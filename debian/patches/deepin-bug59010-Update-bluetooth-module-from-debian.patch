From c352753d51b3a269842d04f9791f12246d501b15 Mon Sep 17 00:00:00 2001
From: Chengyi Zhao <zhaochengyi@uniontech.com>
Date: Wed, 3 Feb 2021 11:12:31 +0800
Subject: [PATCH] bluetooth: Update bluetooth module from debian

It comes from pulseaudio (13.0-3~bpo10+1) buster-backports
of debian, the following main points are included:
* Update a2dp-codecs.h from upstream bluez project
* Modular API for A2DP codecs
* Remove BlueZ 4 related code
---
 configure.ac                                  |   16 +-
 po/POTFILES.in                                |    1 -
 po/be.po                                      |   16 -
 po/de.po                                      |   16 -
 po/el.po                                      |   16 -
 po/fr.po                                      |   16 -
 po/hr.po                                      |   16 -
 po/hu.po                                      |   16 -
 po/id.po                                      |   16 -
 po/it.po                                      |   16 -
 po/lt.po                                      |   16 -
 po/nn.po                                      |   16 -
 po/oc.po                                      |   16 -
 po/pl.po                                      |   16 -
 po/pt_BR.po                                   |   16 -
 po/ru.po                                      |   16 -
 po/sk.po                                      |   16 -
 po/sv.po                                      |   16 -
 po/tr.po                                      |   16 -
 po/uk.po                                      |   16 -
 po/zh_CN.po                                   |   16 -
 po/zh_TW.po                                   |   16 -
 src/Makefile.am                               |   41 +-
 src/modules/bluetooth/a2dp-codec-api.h        |   98 +
 src/modules/bluetooth/a2dp-codec-sbc.c        |  682 +++++
 src/modules/bluetooth/a2dp-codec-util.c       |   56 +
 src/modules/bluetooth/a2dp-codec-util.h       |   34 +
 src/modules/bluetooth/a2dp-codecs.h           |  336 ++-
 src/modules/bluetooth/backend-ofono.c         |  134 +-
 src/modules/bluetooth/bluez4-util.c           | 1851 ------------
 src/modules/bluetooth/bluez4-util.h           |  160 -
 src/modules/bluetooth/bluez5-util.c           |  349 +--
 src/modules/bluetooth/bluez5-util.h           |    6 +
 .../bluetooth/module-bluetooth-discover.c     |   17 +-
 .../bluetooth/module-bluetooth-policy.c       |   30 +-
 src/modules/bluetooth/module-bluez4-device.c  | 2664 -----------------
 .../bluetooth/module-bluez4-discover.c        |  187 --
 src/modules/bluetooth/module-bluez5-device.c  |  633 ++--
 .../bluetooth/module-bluez5-discover.c        |    1 +
 src/modules/bluetooth/rtp.h                   |   58 +-
 40 files changed, 1724 insertions(+), 5950 deletions(-)
 create mode 100644 src/modules/bluetooth/a2dp-codec-api.h
 create mode 100644 src/modules/bluetooth/a2dp-codec-sbc.c
 create mode 100644 src/modules/bluetooth/a2dp-codec-util.c
 create mode 100644 src/modules/bluetooth/a2dp-codec-util.h
 delete mode 100644 src/modules/bluetooth/bluez4-util.c
 delete mode 100644 src/modules/bluetooth/bluez4-util.h
 delete mode 100644 src/modules/bluetooth/module-bluez4-device.c
 delete mode 100644 src/modules/bluetooth/module-bluez4-discover.c

diff --git a/configure.ac b/configure.ac
index 3165b9a..356990d 100644
--- a/configure.ac
+++ b/configure.ac
@@ -1071,24 +1071,14 @@ AX_DEFINE_DIR(PA_MACHINE_ID_FALLBACK, PA_MACHINE_ID_FALLBACK,
 
 #### BlueZ support (optional, dependent on D-Bus and SBC) ####
 
-AC_ARG_ENABLE([bluez4],
-    AS_HELP_STRING([--disable-bluez4],[Disable optional BlueZ 4 support]))
 AC_ARG_ENABLE([bluez5],
     AS_HELP_STRING([--disable-bluez5],[Disable optional BlueZ 5 support]))
 
 ## SBC ##
-AS_IF([test "x$enable_bluez4" != "xno" || test "x$enable_bluez5" != "xno"],
+AS_IF([test "x$enable_bluez5" != "xno"],
     [PKG_CHECK_MODULES(SBC, [ sbc >= 1.0 ], HAVE_SBC=1, HAVE_SBC=0)],
     HAVE_SBC=0)
 
-## BlueZ 4 ##
-AS_IF([test "x$enable_bluez4" != "xno" && test "x$HAVE_DBUS" = "x1" && test "x$HAVE_SBC" = "x1"], HAVE_BLUEZ_4=1,
-      HAVE_BLUEZ_4=0)
-AS_IF([test "x$enable_bluez4" = "xyes" && test "x$HAVE_BLUEZ_4" != "x1"],
-    [AC_MSG_ERROR([*** BLUEZ 4 support not found (requires sbc and D-Bus)])])
-AC_SUBST(HAVE_BLUEZ_4)
-AM_CONDITIONAL([HAVE_BLUEZ_4], [test "x$HAVE_BLUEZ_4" = x1])
-
 ## BlueZ 5 ##
 AS_IF([test "x$enable_bluez5" != "xno" && test "x$HAVE_DBUS" = "x1" && test "x$HAVE_SBC" = "x1"], HAVE_BLUEZ_5=1,
       HAVE_BLUEZ_5=0)
@@ -1097,7 +1087,7 @@ AS_IF([test "x$enable_bluez5" = "xyes" && test "x$HAVE_BLUEZ_5" != "x1"],
 AC_SUBST(HAVE_BLUEZ_5)
 AM_CONDITIONAL([HAVE_BLUEZ_5], [test "x$HAVE_BLUEZ_5" = x1])
 
-AS_IF([test "x$HAVE_BLUEZ_4" = "x1" || test "x$HAVE_BLUEZ_5" = "x1"], HAVE_BLUEZ=1, HAVE_BLUEZ=0)
+AS_IF([test "x$HAVE_BLUEZ_5" = "x1"], HAVE_BLUEZ=1, HAVE_BLUEZ=0)
 AC_SUBST(HAVE_BLUEZ)
 AM_CONDITIONAL([HAVE_BLUEZ], [test "x$HAVE_BLUEZ" = x1])
 
@@ -1604,7 +1594,6 @@ AS_IF([test "x$HAVE_UDEV" = "x1"], ENABLE_UDEV=yes, ENABLE_UDEV=no)
 AS_IF([test "x$HAVE_SYSTEMD_DAEMON" = "x1"], ENABLE_SYSTEMD_DAEMON=yes, ENABLE_SYSTEMD_DAEMON=no)
 AS_IF([test "x$HAVE_SYSTEMD_LOGIN" = "x1"], ENABLE_SYSTEMD_LOGIN=yes, ENABLE_SYSTEMD_LOGIN=no)
 AS_IF([test "x$HAVE_SYSTEMD_JOURNAL" = "x1"], ENABLE_SYSTEMD_JOURNAL=yes, ENABLE_SYSTEMD_JOURNAL=no)
-AS_IF([test "x$HAVE_BLUEZ_4" = "x1"], ENABLE_BLUEZ_4=yes, ENABLE_BLUEZ_4=no)
 AS_IF([test "x$HAVE_BLUEZ_5" = "x1"], ENABLE_BLUEZ_5=yes, ENABLE_BLUEZ_5=no)
 AS_IF([test "x$HAVE_BLUEZ_5_OFONO_HEADSET" = "x1"], ENABLE_BLUEZ_5_OFONO_HEADSET=yes, ENABLE_BLUEZ_5_OFONO_HEADSET=no)
 AS_IF([test "x$HAVE_BLUEZ_5_NATIVE_HEADSET" = "x1"], ENABLE_BLUEZ_5_NATIVE_HEADSET=yes, ENABLE_BLUEZ_5_NATIVE_HEADSET=no)
@@ -1663,7 +1652,6 @@ echo "
     Enable Async DNS:              ${ENABLE_LIBASYNCNS}
     Enable LIRC:                   ${ENABLE_LIRC}
     Enable D-Bus:                  ${ENABLE_DBUS}
-      Enable BlueZ 4:              ${ENABLE_BLUEZ_4}
       Enable BlueZ 5:              ${ENABLE_BLUEZ_5}
         Enable ofono headsets:     ${ENABLE_BLUEZ_5_OFONO_HEADSET}
         Enable native headsets:    ${ENABLE_BLUEZ_5_NATIVE_HEADSET}
diff --git a/po/POTFILES.in b/po/POTFILES.in
index 75a35c3..0b51946 100644
--- a/po/POTFILES.in
+++ b/po/POTFILES.in
@@ -14,7 +14,6 @@ src/modules/alsa/alsa-util.c
 src/modules/alsa/module-alsa-card.c
 src/modules/alsa/module-alsa-sink.c
 src/modules/alsa/module-alsa-source.c
-src/modules/bluetooth/module-bluez4-device.c
 src/modules/bluetooth/module-bluez5-device.c
 src/modules/echo-cancel/module-echo-cancel.c
 src/modules/gconf/gconf-helper.c
diff --git a/po/be.po b/po/be.po
index 162c555..3079078 100644
--- a/po/be.po
+++ b/po/be.po
@@ -591,7 +591,6 @@ msgid "Line In"
 msgstr "Лінейны ўваход"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1710
 msgid "Microphone"
 msgstr "Мікрафон"
@@ -653,7 +652,6 @@ msgid "No Bass Boost"
 msgstr "Без ўзмацнення басоў"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1717
 msgid "Speaker"
 msgstr "Дынамік"
@@ -826,7 +824,6 @@ msgstr "Шматканальны дуплекс"
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2295
 #: ../src/modules/bluetooth/module-bluez5-device.c:1941
 msgid "Off"
 msgstr "Адключаны"
@@ -961,49 +958,40 @@ msgstr ""
 "Хутчэй за ўсё, гэта памылка ў ALSA-драйверы «%s». Калі ласка, паведаміце аб"
 " гэтым распрацоўнікам ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2089
 #: ../src/modules/bluetooth/module-bluez5-device.c:1700
 msgid "Headset"
 msgstr "Гарнітура"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1705
 msgid "Handsfree"
 msgstr "Хэндс-фры"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1723
 msgid "Headphone"
 msgstr "Навушнік"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1728
 msgid "Portable"
 msgstr "Партатыўная сістэма"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1733
 msgid "Car"
 msgstr "Аўтамабільная сістэма"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1738
 msgid "HiFi"
 msgstr "Hi-Fi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1743
 msgid "Phone"
 msgstr "Тэлефон"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2137
 #: ../src/modules/bluetooth/module-bluez5-device.c:1695
 #: ../src/modules/bluetooth/module-bluez5-device.c:1711
 #: ../src/modules/bluetooth/module-bluez5-device.c:1749
 msgid "Bluetooth Output"
 msgstr "Bluetooth-выхад"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2140
 #: ../src/modules/bluetooth/module-bluez5-device.c:1694
 #: ../src/modules/bluetooth/module-bluez5-device.c:1716
 #: ../src/modules/bluetooth/module-bluez5-device.c:1722
@@ -1011,19 +999,15 @@ msgstr "Bluetooth-выхад"
 msgid "Bluetooth Input"
 msgstr "Bluetooth-уваход"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2176
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Прайграванне высокай якасці (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2187
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Захоп высокай якасці (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Тэлефонны дуплекс (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Handsfree Gateway"
 msgstr "Шлюз хэндс-фры"
 
diff --git a/po/de.po b/po/de.po
index e73b652..6081387 100644
--- a/po/de.po
+++ b/po/de.po
@@ -602,7 +602,6 @@ msgid "Line In"
 msgstr "Line-Eingang"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1710
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -664,7 +663,6 @@ msgid "No Bass Boost"
 msgstr "Keine Bassverstärkung"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1717
 msgid "Speaker"
 msgstr "Lautsprecher"
@@ -837,7 +835,6 @@ msgstr "Mehrkanal-Duplex"
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2319
 #: ../src/modules/bluetooth/module-bluez5-device.c:1965
 msgid "Off"
 msgstr "Aus"
@@ -976,49 +973,40 @@ msgstr ""
 "Dies ist wahrscheinlich ein Fehler im ALSA-Treiber »%s«. Bitte melden Sie "
 "dieses Problem den ALSA-Entwicklern."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2089
 #: ../src/modules/bluetooth/module-bluez5-device.c:1700
 msgid "Headset"
 msgstr "Headset"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1705
 msgid "Handsfree"
 msgstr "Freisprecheinrichtung"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1723
 msgid "Headphone"
 msgstr "Kopfhörer"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1728
 msgid "Portable"
 msgstr ""
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1733
 msgid "Car"
 msgstr "Auto"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1738
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1743
 msgid "Phone"
 msgstr "Telefon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2137
 #: ../src/modules/bluetooth/module-bluez5-device.c:1695
 #: ../src/modules/bluetooth/module-bluez5-device.c:1711
 #: ../src/modules/bluetooth/module-bluez5-device.c:1749
 msgid "Bluetooth Output"
 msgstr "Bluetooth-Ausgabe"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2140
 #: ../src/modules/bluetooth/module-bluez5-device.c:1694
 #: ../src/modules/bluetooth/module-bluez5-device.c:1716
 #: ../src/modules/bluetooth/module-bluez5-device.c:1722
@@ -1026,19 +1014,15 @@ msgstr "Bluetooth-Ausgabe"
 msgid "Bluetooth Input"
 msgstr "Bluetooth-Eingabe"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2181
 msgid "High Fidelity Playback (A2DP)"
 msgstr "High Fidelity Playback (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2193
 msgid "High Fidelity Capture (A2DP)"
 msgstr "High Fidelity Capture (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2205
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Telephony Duplex (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2218
 msgid "Handsfree Gateway"
 msgstr ""
 
diff --git a/po/el.po b/po/el.po
index cfa0e46..e49702f 100644
--- a/po/el.po
+++ b/po/el.po
@@ -840,7 +840,6 @@ msgid "Line In"
 msgstr "Γραμμή εισόδου"
 
 #: ../src/modules/alsa/alsa-mixer.c:2256 ../src/modules/alsa/alsa-mixer.c:2334
-#: ../src/modules/bluetooth/module-bluez4-device.c:2101
 #: ../src/modules/bluetooth/module-bluez5-device.c:1451
 msgid "Microphone"
 msgstr "Μικρόφωνο"
@@ -902,7 +901,6 @@ msgid "No Bass Boost"
 msgstr "Χωρίς ενίσχυση μπάσων"
 
 #: ../src/modules/alsa/alsa-mixer.c:2271
-#: ../src/modules/bluetooth/module-bluez4-device.c:2106
 #: ../src/modules/bluetooth/module-bluez5-device.c:1458
 msgid "Speaker"
 msgstr "Ηχείο"
@@ -1057,7 +1055,6 @@ msgstr "Ψηφιακός στερεοφωνικός αμφίδρομος (IEC958
 
 #: ../src/modules/alsa/alsa-mixer.c:3959
 #: ../src/modules/alsa/module-alsa-card.c:193
-#: ../src/modules/bluetooth/module-bluez4-device.c:2297
 #: ../src/modules/bluetooth/module-bluez5-device.c:1656
 msgid "Off"
 msgstr "Ανενεργό"
@@ -1158,49 +1155,40 @@ msgstr ""
 "Το πιθανότερο αυτό είναι ένα σφάλμα στον οδηγό ALSA '%s'. Παρακαλούμε, "
 "αναφέρτε αυτό το θέμα στους προγραμματιστές ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2091
 #: ../src/modules/bluetooth/module-bluez5-device.c:1441
 msgid "Headset"
 msgstr "Ακουστικά"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2096
 #: ../src/modules/bluetooth/module-bluez5-device.c:1446
 msgid "Handsfree"
 msgstr "Ανοιχτής ακρόασης"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2111
 #: ../src/modules/bluetooth/module-bluez5-device.c:1464
 msgid "Headphone"
 msgstr "Ακουστικό"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2116
 #: ../src/modules/bluetooth/module-bluez5-device.c:1469
 msgid "Portable"
 msgstr "Φορητό"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2121
 #: ../src/modules/bluetooth/module-bluez5-device.c:1474
 msgid "Car"
 msgstr "Αυτοκίνητο"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2126
 #: ../src/modules/bluetooth/module-bluez5-device.c:1479
 msgid "HiFi"
 msgstr "Υψηλή πιστότητα"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2131
 #: ../src/modules/bluetooth/module-bluez5-device.c:1484
 msgid "Phone"
 msgstr "Τηλέφωνο"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2139
 #: ../src/modules/bluetooth/module-bluez5-device.c:1436
 #: ../src/modules/bluetooth/module-bluez5-device.c:1452
 #: ../src/modules/bluetooth/module-bluez5-device.c:1490
 msgid "Bluetooth Output"
 msgstr "Έξοδος μπλουτούθ"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1435
 #: ../src/modules/bluetooth/module-bluez5-device.c:1457
 #: ../src/modules/bluetooth/module-bluez5-device.c:1463
@@ -1208,19 +1196,15 @@ msgstr "Έξοδος μπλουτούθ"
 msgid "Bluetooth Input"
 msgstr "Είσοδος μπλουτούθ"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2178
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Αναπαραγωγή υψηλής ποιότητα (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2189
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Λήψη υψηλής ποιότητας (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2200
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Αμφίδρομη τηλεφωνία (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2212
 msgid "Handsfree Gateway"
 msgstr "Πύλη ανοιχτής ακρόασης"
 
diff --git a/po/fr.po b/po/fr.po
index 6a682c5..d970c04 100644
--- a/po/fr.po
+++ b/po/fr.po
@@ -606,7 +606,6 @@ msgid "Line In"
 msgstr "Entrée ligne"
 
 #: ../src/modules/alsa/alsa-mixer.c:2296 ../src/modules/alsa/alsa-mixer.c:2374
-#: ../src/modules/bluetooth/module-bluez4-device.c:2102
 #: ../src/modules/bluetooth/module-bluez5-device.c:1710
 msgid "Microphone"
 msgstr "Microphone"
@@ -668,7 +667,6 @@ msgid "No Bass Boost"
 msgstr "Pas de booster de basses"
 
 #: ../src/modules/alsa/alsa-mixer.c:2311
-#: ../src/modules/bluetooth/module-bluez4-device.c:2107
 #: ../src/modules/bluetooth/module-bluez5-device.c:1717
 msgid "Speaker"
 msgstr "Haut-parleur"
@@ -823,7 +821,6 @@ msgstr "Duplex stéréo numérique (IEC958)"
 
 #: ../src/modules/alsa/alsa-mixer.c:4052
 #: ../src/modules/alsa/module-alsa-card.c:190
-#: ../src/modules/bluetooth/module-bluez4-device.c:2298
 #: ../src/modules/bluetooth/module-bluez5-device.c:1941
 msgid "Off"
 msgstr "Éteint"
@@ -924,49 +921,40 @@ msgstr ""
 "Il s'agit très probablement d'un bogue dans le pilote ALSA « %s ». Veuillez "
 "rapporter ce problème aux développeurs d'ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2092
 #: ../src/modules/bluetooth/module-bluez5-device.c:1700
 msgid "Headset"
 msgstr "Casque"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2097
 #: ../src/modules/bluetooth/module-bluez5-device.c:1705
 msgid "Handsfree"
 msgstr "Mains-libres"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2112
 #: ../src/modules/bluetooth/module-bluez5-device.c:1723
 msgid "Headphone"
 msgstr "Écouteurs"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2117
 #: ../src/modules/bluetooth/module-bluez5-device.c:1728
 msgid "Portable"
 msgstr "Portable"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2122
 #: ../src/modules/bluetooth/module-bluez5-device.c:1733
 msgid "Car"
 msgstr "Voiture"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2127
 #: ../src/modules/bluetooth/module-bluez5-device.c:1738
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2132
 #: ../src/modules/bluetooth/module-bluez5-device.c:1743
 msgid "Phone"
 msgstr "Téléphone"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2140
 #: ../src/modules/bluetooth/module-bluez5-device.c:1695
 #: ../src/modules/bluetooth/module-bluez5-device.c:1711
 #: ../src/modules/bluetooth/module-bluez5-device.c:1749
 msgid "Bluetooth Output"
 msgstr "Sortie Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2143
 #: ../src/modules/bluetooth/module-bluez5-device.c:1694
 #: ../src/modules/bluetooth/module-bluez5-device.c:1716
 #: ../src/modules/bluetooth/module-bluez5-device.c:1722
@@ -974,19 +962,15 @@ msgstr "Sortie Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Entrée Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2179
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Lecture haute fidélité (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2190
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Capture haute fidélité (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2201
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Telephonie en duplex (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2213
 msgid "Handsfree Gateway"
 msgstr "Passerelle Mains-libres"
 
diff --git a/po/hr.po b/po/hr.po
index 3afd720..c60687e 100644
--- a/po/hr.po
+++ b/po/hr.po
@@ -597,7 +597,6 @@ msgid "Line In"
 msgstr "Ulaz"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1696
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -659,7 +658,6 @@ msgid "No Bass Boost"
 msgstr "Bez pojačanja basa"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1703
 msgid "Speaker"
 msgstr "Zvučnik"
@@ -832,7 +830,6 @@ msgstr "Višekanalni obostrani"
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:1951
 msgid "Off"
 msgstr "Isključeno"
@@ -967,49 +964,40 @@ msgstr ""
 "Najvjerojatnije je ovo greška ALSA upravljačkog programa '%s'. Prijavite "
 "problem ALSA razvijateljima."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1686
 msgid "Headset"
 msgstr "Slušalice s mikrofonom"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1691
 msgid "Handsfree"
 msgstr "Bez-ruku"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1709
 msgid "Headphone"
 msgstr "Slušalice"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1714
 msgid "Portable"
 msgstr "Prijenosnik"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1719
 msgid "Car"
 msgstr "Automobil"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1724
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1729
 msgid "Phone"
 msgstr "Telefon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1681
 #: ../src/modules/bluetooth/module-bluez5-device.c:1697
 #: ../src/modules/bluetooth/module-bluez5-device.c:1735
 msgid "Bluetooth Output"
 msgstr "Bluetooth izlaz"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1680
 #: ../src/modules/bluetooth/module-bluez5-device.c:1702
 #: ../src/modules/bluetooth/module-bluez5-device.c:1708
@@ -1017,19 +1005,15 @@ msgstr "Bluetooth izlaz"
 msgid "Bluetooth Input"
 msgstr "Bluetooth ulaz"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Reprodukcija visoke autentičnosti (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Snimanje visoke autentičnosti (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Obostrana telefonija (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "Bezručni pristupnik"
 
diff --git a/po/hu.po b/po/hu.po
index bcb39d8..1e364fc 100644
--- a/po/hu.po
+++ b/po/hu.po
@@ -609,7 +609,6 @@ msgid "Line In"
 msgstr "Vonalbemenet"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1710
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -671,7 +670,6 @@ msgid "No Bass Boost"
 msgstr "Nincs basszuskiemelés"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1717
 msgid "Speaker"
 msgstr "Hangszóró"
@@ -844,7 +842,6 @@ msgstr "Többcsatornás duplex"
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2319
 #: ../src/modules/bluetooth/module-bluez5-device.c:1965
 msgid "Off"
 msgstr "Kikapcsolva"
@@ -983,50 +980,41 @@ msgstr ""
 "Ez valószínűleg egy hiba eredménye az ALSA „%s” illesztőprogramban. Jelentse "
 "ezt a problémát az ALSA fejlesztői felé."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2089
 #: ../src/modules/bluetooth/module-bluez5-device.c:1700
 msgid "Headset"
 msgstr "Fejhallgató"
 
 # FIXME: utánanézni
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1705
 msgid "Handsfree"
 msgstr "Kihangosító"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1723
 msgid "Headphone"
 msgstr "Fülhallgató"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1728
 msgid "Portable"
 msgstr "Hordozható"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1733
 msgid "Car"
 msgstr "Autó"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1738
 msgid "HiFi"
 msgstr "Hi-Fi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1743
 msgid "Phone"
 msgstr "Telefon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2137
 #: ../src/modules/bluetooth/module-bluez5-device.c:1695
 #: ../src/modules/bluetooth/module-bluez5-device.c:1711
 #: ../src/modules/bluetooth/module-bluez5-device.c:1749
 msgid "Bluetooth Output"
 msgstr "Bluetooth kimenet"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2140
 #: ../src/modules/bluetooth/module-bluez5-device.c:1694
 #: ../src/modules/bluetooth/module-bluez5-device.c:1716
 #: ../src/modules/bluetooth/module-bluez5-device.c:1722
@@ -1034,19 +1022,15 @@ msgstr "Bluetooth kimenet"
 msgid "Bluetooth Input"
 msgstr "Bluetooth bemenet"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2181
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Hi-Fi lejátszás (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2193
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Hi-Fi felvétel (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2205
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Telefon duplex (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2218
 msgid "Handsfree Gateway"
 msgstr "Kihangosító átjáró"
 
diff --git a/po/id.po b/po/id.po
index d61df67..4d3b7ee 100644
--- a/po/id.po
+++ b/po/id.po
@@ -590,7 +590,6 @@ msgid "Line In"
 msgstr "Jalur Masuk"
 
 #: ../src/modules/alsa/alsa-mixer.c:2448 ../src/modules/alsa/alsa-mixer.c:2526
-#: ../src/modules/bluetooth/module-bluez4-device.c:2103
 #: ../src/modules/bluetooth/module-bluez5-device.c:1781
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -652,7 +651,6 @@ msgid "No Bass Boost"
 msgstr "Tanpa Boost Bass"
 
 #: ../src/modules/alsa/alsa-mixer.c:2463
-#: ../src/modules/bluetooth/module-bluez4-device.c:2108
 #: ../src/modules/bluetooth/module-bluez5-device.c:1788
 msgid "Speaker"
 msgstr "Speaker"
@@ -839,7 +837,6 @@ msgstr "Dupleks Stereo"
 
 #: ../src/modules/alsa/alsa-mixer.c:4226
 #: ../src/modules/alsa/module-alsa-card.c:185
-#: ../src/modules/bluetooth/module-bluez4-device.c:2323
 #: ../src/modules/bluetooth/module-bluez5-device.c:2036
 msgid "Off"
 msgstr "Mati"
@@ -974,49 +971,40 @@ msgstr ""
 "Sangat mungkin ini adalah kutu pada driver ALSA '%s'. Silakan laporkan hal "
 "ini ke para pengembang ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2093
 #: ../src/modules/bluetooth/module-bluez5-device.c:1771
 msgid "Headset"
 msgstr "Headset"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2098
 #: ../src/modules/bluetooth/module-bluez5-device.c:1776
 msgid "Handsfree"
 msgstr "Handsfree"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2113
 #: ../src/modules/bluetooth/module-bluez5-device.c:1794
 msgid "Headphone"
 msgstr "Headphone"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2118
 #: ../src/modules/bluetooth/module-bluez5-device.c:1799
 msgid "Portable"
 msgstr "Portabel"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2123
 #: ../src/modules/bluetooth/module-bluez5-device.c:1804
 msgid "Car"
 msgstr "Mobil"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2128
 #: ../src/modules/bluetooth/module-bluez5-device.c:1809
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2133
 #: ../src/modules/bluetooth/module-bluez5-device.c:1814
 msgid "Phone"
 msgstr "Telepon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2141
 #: ../src/modules/bluetooth/module-bluez5-device.c:1766
 #: ../src/modules/bluetooth/module-bluez5-device.c:1782
 #: ../src/modules/bluetooth/module-bluez5-device.c:1820
 msgid "Bluetooth Output"
 msgstr "Keluaran Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2144
 #: ../src/modules/bluetooth/module-bluez5-device.c:1765
 #: ../src/modules/bluetooth/module-bluez5-device.c:1787
 #: ../src/modules/bluetooth/module-bluez5-device.c:1793
@@ -1024,19 +1012,15 @@ msgstr "Keluaran Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Masukan Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2185
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Main Ulang High Fidelity (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2197
 msgid "High Fidelity Capture (A2DP)"
 msgstr "High Fidelity Capture (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2209
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Dupleks Teleponi (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2222
 msgid "Handsfree Gateway"
 msgstr "Gateway Handsfree"
 
diff --git a/po/it.po b/po/it.po
index d71d74c..0e3dc64 100644
--- a/po/it.po
+++ b/po/it.po
@@ -619,7 +619,6 @@ msgid "Line In"
 msgstr "Line-In"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1750
 msgid "Microphone"
 msgstr "Microfono"
@@ -681,7 +680,6 @@ msgid "No Bass Boost"
 msgstr "Nessun incremento bassi"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1757
 msgid "Speaker"
 msgstr "Altoparlante"
@@ -862,7 +860,6 @@ msgstr "Duplex stereo"
 
 #: ../src/modules/alsa/alsa-mixer.c:4157
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:2005
 msgid "Off"
 msgstr "Spento"
@@ -995,49 +992,40 @@ msgstr ""
 "Molto probabilmente si tratta di un bug nel driver ALSA \"%s\". Segnalare "
 "questo problema agli sviluppatori ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1740
 msgid "Headset"
 msgstr "Cuffie con microfono"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1745
 msgid "Handsfree"
 msgstr "Sistema mani-libere"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1763
 msgid "Headphone"
 msgstr "Cuffie"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1768
 msgid "Portable"
 msgstr "Portabile"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1773
 msgid "Car"
 msgstr "Automobile"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1778
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1783
 msgid "Phone"
 msgstr "Telefono"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1735
 #: ../src/modules/bluetooth/module-bluez5-device.c:1751
 #: ../src/modules/bluetooth/module-bluez5-device.c:1789
 msgid "Bluetooth Output"
 msgstr "Uscita Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1734
 #: ../src/modules/bluetooth/module-bluez5-device.c:1756
 #: ../src/modules/bluetooth/module-bluez5-device.c:1762
@@ -1045,19 +1033,15 @@ msgstr "Uscita Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Ingresso Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Riproduzione ad alta fedeltà (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Cattura ad alta fedeltà (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Doppino telefonico (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "Gateway handsfree"
 
diff --git a/po/lt.po b/po/lt.po
index b2e210c..cf7bf8a 100644
--- a/po/lt.po
+++ b/po/lt.po
@@ -603,7 +603,6 @@ msgid "Line In"
 msgstr "Įvadinė linija"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1783
 msgid "Microphone"
 msgstr "Mikrofonas"
@@ -665,7 +664,6 @@ msgid "No Bass Boost"
 msgstr "Be žemų tonų pastiprinimo"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1790
 msgid "Speaker"
 msgstr "Garsiakalbis"
@@ -863,7 +861,6 @@ msgstr "Dvipusė stereo"
 
 #: ../src/modules/alsa/alsa-mixer.c:4158
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:2038
 msgid "Off"
 msgstr "Išjungta"
@@ -998,49 +995,40 @@ msgstr ""
 "Greičiausiai, tai yra klaida ALSA \"'%s\" tvarkyklėje. Prašome apie šią "
 "klaidą pranešti ALSA kūrėjams."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1773
 msgid "Headset"
 msgstr "Ausinės su mikrofonu"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1778
 msgid "Handsfree"
 msgstr "Laisvų rankų įranga"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1796
 msgid "Headphone"
 msgstr "Ausinė"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1801
 msgid "Portable"
 msgstr "Portatyvi sistema"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1806
 msgid "Car"
 msgstr "Automobilis"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1811
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1816
 msgid "Phone"
 msgstr "Telefonas"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1768
 #: ../src/modules/bluetooth/module-bluez5-device.c:1784
 #: ../src/modules/bluetooth/module-bluez5-device.c:1822
 msgid "Bluetooth Output"
 msgstr "Bluetooth išvestis"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1767
 #: ../src/modules/bluetooth/module-bluez5-device.c:1789
 #: ../src/modules/bluetooth/module-bluez5-device.c:1795
@@ -1048,19 +1036,15 @@ msgstr "Bluetooth išvestis"
 msgid "Bluetooth Input"
 msgstr "Bluetooth įvestis"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Aukštos kokybės atkūrimas (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Aukštos kokybės paėmimas (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Telefoninė dvipusė (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "Laisvų rankų įrangos tinklų sietuvas"
 
diff --git a/po/nn.po b/po/nn.po
index f6121d1..898a271 100644
--- a/po/nn.po
+++ b/po/nn.po
@@ -568,7 +568,6 @@ msgid "Line In"
 msgstr "Linje inn"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1750
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -643,7 +642,6 @@ msgid "No Bass Boost"
 msgstr "Inga bassforsterking"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1757
 msgid "Speaker"
 msgstr "Høgtalar"
@@ -845,7 +843,6 @@ msgstr "Stereo dupleks"
 
 #: ../src/modules/alsa/alsa-mixer.c:4157
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:2005
 msgid "Off"
 msgstr "Av"
@@ -943,50 +940,42 @@ msgstr ""
 "snd_pcm_mmap_begin() gav ein verdi som er uvanleg stor: %lu byte (%lu ms).\n"
 "Dette kjem truleg av ein feil i ALSA-drivaren «%s». Meld frå om problemet til ALSA-utviklarane."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1740
 #| msgctxt "This device is a Headset"
 #| msgid "Headset"
 msgid "Headset"
 msgstr "Hovudsett"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1745
 #| msgctxt "For holding pieces"
 #| msgid "Hand"
 msgid "Handsfree"
 msgstr "Handfri"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1763
 msgid "Headphone"
 msgstr "Hovudtelefonar"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1768
 #| msgctxt "portugal_districts.kgm"
 #| msgid "Portalegre"
 msgid "Portable"
 msgstr "Portabel"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1773
 msgid "Car"
 msgstr "Bil"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1778
 msgid "HiFi"
 msgstr "Hi-fi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1783
 #| msgctxt "Name"
 #| msgid "Phone"
 msgid "Phone"
 msgstr "Telefon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1735
 #: ../src/modules/bluetooth/module-bluez5-device.c:1751
 #: ../src/modules/bluetooth/module-bluez5-device.c:1789
@@ -995,7 +984,6 @@ msgstr "Telefon"
 msgid "Bluetooth Output"
 msgstr "Bluetooth-utlyd"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1734
 #: ../src/modules/bluetooth/module-bluez5-device.c:1756
 #: ../src/modules/bluetooth/module-bluez5-device.c:1762
@@ -1005,19 +993,15 @@ msgstr "Bluetooth-utlyd"
 msgid "Bluetooth Input"
 msgstr "Bluetooth-innlyd"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Hi-fi-avspeling (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Hi-fi-opptak (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Telefon dupleks (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "Handfri-portnar"
 
diff --git a/po/oc.po b/po/oc.po
index 4a65fb5..5fb403d 100644
--- a/po/oc.po
+++ b/po/oc.po
@@ -521,7 +521,6 @@ msgid "Line In"
 msgstr "Entrada linha"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2173
 #: ../src/modules/bluetooth/module-bluez5-device.c:1937
 msgid "Microphone"
 msgstr "Micrò"
@@ -583,7 +582,6 @@ msgid "No Bass Boost"
 msgstr "Pas d'amplificacion de las bassas"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2178
 #: ../src/modules/bluetooth/module-bluez5-device.c:1944
 msgid "Speaker"
 msgstr "Nautparlaire"
@@ -756,7 +754,6 @@ msgstr ""
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2369
 #: ../src/modules/bluetooth/module-bluez5-device.c:2173
 #: ../src/modules/droid/module-droid-card.c:221
 msgid "Off"
@@ -880,49 +877,40 @@ msgstr ""
 "S'agís fòrt probablament d'un bug dins lo pilòt ALSA « %s ». Raportatz "
 "aqueste problèma als desvolopaires d'ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2163
 #: ../src/modules/bluetooth/module-bluez5-device.c:1927
 msgid "Headset"
 msgstr "Casc àudio"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2168
 #: ../src/modules/bluetooth/module-bluez5-device.c:1932
 msgid "Handsfree"
 msgstr "Mans liuras"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2183
 #: ../src/modules/bluetooth/module-bluez5-device.c:1950
 msgid "Headphone"
 msgstr "Escotadors"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2188
 #: ../src/modules/bluetooth/module-bluez5-device.c:1955
 msgid "Portable"
 msgstr "Portable"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2193
 #: ../src/modules/bluetooth/module-bluez5-device.c:1960
 msgid "Car"
 msgstr "Telefòn de veitura"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 #: ../src/modules/bluetooth/module-bluez5-device.c:1965
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2203
 #: ../src/modules/bluetooth/module-bluez5-device.c:1970
 msgid "Phone"
 msgstr "Telefòn"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2211
 #: ../src/modules/bluetooth/module-bluez5-device.c:1922
 #: ../src/modules/bluetooth/module-bluez5-device.c:1938
 #: ../src/modules/bluetooth/module-bluez5-device.c:1976
 msgid "Bluetooth Output"
 msgstr "Sortida Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2214
 #: ../src/modules/bluetooth/module-bluez5-device.c:1921
 #: ../src/modules/bluetooth/module-bluez5-device.c:1943
 #: ../src/modules/bluetooth/module-bluez5-device.c:1949
@@ -930,19 +918,15 @@ msgstr "Sortida Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Entrada Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2250
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Lectura nauta fidelitat (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2261
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Captura Hi-Fi (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2272
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Telefonia en duplèx (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2284
 msgid "Handsfree Gateway"
 msgstr "Pòrt mans liuras"
 
diff --git a/po/pl.po b/po/pl.po
index 9591cea..84ac7a0 100644
--- a/po/pl.po
+++ b/po/pl.po
@@ -594,7 +594,6 @@ msgid "Line In"
 msgstr "Wejście liniowe"
 
 #: ../src/modules/alsa/alsa-mixer.c:2448 ../src/modules/alsa/alsa-mixer.c:2526
-#: ../src/modules/bluetooth/module-bluez4-device.c:2111
 #: ../src/modules/bluetooth/module-bluez5-device.c:1789
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -656,7 +655,6 @@ msgid "No Bass Boost"
 msgstr "Brak podbicia basów"
 
 #: ../src/modules/alsa/alsa-mixer.c:2463
-#: ../src/modules/bluetooth/module-bluez4-device.c:2116
 #: ../src/modules/bluetooth/module-bluez5-device.c:1796
 msgid "Speaker"
 msgstr "Głośnik"
@@ -841,7 +839,6 @@ msgstr "Dupleks stereo"
 
 #: ../src/modules/alsa/alsa-mixer.c:4226
 #: ../src/modules/alsa/module-alsa-card.c:185
-#: ../src/modules/bluetooth/module-bluez4-device.c:2331
 #: ../src/modules/bluetooth/module-bluez5-device.c:2044
 msgid "Off"
 msgstr "Wyłączone"
@@ -973,49 +970,40 @@ msgstr ""
 "Prawdopodobnie jest to błąd sterownika ALSA „%s”. Proszę zgłosić ten problem "
 "programistom usługi ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2101
 #: ../src/modules/bluetooth/module-bluez5-device.c:1779
 msgid "Headset"
 msgstr "Słuchawki z mikrofonem"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2106
 #: ../src/modules/bluetooth/module-bluez5-device.c:1784
 msgid "Handsfree"
 msgstr "Zestaw głośnomówiący"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2121
 #: ../src/modules/bluetooth/module-bluez5-device.c:1802
 msgid "Headphone"
 msgstr "Słuchawki"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2126
 #: ../src/modules/bluetooth/module-bluez5-device.c:1807
 msgid "Portable"
 msgstr "Przenośne"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2131
 #: ../src/modules/bluetooth/module-bluez5-device.c:1812
 msgid "Car"
 msgstr "Samochód"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2136
 #: ../src/modules/bluetooth/module-bluez5-device.c:1817
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2141
 #: ../src/modules/bluetooth/module-bluez5-device.c:1822
 msgid "Phone"
 msgstr "Telefon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2149
 #: ../src/modules/bluetooth/module-bluez5-device.c:1774
 #: ../src/modules/bluetooth/module-bluez5-device.c:1790
 #: ../src/modules/bluetooth/module-bluez5-device.c:1828
 msgid "Bluetooth Output"
 msgstr "Wyjście Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2152
 #: ../src/modules/bluetooth/module-bluez5-device.c:1773
 #: ../src/modules/bluetooth/module-bluez5-device.c:1795
 #: ../src/modules/bluetooth/module-bluez5-device.c:1801
@@ -1023,19 +1011,15 @@ msgstr "Wyjście Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Wejście Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2193
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Odtwarzanie o wysokiej dokładności (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2205
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Przechwytywanie o wysokiej dokładności (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2217
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Dupleks telefoniczny (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2230
 msgid "Handsfree Gateway"
 msgstr "Zestaw głośnomówiący"
 
diff --git a/po/pt_BR.po b/po/pt_BR.po
index a9fd40b..e7e84bf 100644
--- a/po/pt_BR.po
+++ b/po/pt_BR.po
@@ -605,7 +605,6 @@ msgid "Line In"
 msgstr "Entrada de linha"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2103
 #: ../src/modules/bluetooth/module-bluez5-device.c:1716
 msgid "Microphone"
 msgstr "Microfone"
@@ -673,7 +672,6 @@ msgid "No Bass Boost"
 msgstr "Sem reforço de graves"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2108
 #: ../src/modules/bluetooth/module-bluez5-device.c:1723
 msgid "Speaker"
 msgstr "Auto-falante"
@@ -846,7 +844,6 @@ msgstr "Duplex multicanal"
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2323
 #: ../src/modules/bluetooth/module-bluez5-device.c:1971
 msgid "Off"
 msgstr "Desligado"
@@ -982,50 +979,41 @@ msgstr ""
 "relate esse problema aos desenvolvedores do ALSA."
 
 # Fone de ouvido não se encaixa como tradução aqui, pois há ou pode haver microfone junto.
-#: ../src/modules/bluetooth/module-bluez4-device.c:2093
 #: ../src/modules/bluetooth/module-bluez5-device.c:1706
 msgid "Headset"
 msgstr "Headset"
 
 # Desconheço tradução comum para esta palavra.
-#: ../src/modules/bluetooth/module-bluez4-device.c:2098
 #: ../src/modules/bluetooth/module-bluez5-device.c:1711
 msgid "Handsfree"
 msgstr "Handsfree"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2113
 #: ../src/modules/bluetooth/module-bluez5-device.c:1729
 msgid "Headphone"
 msgstr "Fones de ouvido"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2118
 #: ../src/modules/bluetooth/module-bluez5-device.c:1734
 msgid "Portable"
 msgstr "Portátil"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2123
 #: ../src/modules/bluetooth/module-bluez5-device.c:1739
 msgid "Car"
 msgstr "Carro"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2128
 #: ../src/modules/bluetooth/module-bluez5-device.c:1744
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2133
 #: ../src/modules/bluetooth/module-bluez5-device.c:1749
 msgid "Phone"
 msgstr "Telefone"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2141
 #: ../src/modules/bluetooth/module-bluez5-device.c:1701
 #: ../src/modules/bluetooth/module-bluez5-device.c:1717
 #: ../src/modules/bluetooth/module-bluez5-device.c:1755
 msgid "Bluetooth Output"
 msgstr "Saída Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2144
 #: ../src/modules/bluetooth/module-bluez5-device.c:1700
 #: ../src/modules/bluetooth/module-bluez5-device.c:1722
 #: ../src/modules/bluetooth/module-bluez5-device.c:1728
@@ -1033,19 +1021,15 @@ msgstr "Saída Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Entrada Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2185
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Reprodução de alta fidelidade (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2197
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Captura de alta fidelidade (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2209
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Duplex telefônico (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2222
 msgid "Handsfree Gateway"
 msgstr "Gateway de handsfree"
 
diff --git a/po/ru.po b/po/ru.po
index 2e81b07..d69f7f8 100644
--- a/po/ru.po
+++ b/po/ru.po
@@ -779,7 +779,6 @@ msgid "Line In"
 msgstr "Линейный вход"
 
 #: ../src/modules/alsa/alsa-mixer.c:2256 ../src/modules/alsa/alsa-mixer.c:2334
-#: ../src/modules/bluetooth/module-bluez4-device.c:2101
 #: ../src/modules/bluetooth/module-bluez5-device.c:1451
 msgid "Microphone"
 msgstr "Микрофон"
@@ -843,7 +842,6 @@ msgid "No Bass Boost"
 msgstr "Нет усиления басов"
 
 #: ../src/modules/alsa/alsa-mixer.c:2271
-#: ../src/modules/bluetooth/module-bluez4-device.c:2106
 #: ../src/modules/bluetooth/module-bluez5-device.c:1458
 msgid "Speaker"
 msgstr "Динамик"
@@ -998,7 +996,6 @@ msgstr "Цифровой стерео дуплекс (IEC958)"
 
 #: ../src/modules/alsa/alsa-mixer.c:3959
 #: ../src/modules/alsa/module-alsa-card.c:193
-#: ../src/modules/bluetooth/module-bluez4-device.c:2297
 #: ../src/modules/bluetooth/module-bluez5-device.c:1656
 msgid "Off"
 msgstr "Выключено"
@@ -1101,50 +1098,41 @@ msgstr ""
 "Вероятно, это ошибка в драйвере ALSA «%s». Пожалуйста, сообщите об этой "
 "проблеме разработчикам ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2091
 #: ../src/modules/bluetooth/module-bluez5-device.c:1441
 msgid "Headset"
 msgstr "Гарнитура"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2096
 #: ../src/modules/bluetooth/module-bluez5-device.c:1446
 msgid "Handsfree"
 msgstr "Хендс-фри"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2111
 #: ../src/modules/bluetooth/module-bluez5-device.c:1464
 msgid "Headphone"
 msgstr "Наушник"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2116
 #: ../src/modules/bluetooth/module-bluez5-device.c:1469
 msgid "Portable"
 msgstr "Портативный динамик"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2121
 #: ../src/modules/bluetooth/module-bluez5-device.c:1474
 msgid "Car"
 msgstr "Автомобильный динамик"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2126
 #: ../src/modules/bluetooth/module-bluez5-device.c:1479
 msgid "HiFi"
 msgstr "Hi-Fi"
 
 # BUGME: please clarify, does this mean a cell phone? --aspotashev
-#: ../src/modules/bluetooth/module-bluez4-device.c:2131
 #: ../src/modules/bluetooth/module-bluez5-device.c:1484
 msgid "Phone"
 msgstr "Телефон"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2139
 #: ../src/modules/bluetooth/module-bluez5-device.c:1436
 #: ../src/modules/bluetooth/module-bluez5-device.c:1452
 #: ../src/modules/bluetooth/module-bluez5-device.c:1490
 msgid "Bluetooth Output"
 msgstr "Выход Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1435
 #: ../src/modules/bluetooth/module-bluez5-device.c:1457
 #: ../src/modules/bluetooth/module-bluez5-device.c:1463
@@ -1152,19 +1140,15 @@ msgstr "Выход Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Вход Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2178
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Воспроизведение высокого качества (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2189
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Запись высокого качества (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2200
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Дуплексная телефония (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2212
 msgid "Handsfree Gateway"
 msgstr "Шлюз передачи данных для хендс-фри"
 
diff --git a/po/sk.po b/po/sk.po
index 730c234..3fdc786 100644
--- a/po/sk.po
+++ b/po/sk.po
@@ -495,7 +495,6 @@ msgid "Line In"
 msgstr "Vstupná linka"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1710
 msgid "Microphone"
 msgstr "Mikrofón"
@@ -557,7 +556,6 @@ msgid "No Bass Boost"
 msgstr "Bez zosilnenia basov"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1717
 msgid "Speaker"
 msgstr "Reproduktor"
@@ -730,7 +728,6 @@ msgstr "Obojsmerný viackanálový"
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2295
 #: ../src/modules/bluetooth/module-bluez5-device.c:1941
 msgid "Off"
 msgstr "Vypnuté"
@@ -825,49 +822,40 @@ msgid ""
 "to the ALSA developers."
 msgstr ""
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2089
 #: ../src/modules/bluetooth/module-bluez5-device.c:1700
 msgid "Headset"
 msgstr "Headset"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1705
 msgid "Handsfree"
 msgstr "Handsfree"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1723
 msgid "Headphone"
 msgstr "Slúchadlo"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1728
 msgid "Portable"
 msgstr "Prenosné"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1733
 msgid "Car"
 msgstr "Automobil"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1738
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1743
 msgid "Phone"
 msgstr "Telefón"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2137
 #: ../src/modules/bluetooth/module-bluez5-device.c:1695
 #: ../src/modules/bluetooth/module-bluez5-device.c:1711
 #: ../src/modules/bluetooth/module-bluez5-device.c:1749
 msgid "Bluetooth Output"
 msgstr "Výstup cez Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2140
 #: ../src/modules/bluetooth/module-bluez5-device.c:1694
 #: ../src/modules/bluetooth/module-bluez5-device.c:1716
 #: ../src/modules/bluetooth/module-bluez5-device.c:1722
@@ -875,19 +863,15 @@ msgstr "Výstup cez Bluetooth"
 msgid "Bluetooth Input"
 msgstr "Vstup cez Bluetooth"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2176
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Hi-Fi prehrávanie (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2187
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Hi-Fi zaznamenávanie (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr ""
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Handsfree Gateway"
 msgstr "Brána pre handsfree"
 
diff --git a/po/sv.po b/po/sv.po
index a5b6d6f..891fc79 100644
--- a/po/sv.po
+++ b/po/sv.po
@@ -594,7 +594,6 @@ msgid "Line In"
 msgstr "Linje in"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1783
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -656,7 +655,6 @@ msgid "No Bass Boost"
 msgstr "Ingen basökning"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1790
 msgid "Speaker"
 msgstr "Högtalare"
@@ -841,7 +839,6 @@ msgstr "Stereo duplex"
 
 #: ../src/modules/alsa/alsa-mixer.c:4158
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:2038
 msgid "Off"
 msgstr "Av"
@@ -976,49 +973,40 @@ msgstr ""
 "Förmodligen är detta ett fel i ALSA-drivrutinen ”%s”. Vänligen rapportera "
 "problemet till ALSA-utvecklarna."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1773
 msgid "Headset"
 msgstr "Headset"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1778
 msgid "Handsfree"
 msgstr "Handsfree"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1796
 msgid "Headphone"
 msgstr "Hörlurar"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1801
 msgid "Portable"
 msgstr "Bärbar"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1806
 msgid "Car"
 msgstr "Bil"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1811
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1816
 msgid "Phone"
 msgstr "Telefon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1768
 #: ../src/modules/bluetooth/module-bluez5-device.c:1784
 #: ../src/modules/bluetooth/module-bluez5-device.c:1822
 msgid "Bluetooth Output"
 msgstr "Bluetooth-utgång"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1767
 #: ../src/modules/bluetooth/module-bluez5-device.c:1789
 #: ../src/modules/bluetooth/module-bluez5-device.c:1795
@@ -1026,19 +1014,15 @@ msgstr "Bluetooth-utgång"
 msgid "Bluetooth Input"
 msgstr "Bluetooth-ingång"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "High fidelity playback (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "High fidelity capture (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Telephony duplex (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "Handsfree gateway"
 
diff --git a/po/tr.po b/po/tr.po
index 9a72759..73514d6 100644
--- a/po/tr.po
+++ b/po/tr.po
@@ -678,7 +678,6 @@ msgid "Line In"
 msgstr "Hat girişi"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1696
 msgid "Microphone"
 msgstr "Mikrofon"
@@ -740,7 +739,6 @@ msgid "No Bass Boost"
 msgstr "Bas Artırma"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1703
 msgid "Speaker"
 msgstr "Hoparlör"
@@ -922,7 +920,6 @@ msgstr "İkili Stereo"
 
 #: ../src/modules/alsa/alsa-mixer.c:4157
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:1951
 msgid "Off"
 msgstr "Kapalı"
@@ -1054,49 +1051,40 @@ msgstr ""
 "Büyük ihtimalle bu bir ALSA sürücüsü '%s' hatasıdır. Lütfen bu sorunu ALSA "
 "geliştiricilerine bildirin."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1686
 msgid "Headset"
 msgstr "Kulaklık"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1691
 msgid "Handsfree"
 msgstr "Ahizesiz"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1709
 msgid "Headphone"
 msgstr "Kulaklık"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1714
 msgid "Portable"
 msgstr "Taşınabilir"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1719
 msgid "Car"
 msgstr "Araba"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1724
 msgid "HiFi"
 msgstr "Yüksek duyarlılık"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1729
 msgid "Phone"
 msgstr "Telefon"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1681
 #: ../src/modules/bluetooth/module-bluez5-device.c:1697
 #: ../src/modules/bluetooth/module-bluez5-device.c:1735
 msgid "Bluetooth Output"
 msgstr "Bluetooth Çıkışı"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1680
 #: ../src/modules/bluetooth/module-bluez5-device.c:1702
 #: ../src/modules/bluetooth/module-bluez5-device.c:1708
@@ -1104,19 +1092,15 @@ msgstr "Bluetooth Çıkışı"
 msgid "Bluetooth Input"
 msgstr "Bluetooth Girişi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Yüksek Kaliteli Çalma (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Yüksek Kaliteli Yakalama (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Çift yönlü Telefon (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "Eller Serbest Geçidi"
 
diff --git a/po/uk.po b/po/uk.po
index 48160ae..410beca 100644
--- a/po/uk.po
+++ b/po/uk.po
@@ -609,7 +609,6 @@ msgid "Line In"
 msgstr "Лінійний вхід"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1783
 msgid "Microphone"
 msgstr "Мікрофон"
@@ -671,7 +670,6 @@ msgid "No Bass Boost"
 msgstr "Без підсилення"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1790
 msgid "Speaker"
 msgstr "Гучномовець"
@@ -857,7 +855,6 @@ msgstr "Двобічне стерео"
 
 #: ../src/modules/alsa/alsa-mixer.c:4158
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:2038
 msgid "Off"
 msgstr "Вимкнено"
@@ -992,49 +989,40 @@ msgstr ""
 "Ймовірно, ви натрапили на ваду у драйвері ALSA «%s». Будь ласка, повідомте "
 "про цю ваду розробникам ALSA."
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1773
 msgid "Headset"
 msgstr "Гарнітура"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1778
 msgid "Handsfree"
 msgstr "Пристрій гучного зв’язку"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1796
 msgid "Headphone"
 msgstr "Навушники"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1801
 msgid "Portable"
 msgstr "Портативна система"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1806
 msgid "Car"
 msgstr "Автомобільна система"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1811
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1816
 msgid "Phone"
 msgstr "Телефон"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1768
 #: ../src/modules/bluetooth/module-bluez5-device.c:1784
 #: ../src/modules/bluetooth/module-bluez5-device.c:1822
 msgid "Bluetooth Output"
 msgstr "Bluetooth (відтворення)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1767
 #: ../src/modules/bluetooth/module-bluez5-device.c:1789
 #: ../src/modules/bluetooth/module-bluez5-device.c:1795
@@ -1042,19 +1030,15 @@ msgstr "Bluetooth (відтворення)"
 msgid "Bluetooth Input"
 msgstr "Bluetooth (вхід)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "Високоточне відтворення (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "Високоточне захоплення (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "Телефонний дуплекс (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "Пристрій гучного зв’язку"
 
diff --git a/po/zh_CN.po b/po/zh_CN.po
index 19a7ae5..11a36f1 100644
--- a/po/zh_CN.po
+++ b/po/zh_CN.po
@@ -555,7 +555,6 @@ msgid "Line In"
 msgstr "输入插孔"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1710
 msgid "Microphone"
 msgstr "话筒"
@@ -617,7 +616,6 @@ msgid "No Bass Boost"
 msgstr "无重低音增强"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1717
 msgid "Speaker"
 msgstr "扬声器"
@@ -790,7 +788,6 @@ msgstr "多声道双工"
 
 #: ../src/modules/alsa/alsa-mixer.c:4155
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2295
 #: ../src/modules/bluetooth/module-bluez5-device.c:1941
 msgid "Off"
 msgstr "关"
@@ -911,49 +908,40 @@ msgstr ""
 "snd_pcm_mmap_begin() 返回的值非常大：%lu 字节(%lu ms)。\n"
 "这很可能是由 ALSA 驱动程序 %s 中的 bug。请向 ALSA 开发者举报这个问题。"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2089
 #: ../src/modules/bluetooth/module-bluez5-device.c:1700
 msgid "Headset"
 msgstr "耳机"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1705
 msgid "Handsfree"
 msgstr "免手操作"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1723
 msgid "Headphone"
 msgstr "头戴耳机"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1728
 msgid "Portable"
 msgstr "便携式"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1733
 msgid "Car"
 msgstr "车内"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1738
 msgid "HiFi"
 msgstr "高保真"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1743
 msgid "Phone"
 msgstr "电话"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2137
 #: ../src/modules/bluetooth/module-bluez5-device.c:1695
 #: ../src/modules/bluetooth/module-bluez5-device.c:1711
 #: ../src/modules/bluetooth/module-bluez5-device.c:1749
 msgid "Bluetooth Output"
 msgstr "蓝牙输出"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2140
 #: ../src/modules/bluetooth/module-bluez5-device.c:1694
 #: ../src/modules/bluetooth/module-bluez5-device.c:1716
 #: ../src/modules/bluetooth/module-bluez5-device.c:1722
@@ -961,19 +949,15 @@ msgstr "蓝牙输出"
 msgid "Bluetooth Input"
 msgstr "蓝牙输入"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2176
 msgid "High Fidelity Playback (A2DP)"
 msgstr "高保真回放(A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2187
 msgid "High Fidelity Capture (A2DP)"
 msgstr "高保真采集(A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "双工电话(HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Handsfree Gateway"
 msgstr "蓝牙音频网关"
 
diff --git a/po/zh_TW.po b/po/zh_TW.po
index 6f6dc9a..b41ca7a 100644
--- a/po/zh_TW.po
+++ b/po/zh_TW.po
@@ -558,7 +558,6 @@ msgid "Line In"
 msgstr "線路輸入"
 
 #: ../src/modules/alsa/alsa-mixer.c:2383 ../src/modules/alsa/alsa-mixer.c:2461
-#: ../src/modules/bluetooth/module-bluez4-device.c:2104
 #: ../src/modules/bluetooth/module-bluez5-device.c:1773
 msgid "Microphone"
 msgstr "麥克風"
@@ -620,7 +619,6 @@ msgid "No Bass Boost"
 msgstr "無低音增強"
 
 #: ../src/modules/alsa/alsa-mixer.c:2398
-#: ../src/modules/bluetooth/module-bluez4-device.c:2109
 #: ../src/modules/bluetooth/module-bluez5-device.c:1780
 msgid "Speaker"
 msgstr "喇叭"
@@ -805,7 +803,6 @@ msgstr "立體聲雙工"
 
 #: ../src/modules/alsa/alsa-mixer.c:4158
 #: ../src/modules/alsa/module-alsa-card.c:186
-#: ../src/modules/bluetooth/module-bluez4-device.c:2324
 #: ../src/modules/bluetooth/module-bluez5-device.c:2028
 msgid "Off"
 msgstr "關閉"
@@ -924,49 +921,40 @@ msgstr ""
 "snd_pcm_mmap_begin() 傳回超出預期的大值：%lu bytes (%lu ms)。\n"
 "這很能是 ALSA 驅動程式「%s」的臭蟲。請回報這個問題給 ALSA 開發者。"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2094
 #: ../src/modules/bluetooth/module-bluez5-device.c:1763
 msgid "Headset"
 msgstr "耳麥"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2099
 #: ../src/modules/bluetooth/module-bluez5-device.c:1768
 msgid "Handsfree"
 msgstr "免持裝置"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2114
 #: ../src/modules/bluetooth/module-bluez5-device.c:1786
 msgid "Headphone"
 msgstr "頭戴式耳機"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2119
 #: ../src/modules/bluetooth/module-bluez5-device.c:1791
 msgid "Portable"
 msgstr "可攜裝置"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2124
 #: ../src/modules/bluetooth/module-bluez5-device.c:1796
 msgid "Car"
 msgstr "汽車"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2129
 #: ../src/modules/bluetooth/module-bluez5-device.c:1801
 msgid "HiFi"
 msgstr "HiFi"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2134
 #: ../src/modules/bluetooth/module-bluez5-device.c:1806
 msgid "Phone"
 msgstr "手機"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2142
 #: ../src/modules/bluetooth/module-bluez5-device.c:1758
 #: ../src/modules/bluetooth/module-bluez5-device.c:1774
 #: ../src/modules/bluetooth/module-bluez5-device.c:1812
 msgid "Bluetooth Output"
 msgstr "藍牙輸出"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2145
 #: ../src/modules/bluetooth/module-bluez5-device.c:1757
 #: ../src/modules/bluetooth/module-bluez5-device.c:1779
 #: ../src/modules/bluetooth/module-bluez5-device.c:1785
@@ -974,19 +962,15 @@ msgstr "藍牙輸出"
 msgid "Bluetooth Input"
 msgstr "藍牙輸入"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2186
 msgid "High Fidelity Playback (A2DP)"
 msgstr "高傳真播放裝置 (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2198
 msgid "High Fidelity Capture (A2DP)"
 msgstr "高傳真擷取裝置 (A2DP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2210
 msgid "Telephony Duplex (HSP/HFP)"
 msgstr "電話雙工 (HSP/HFP)"
 
-#: ../src/modules/bluetooth/module-bluez4-device.c:2223
 msgid "Handsfree Gateway"
 msgstr "免持閘道"
 
diff --git a/src/Makefile.am b/src/Makefile.am
index af30875..2d6df82 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -1461,13 +1461,6 @@ modlibexec_LTLIBRARIES += \
 		module-bluetooth-policy.la
 endif
 
-if HAVE_BLUEZ_4
-modlibexec_LTLIBRARIES += \
-		libbluez4-util.la \
-		module-bluez4-discover.la \
-		module-bluez4-device.la
-endif
-
 if HAVE_BLUEZ_5
 modlibexec_LTLIBRARIES += \
 		libbluez5-util.la \
@@ -2117,30 +2110,15 @@ module_bluetooth_discover_la_LDFLAGS = $(MODULE_LDFLAGS)
 module_bluetooth_discover_la_LIBADD = $(MODULE_LIBADD)
 module_bluetooth_discover_la_CFLAGS = $(AM_CFLAGS) -DPA_MODULE_NAME=module_bluetooth_discover
 
-# Bluetooth BlueZ 4 sink / source
-module_bluez4_discover_la_SOURCES = modules/bluetooth/module-bluez4-discover.c
-module_bluez4_discover_la_LDFLAGS = $(MODULE_LDFLAGS)
-module_bluez4_discover_la_LIBADD = $(MODULE_LIBADD) $(DBUS_LIBS) libbluez4-util.la
-module_bluez4_discover_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS) -DPA_MODULE_NAME=module_bluez4_discover
-
-libbluez4_util_la_SOURCES = \
-		modules/bluetooth/a2dp-codecs.h \
-		modules/bluetooth/bluez4-util.c \
-		modules/bluetooth/bluez4-util.h
-libbluez4_util_la_LDFLAGS = -avoid-version
-libbluez4_util_la_LIBADD = $(MODULE_LIBADD) $(DBUS_LIBS)
-libbluez4_util_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS)
-
-module_bluez4_device_la_SOURCES = modules/bluetooth/module-bluez4-device.c modules/bluetooth/rtp.h
-module_bluez4_device_la_LDFLAGS = $(MODULE_LDFLAGS)
-module_bluez4_device_la_LIBADD = $(MODULE_LIBADD) $(DBUS_LIBS) $(SBC_LIBS) libbluez4-util.la
-module_bluez4_device_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS) $(SBC_CFLAGS) -DPA_MODULE_NAME=module_bluez4_device
-
 # Bluetooth BlueZ 5 sink / source
 libbluez5_util_la_SOURCES = \
 		modules/bluetooth/bluez5-util.c \
 		modules/bluetooth/bluez5-util.h \
-		modules/bluetooth/a2dp-codecs.h
+		modules/bluetooth/a2dp-codec-api.h \
+		modules/bluetooth/a2dp-codec-util.c \
+		modules/bluetooth/a2dp-codec-util.h \
+		modules/bluetooth/a2dp-codecs.h \
+		modules/bluetooth/rtp.h
 if HAVE_BLUEZ_5_OFONO_HEADSET
 libbluez5_util_la_SOURCES += \
 		modules/bluetooth/backend-ofono.c
@@ -2153,6 +2131,11 @@ endif
 libbluez5_util_la_LDFLAGS = -avoid-version
 libbluez5_util_la_LIBADD = $(MODULE_LIBADD) $(DBUS_LIBS)
 libbluez5_util_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS)
+libbluez5_util_la_CPPFLAGS = $(AM_CPPFLAGS)
+
+libbluez5_util_la_SOURCES += modules/bluetooth/a2dp-codec-sbc.c
+libbluez5_util_la_LIBADD += $(SBC_LIBS)
+libbluez5_util_la_CFLAGS += $(SBC_CFLAGS)
 
 module_bluez5_discover_la_SOURCES = modules/bluetooth/module-bluez5-discover.c
 module_bluez5_discover_la_LDFLAGS = $(MODULE_LDFLAGS)
@@ -2161,8 +2144,8 @@ module_bluez5_discover_la_CFLAGS = $(AM_CFLAGS) $(DBUS_CFLAGS) -DPA_MODULE_NAME=
 
 module_bluez5_device_la_SOURCES = modules/bluetooth/module-bluez5-device.c
 module_bluez5_device_la_LDFLAGS = $(MODULE_LDFLAGS)
-module_bluez5_device_la_LIBADD = $(MODULE_LIBADD) $(SBC_LIBS) libbluez5-util.la
-module_bluez5_device_la_CFLAGS = $(AM_CFLAGS) $(SBC_CFLAGS) -DPA_MODULE_NAME=module_bluez5_device
+module_bluez5_device_la_LIBADD = $(MODULE_LIBADD) libbluez5-util.la
+module_bluez5_device_la_CFLAGS = $(AM_CFLAGS) -DPA_MODULE_NAME=module_bluez5_device
 
 # Apple Airtunes/RAOP
 module_raop_sink_la_SOURCES = modules/raop/module-raop-sink.c
diff --git a/src/modules/bluetooth/a2dp-codec-api.h b/src/modules/bluetooth/a2dp-codec-api.h
new file mode 100644
index 0000000..a3123f4
--- /dev/null
+++ b/src/modules/bluetooth/a2dp-codec-api.h
@@ -0,0 +1,98 @@
+#ifndef fooa2dpcodechfoo
+#define fooa2dpcodechfoo
+
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2018-2019 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#include <pulsecore/core.h>
+
+#define MAX_A2DP_CAPS_SIZE 254
+
+typedef struct pa_a2dp_codec_capabilities {
+    uint8_t size;
+    uint8_t buffer[]; /* max size is 254 bytes */
+} pa_a2dp_codec_capabilities;
+
+typedef struct pa_a2dp_codec_id {
+    uint8_t codec_id;
+    uint32_t vendor_id;
+    uint16_t vendor_codec_id;
+} pa_a2dp_codec_id;
+
+typedef struct pa_a2dp_codec {
+    /* Unique name of the codec, lowercase and without whitespaces, used for
+     * constructing identifier, D-Bus paths, ... */
+    const char *name;
+    /* Human readable codec description */
+    const char *description;
+
+    /* A2DP codec id */
+    pa_a2dp_codec_id id;
+
+    /* True if codec is bi-directional and supports backchannel */
+    bool support_backchannel;
+
+    /* Returns true if codec accepts capabilities, for_encoding is true when
+     * capabilities are used for encoding */
+    bool (*can_accept_capabilities)(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding);
+    /* Choose remote endpoint based on capabilities from hash map
+     * (const char *endpoint -> const pa_a2dp_codec_capabilities *capability)
+     * and returns corresponding endpoint key (or NULL when there is no valid),
+     * for_encoder is true when capabilities hash map is used for encoding */
+    const char *(*choose_remote_endpoint)(const pa_hashmap *capabilities_hashmap, const pa_sample_spec *default_sample_spec, bool for_encoding);
+    /* Fill codec capabilities, returns size of filled buffer */
+    uint8_t (*fill_capabilities)(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]);
+    /* Validate codec configuration, returns true on success */
+    bool (*is_configuration_valid)(const uint8_t *config_buffer, uint8_t config_size);
+    /* Fill preferred codec configuration, returns size of filled buffer or 0 on failure */
+    uint8_t (*fill_preferred_configuration)(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]);
+
+    /* Initialize codec, returns codec info data and set sample_spec,
+     * for_encoding is true when codec_info is used for encoding,
+     * for_backchannel is true when codec_info is used for backchannel */
+    void *(*init)(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec);
+    /* Deinitialize and release codec info data in codec_info */
+    void (*deinit)(void *codec_info);
+    /* Reset internal state of codec info data in codec_info, returns
+     * a negative value on failure */
+    int (*reset)(void *codec_info);
+
+    /* Get read block size for codec, it is minimal size of buffer
+     * needed to decode read_link_mtu bytes of encoded data */
+    size_t (*get_read_block_size)(void *codec_info, size_t read_link_mtu);
+    /* Get write block size for codec, it is maximal size of buffer
+     * which can produce at most write_link_mtu bytes of encoded data */
+    size_t (*get_write_block_size)(void *codec_info, size_t write_link_mtu);
+
+    /* Reduce encoder bitrate for codec, returns new write block size or zero
+     * if not changed, called when socket is not accepting encoded data fast
+     * enough */
+    size_t (*reduce_encoder_bitrate)(void *codec_info, size_t write_link_mtu);
+
+    /* Encode input_buffer of input_size to output_buffer of output_size,
+     * returns size of filled ouput_buffer and set processed to size of
+     * processed input_buffer */
+    size_t (*encode_buffer)(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed);
+    /* Decode input_buffer of input_size to output_buffer of output_size,
+     * returns size of filled ouput_buffer and set processed to size of
+     * processed input_buffer */
+    size_t (*decode_buffer)(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed);
+} pa_a2dp_codec;
+
+#endif
diff --git a/src/modules/bluetooth/a2dp-codec-sbc.c b/src/modules/bluetooth/a2dp-codec-sbc.c
new file mode 100644
index 0000000..89c647f
--- /dev/null
+++ b/src/modules/bluetooth/a2dp-codec-sbc.c
@@ -0,0 +1,682 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2018-2019 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulsecore/core-util.h>
+#include <pulsecore/log.h>
+#include <pulsecore/macro.h>
+#include <pulsecore/once.h>
+#include <pulse/sample.h>
+#include <pulse/xmalloc.h>
+
+#include <arpa/inet.h>
+
+#include <sbc/sbc.h>
+
+#include "a2dp-codecs.h"
+#include "a2dp-codec-api.h"
+#include "rtp.h"
+
+#define SBC_BITPOOL_DEC_LIMIT 32
+#define SBC_BITPOOL_DEC_STEP 5
+
+struct sbc_info {
+    sbc_t sbc;                           /* Codec data */
+    size_t codesize, frame_length;       /* SBC Codesize, frame_length. We simply cache those values here */
+    uint16_t seq_num;                    /* Cumulative packet sequence */
+    uint8_t frequency;
+    uint8_t blocks;
+    uint8_t subbands;
+    uint8_t mode;
+    uint8_t allocation;
+    uint8_t initial_bitpool;
+    uint8_t min_bitpool;
+    uint8_t max_bitpool;
+};
+
+static bool can_accept_capabilities(const uint8_t *capabilities_buffer, uint8_t capabilities_size, bool for_encoding) {
+    const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
+
+    if (capabilities_size != sizeof(*capabilities))
+        return false;
+
+    if (!(capabilities->frequency & (SBC_SAMPLING_FREQ_16000 | SBC_SAMPLING_FREQ_32000 | SBC_SAMPLING_FREQ_44100 | SBC_SAMPLING_FREQ_48000)))
+        return false;
+
+    if (!(capabilities->channel_mode & (SBC_CHANNEL_MODE_MONO | SBC_CHANNEL_MODE_DUAL_CHANNEL | SBC_CHANNEL_MODE_STEREO | SBC_CHANNEL_MODE_JOINT_STEREO)))
+        return false;
+
+    if (!(capabilities->allocation_method & (SBC_ALLOCATION_SNR | SBC_ALLOCATION_LOUDNESS)))
+        return false;
+
+    if (!(capabilities->subbands & (SBC_SUBBANDS_4 | SBC_SUBBANDS_8)))
+        return false;
+
+    if (!(capabilities->block_length & (SBC_BLOCK_LENGTH_4 | SBC_BLOCK_LENGTH_8 | SBC_BLOCK_LENGTH_12 | SBC_BLOCK_LENGTH_16)))
+        return false;
+
+    return true;
+}
+
+static const char *choose_remote_endpoint(const pa_hashmap *capabilities_hashmap, const pa_sample_spec *default_sample_spec, bool for_encoding) {
+    const pa_a2dp_codec_capabilities *a2dp_capabilities;
+    const char *key;
+    void *state;
+
+    /* There is no preference, just choose random valid entry */
+    PA_HASHMAP_FOREACH_KV(key, a2dp_capabilities, capabilities_hashmap, state) {
+        if (can_accept_capabilities(a2dp_capabilities->buffer, a2dp_capabilities->size, for_encoding))
+            return key;
+    }
+
+    return NULL;
+}
+
+static uint8_t fill_capabilities(uint8_t capabilities_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_sbc_t *capabilities = (a2dp_sbc_t *) capabilities_buffer;
+
+    pa_zero(*capabilities);
+
+    capabilities->channel_mode = SBC_CHANNEL_MODE_MONO | SBC_CHANNEL_MODE_DUAL_CHANNEL | SBC_CHANNEL_MODE_STEREO |
+                                 SBC_CHANNEL_MODE_JOINT_STEREO;
+    capabilities->frequency = SBC_SAMPLING_FREQ_16000 | SBC_SAMPLING_FREQ_32000 | SBC_SAMPLING_FREQ_44100 |
+                              SBC_SAMPLING_FREQ_48000;
+    capabilities->allocation_method = SBC_ALLOCATION_SNR | SBC_ALLOCATION_LOUDNESS;
+    capabilities->subbands = SBC_SUBBANDS_4 | SBC_SUBBANDS_8;
+    capabilities->block_length = SBC_BLOCK_LENGTH_4 | SBC_BLOCK_LENGTH_8 | SBC_BLOCK_LENGTH_12 | SBC_BLOCK_LENGTH_16;
+    capabilities->min_bitpool = SBC_MIN_BITPOOL;
+    capabilities->max_bitpool = SBC_BITPOOL_HQ_JOINT_STEREO_44100;
+
+    return sizeof(*capabilities);
+}
+
+static bool is_configuration_valid(const uint8_t *config_buffer, uint8_t config_size) {
+    const a2dp_sbc_t *config = (const a2dp_sbc_t *) config_buffer;
+
+    if (config_size != sizeof(*config)) {
+        pa_log_error("Invalid size of config buffer");
+        return false;
+    }
+
+    if (config->frequency != SBC_SAMPLING_FREQ_16000 && config->frequency != SBC_SAMPLING_FREQ_32000 &&
+        config->frequency != SBC_SAMPLING_FREQ_44100 && config->frequency != SBC_SAMPLING_FREQ_48000) {
+        pa_log_error("Invalid sampling frequency in configuration");
+        return false;
+    }
+
+    if (config->channel_mode != SBC_CHANNEL_MODE_MONO && config->channel_mode != SBC_CHANNEL_MODE_DUAL_CHANNEL &&
+        config->channel_mode != SBC_CHANNEL_MODE_STEREO && config->channel_mode != SBC_CHANNEL_MODE_JOINT_STEREO) {
+        pa_log_error("Invalid channel mode in configuration");
+        return false;
+    }
+
+    if (config->allocation_method != SBC_ALLOCATION_SNR && config->allocation_method != SBC_ALLOCATION_LOUDNESS) {
+        pa_log_error("Invalid allocation method in configuration");
+        return false;
+    }
+
+    if (config->subbands != SBC_SUBBANDS_4 && config->subbands != SBC_SUBBANDS_8) {
+        pa_log_error("Invalid SBC subbands in configuration");
+        return false;
+    }
+
+    if (config->block_length != SBC_BLOCK_LENGTH_4 && config->block_length != SBC_BLOCK_LENGTH_8 &&
+        config->block_length != SBC_BLOCK_LENGTH_12 && config->block_length != SBC_BLOCK_LENGTH_16) {
+        pa_log_error("Invalid block length in configuration");
+        return false;
+    }
+
+    if (config->min_bitpool > config->max_bitpool) {
+        pa_log_error("Invalid bitpool in configuration");
+        return false;
+    }
+
+    return true;
+}
+
+static uint8_t default_bitpool(uint8_t freq, uint8_t mode) {
+    /* These bitpool values were chosen based on the A2DP spec recommendation */
+    switch (freq) {
+        case SBC_SAMPLING_FREQ_16000:
+        case SBC_SAMPLING_FREQ_32000:
+            switch (mode) {
+                case SBC_CHANNEL_MODE_MONO:
+                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
+                case SBC_CHANNEL_MODE_STEREO:
+                case SBC_CHANNEL_MODE_JOINT_STEREO:
+                    return SBC_BITPOOL_HQ_JOINT_STEREO_44100;
+            }
+            break;
+
+        case SBC_SAMPLING_FREQ_44100:
+            switch (mode) {
+                case SBC_CHANNEL_MODE_MONO:
+                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
+                    return SBC_BITPOOL_HQ_MONO_44100;
+
+                case SBC_CHANNEL_MODE_STEREO:
+                case SBC_CHANNEL_MODE_JOINT_STEREO:
+                    return SBC_BITPOOL_HQ_JOINT_STEREO_44100;
+            }
+            break;
+
+        case SBC_SAMPLING_FREQ_48000:
+            switch (mode) {
+                case SBC_CHANNEL_MODE_MONO:
+                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
+                    return SBC_BITPOOL_HQ_MONO_48000;
+
+                case SBC_CHANNEL_MODE_STEREO:
+                case SBC_CHANNEL_MODE_JOINT_STEREO:
+                    return SBC_BITPOOL_HQ_JOINT_STEREO_48000;
+            }
+            break;
+    }
+
+    pa_assert_not_reached();
+}
+
+static uint8_t fill_preferred_configuration(const pa_sample_spec *default_sample_spec, const uint8_t *capabilities_buffer, uint8_t capabilities_size, uint8_t config_buffer[MAX_A2DP_CAPS_SIZE]) {
+    a2dp_sbc_t *config = (a2dp_sbc_t *) config_buffer;
+    const a2dp_sbc_t *capabilities = (const a2dp_sbc_t *) capabilities_buffer;
+    int i;
+
+    static const struct {
+        uint32_t rate;
+        uint8_t cap;
+    } freq_table[] = {
+        { 16000U, SBC_SAMPLING_FREQ_16000 },
+        { 32000U, SBC_SAMPLING_FREQ_32000 },
+        { 44100U, SBC_SAMPLING_FREQ_44100 },
+        { 48000U, SBC_SAMPLING_FREQ_48000 }
+    };
+
+    if (capabilities_size != sizeof(*capabilities)) {
+        pa_log_error("Invalid size of capabilities buffer");
+        return 0;
+    }
+
+    pa_zero(*config);
+
+    /* Find the lowest freq that is at least as high as the requested sampling rate */
+    for (i = 0; (unsigned) i < PA_ELEMENTSOF(freq_table); i++)
+        if (freq_table[i].rate >= default_sample_spec->rate && (capabilities->frequency & freq_table[i].cap)) {
+            config->frequency = freq_table[i].cap;
+            break;
+        }
+
+    if ((unsigned) i == PA_ELEMENTSOF(freq_table)) {
+        for (--i; i >= 0; i--) {
+            if (capabilities->frequency & freq_table[i].cap) {
+                config->frequency = freq_table[i].cap;
+                break;
+            }
+        }
+
+        if (i < 0) {
+            pa_log_error("Not suitable sample rate");
+            return 0;
+        }
+    }
+
+    pa_assert((unsigned) i < PA_ELEMENTSOF(freq_table));
+
+    if (default_sample_spec->channels <= 1) {
+        if (capabilities->channel_mode & SBC_CHANNEL_MODE_MONO)
+            config->channel_mode = SBC_CHANNEL_MODE_MONO;
+        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
+            config->channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
+        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_STEREO)
+            config->channel_mode = SBC_CHANNEL_MODE_STEREO;
+        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
+            config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+        else {
+            pa_log_error("No supported channel modes");
+            return 0;
+        }
+    } else {
+        if (capabilities->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
+            config->channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
+        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_STEREO)
+            config->channel_mode = SBC_CHANNEL_MODE_STEREO;
+        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
+            config->channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
+        else if (capabilities->channel_mode & SBC_CHANNEL_MODE_MONO)
+            config->channel_mode = SBC_CHANNEL_MODE_MONO;
+        else {
+            pa_log_error("No supported channel modes");
+            return 0;
+        }
+    }
+
+    if (capabilities->block_length & SBC_BLOCK_LENGTH_16)
+        config->block_length = SBC_BLOCK_LENGTH_16;
+    else if (capabilities->block_length & SBC_BLOCK_LENGTH_12)
+        config->block_length = SBC_BLOCK_LENGTH_12;
+    else if (capabilities->block_length & SBC_BLOCK_LENGTH_8)
+        config->block_length = SBC_BLOCK_LENGTH_8;
+    else if (capabilities->block_length & SBC_BLOCK_LENGTH_4)
+        config->block_length = SBC_BLOCK_LENGTH_4;
+    else {
+        pa_log_error("No supported block lengths");
+        return 0;
+    }
+
+    if (capabilities->subbands & SBC_SUBBANDS_8)
+        config->subbands = SBC_SUBBANDS_8;
+    else if (capabilities->subbands & SBC_SUBBANDS_4)
+        config->subbands = SBC_SUBBANDS_4;
+    else {
+        pa_log_error("No supported subbands");
+        return 0;
+    }
+
+    if (capabilities->allocation_method & SBC_ALLOCATION_LOUDNESS)
+        config->allocation_method = SBC_ALLOCATION_LOUDNESS;
+    else if (capabilities->allocation_method & SBC_ALLOCATION_SNR)
+        config->allocation_method = SBC_ALLOCATION_SNR;
+    else {
+        pa_log_error("No supported allocation method");
+        return 0;
+    }
+
+    config->min_bitpool = (uint8_t) PA_MAX(SBC_MIN_BITPOOL, capabilities->min_bitpool);
+    config->max_bitpool = (uint8_t) PA_MIN(default_bitpool(config->frequency, config->channel_mode), capabilities->max_bitpool);
+
+    if (config->min_bitpool > config->max_bitpool) {
+        pa_log_error("No supported bitpool");
+        return 0;
+    }
+
+    return sizeof(*config);
+}
+
+static void set_params(struct sbc_info *sbc_info) {
+    sbc_info->sbc.frequency = sbc_info->frequency;
+    sbc_info->sbc.blocks = sbc_info->blocks;
+    sbc_info->sbc.subbands = sbc_info->subbands;
+    sbc_info->sbc.mode = sbc_info->mode;
+    sbc_info->sbc.allocation = sbc_info->allocation;
+    sbc_info->sbc.bitpool = sbc_info->initial_bitpool;
+    sbc_info->sbc.endian = SBC_LE;
+
+    sbc_info->codesize = sbc_get_codesize(&sbc_info->sbc);
+    sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
+}
+
+static void *init(bool for_encoding, bool for_backchannel, const uint8_t *config_buffer, uint8_t config_size, pa_sample_spec *sample_spec) {
+    struct sbc_info *sbc_info;
+    const a2dp_sbc_t *config = (const a2dp_sbc_t *) config_buffer;
+    int ret;
+
+    pa_assert(config_size == sizeof(*config));
+    pa_assert(!for_backchannel);
+
+    sbc_info = pa_xnew0(struct sbc_info, 1);
+
+    ret = sbc_init(&sbc_info->sbc, 0);
+    if (ret != 0) {
+        pa_xfree(sbc_info);
+        pa_log_error("SBC initialization failed: %d", ret);
+        return NULL;
+    }
+
+    sample_spec->format = PA_SAMPLE_S16LE;
+
+    switch (config->frequency) {
+        case SBC_SAMPLING_FREQ_16000:
+            sbc_info->frequency = SBC_FREQ_16000;
+            sample_spec->rate = 16000U;
+            break;
+        case SBC_SAMPLING_FREQ_32000:
+            sbc_info->frequency = SBC_FREQ_32000;
+            sample_spec->rate = 32000U;
+            break;
+        case SBC_SAMPLING_FREQ_44100:
+            sbc_info->frequency = SBC_FREQ_44100;
+            sample_spec->rate = 44100U;
+            break;
+        case SBC_SAMPLING_FREQ_48000:
+            sbc_info->frequency = SBC_FREQ_48000;
+            sample_spec->rate = 48000U;
+            break;
+        default:
+            pa_assert_not_reached();
+    }
+
+    switch (config->channel_mode) {
+        case SBC_CHANNEL_MODE_MONO:
+            sbc_info->mode = SBC_MODE_MONO;
+            sample_spec->channels = 1;
+            break;
+        case SBC_CHANNEL_MODE_DUAL_CHANNEL:
+            sbc_info->mode = SBC_MODE_DUAL_CHANNEL;
+            sample_spec->channels = 2;
+            break;
+        case SBC_CHANNEL_MODE_STEREO:
+            sbc_info->mode = SBC_MODE_STEREO;
+            sample_spec->channels = 2;
+            break;
+        case SBC_CHANNEL_MODE_JOINT_STEREO:
+            sbc_info->mode = SBC_MODE_JOINT_STEREO;
+            sample_spec->channels = 2;
+            break;
+        default:
+            pa_assert_not_reached();
+    }
+
+    switch (config->allocation_method) {
+        case SBC_ALLOCATION_SNR:
+            sbc_info->allocation = SBC_AM_SNR;
+            break;
+        case SBC_ALLOCATION_LOUDNESS:
+            sbc_info->allocation = SBC_AM_LOUDNESS;
+            break;
+        default:
+            pa_assert_not_reached();
+    }
+
+    switch (config->subbands) {
+        case SBC_SUBBANDS_4:
+            sbc_info->subbands = SBC_SB_4;
+            break;
+        case SBC_SUBBANDS_8:
+            sbc_info->subbands = SBC_SB_8;
+            break;
+        default:
+            pa_assert_not_reached();
+    }
+
+    switch (config->block_length) {
+        case SBC_BLOCK_LENGTH_4:
+            sbc_info->blocks = SBC_BLK_4;
+            break;
+        case SBC_BLOCK_LENGTH_8:
+            sbc_info->blocks = SBC_BLK_8;
+            break;
+        case SBC_BLOCK_LENGTH_12:
+            sbc_info->blocks = SBC_BLK_12;
+            break;
+        case SBC_BLOCK_LENGTH_16:
+            sbc_info->blocks = SBC_BLK_16;
+            break;
+        default:
+            pa_assert_not_reached();
+    }
+
+    sbc_info->min_bitpool = config->min_bitpool;
+    sbc_info->max_bitpool = config->max_bitpool;
+
+    /* Set minimum bitpool for source to get the maximum possible block_size
+     * in get_block_size() function. This block_size is length of buffer used
+     * for decoded audio data and so is inversely proportional to frame length
+     * which depends on bitpool value. Bitpool is controlled by other side from
+     * range [min_bitpool, max_bitpool]. */
+    sbc_info->initial_bitpool = for_encoding ? sbc_info->max_bitpool : sbc_info->min_bitpool;
+
+    set_params(sbc_info);
+
+    pa_log_info("SBC parameters: allocation=%s, subbands=%u, blocks=%u, mode=%s bitpool=%u codesize=%u frame_length=%u",
+                sbc_info->sbc.allocation ? "SNR" : "Loudness", sbc_info->sbc.subbands ? 8 : 4,
+                (sbc_info->sbc.blocks+1)*4, sbc_info->sbc.mode == SBC_MODE_MONO ? "Mono" :
+                sbc_info->sbc.mode == SBC_MODE_DUAL_CHANNEL ? "DualChannel" :
+                sbc_info->sbc.mode == SBC_MODE_STEREO ? "Stereo" : "JointStereo",
+                sbc_info->sbc.bitpool, (unsigned)sbc_info->codesize, (unsigned)sbc_info->frame_length);
+
+    return sbc_info;
+}
+
+static void deinit(void *codec_info) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+
+    sbc_finish(&sbc_info->sbc);
+    pa_xfree(sbc_info);
+}
+
+static void set_bitpool(struct sbc_info *sbc_info, uint8_t bitpool) {
+    if (bitpool > sbc_info->max_bitpool)
+        bitpool = sbc_info->max_bitpool;
+    else if (bitpool < sbc_info->min_bitpool)
+        bitpool = sbc_info->min_bitpool;
+
+    sbc_info->sbc.bitpool = bitpool;
+
+    sbc_info->codesize = sbc_get_codesize(&sbc_info->sbc);
+    sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
+
+    pa_log_debug("Bitpool has changed to %u", sbc_info->sbc.bitpool);
+}
+
+static int reset(void *codec_info) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    int ret;
+
+    ret = sbc_reinit(&sbc_info->sbc, 0);
+    if (ret != 0) {
+        pa_log_error("SBC reinitialization failed: %d", ret);
+        return -1;
+    }
+
+    /* sbc_reinit() sets also default parameters, so reset them back */
+    set_params(sbc_info);
+
+    sbc_info->seq_num = 0;
+    return 0;
+}
+
+static size_t get_block_size(void *codec_info, size_t link_mtu) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    size_t rtp_size = sizeof(struct rtp_header) + sizeof(struct rtp_sbc_payload);
+    size_t frame_count = (link_mtu - rtp_size) / sbc_info->frame_length;
+
+    /* frame_count is only 4 bit number */
+    if (frame_count > 15)
+        frame_count = 15;
+
+    return frame_count * sbc_info->codesize;
+}
+
+static size_t reduce_encoder_bitrate(void *codec_info, size_t write_link_mtu) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    uint8_t bitpool;
+
+    /* Check if bitpool is already at its limit */
+    if (sbc_info->sbc.bitpool <= SBC_BITPOOL_DEC_LIMIT)
+        return 0;
+
+    bitpool = sbc_info->sbc.bitpool - SBC_BITPOOL_DEC_STEP;
+
+    if (bitpool < SBC_BITPOOL_DEC_LIMIT)
+        bitpool = SBC_BITPOOL_DEC_LIMIT;
+
+    if (sbc_info->sbc.bitpool == bitpool)
+        return 0;
+
+    set_bitpool(sbc_info, bitpool);
+    return get_block_size(codec_info, write_link_mtu);
+}
+
+static size_t encode_buffer(void *codec_info, uint32_t timestamp, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+    struct rtp_header *header;
+    struct rtp_sbc_payload *payload;
+    uint8_t *d;
+    const uint8_t *p;
+    size_t to_write, to_encode;
+    uint8_t frame_count;
+
+    header = (struct rtp_header*) output_buffer;
+    payload = (struct rtp_sbc_payload*) (output_buffer + sizeof(*header));
+
+    frame_count = 0;
+
+    p = input_buffer;
+    to_encode = input_size;
+
+    d = output_buffer + sizeof(*header) + sizeof(*payload);
+    to_write = output_size - sizeof(*header) - sizeof(*payload);
+
+    /* frame_count is only 4 bit number */
+    while (PA_LIKELY(to_encode > 0 && to_write > 0 && frame_count < 15)) {
+        ssize_t written;
+        ssize_t encoded;
+
+        encoded = sbc_encode(&sbc_info->sbc,
+                             p, to_encode,
+                             d, to_write,
+                             &written);
+
+        if (PA_UNLIKELY(encoded <= 0)) {
+            pa_log_error("SBC encoding error (%li)", (long) encoded);
+            break;
+        }
+
+        if (PA_UNLIKELY(written < 0)) {
+            pa_log_error("SBC encoding error (%li)", (long) written);
+            break;
+        }
+
+        pa_assert_fp((size_t) encoded <= to_encode);
+        pa_assert_fp((size_t) encoded == sbc_info->codesize);
+
+        pa_assert_fp((size_t) written <= to_write);
+        pa_assert_fp((size_t) written == sbc_info->frame_length);
+
+        p += encoded;
+        to_encode -= encoded;
+
+        d += written;
+        to_write -= written;
+
+        frame_count++;
+    }
+
+    PA_ONCE_BEGIN {
+        pa_log_debug("Using SBC codec implementation: %s", pa_strnull(sbc_get_implementation_info(&sbc_info->sbc)));
+    } PA_ONCE_END;
+
+    if (PA_UNLIKELY(frame_count == 0)) {
+        *processed = 0;
+        return 0;
+    }
+
+    /* write it to the fifo */
+    pa_memzero(output_buffer, sizeof(*header) + sizeof(*payload));
+    header->v = 2;
+
+    /* A2DP spec: "A payload type in the RTP dynamic range shall be chosen".
+     * RFC3551 defines the dynamic range to span from 96 to 127, and 96 appears
+     * to be the most common choice in A2DP implementations. */
+    header->pt = 96;
+
+    header->sequence_number = htons(sbc_info->seq_num++);
+    header->timestamp = htonl(timestamp);
+    header->ssrc = htonl(1);
+    payload->frame_count = frame_count;
+
+    *processed = p - input_buffer;
+    return d - output_buffer;
+}
+
+static size_t decode_buffer(void *codec_info, const uint8_t *input_buffer, size_t input_size, uint8_t *output_buffer, size_t output_size, size_t *processed) {
+    struct sbc_info *sbc_info = (struct sbc_info *) codec_info;
+
+    struct rtp_header *header;
+    struct rtp_sbc_payload *payload;
+    const uint8_t *p;
+    uint8_t *d;
+    size_t to_write, to_decode;
+    uint8_t frame_count;
+
+    header = (struct rtp_header *) input_buffer;
+    payload = (struct rtp_sbc_payload*) (input_buffer + sizeof(*header));
+
+    frame_count = payload->frame_count;
+
+    /* TODO: Add support for decoding fragmented SBC frames */
+    if (payload->is_fragmented) {
+        pa_log_error("Unsupported fragmented SBC frame");
+        *processed = 0;
+        return 0;
+    }
+
+    p = input_buffer + sizeof(*header) + sizeof(*payload);
+    to_decode = input_size - sizeof(*header) - sizeof(*payload);
+
+    d = output_buffer;
+    to_write = output_size;
+
+    while (PA_LIKELY(to_decode > 0 && to_write > 0 && frame_count > 0)) {
+        size_t written;
+        ssize_t decoded;
+
+        decoded = sbc_decode(&sbc_info->sbc,
+                             p, to_decode,
+                             d, to_write,
+                             &written);
+
+        if (PA_UNLIKELY(decoded <= 0)) {
+            pa_log_error("SBC decoding error (%li)", (long) decoded);
+            break;
+        }
+
+        /* Reset frame length, it can be changed due to bitpool change */
+        sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
+
+        pa_assert_fp((size_t) decoded <= to_decode);
+        pa_assert_fp((size_t) decoded == sbc_info->frame_length);
+
+        pa_assert_fp((size_t) written <= to_write);
+        pa_assert_fp((size_t) written == sbc_info->codesize);
+
+        p += decoded;
+        to_decode -= decoded;
+
+        d += written;
+        to_write -= written;
+
+        frame_count--;
+    }
+
+    *processed = p - input_buffer;
+    return d - output_buffer;
+}
+
+const pa_a2dp_codec pa_a2dp_codec_sbc = {
+    .name = "sbc",
+    .description = "SBC",
+    .id = { A2DP_CODEC_SBC, 0, 0 },
+    .support_backchannel = false,
+    .can_accept_capabilities = can_accept_capabilities,
+    .choose_remote_endpoint = choose_remote_endpoint,
+    .fill_capabilities = fill_capabilities,
+    .is_configuration_valid = is_configuration_valid,
+    .fill_preferred_configuration = fill_preferred_configuration,
+    .init = init,
+    .deinit = deinit,
+    .reset = reset,
+    .get_read_block_size = get_block_size,
+    .get_write_block_size = get_block_size,
+    .reduce_encoder_bitrate = reduce_encoder_bitrate,
+    .encode_buffer = encode_buffer,
+    .decode_buffer = decode_buffer,
+};
diff --git a/src/modules/bluetooth/a2dp-codec-util.c b/src/modules/bluetooth/a2dp-codec-util.c
new file mode 100644
index 0000000..94d01e7
--- /dev/null
+++ b/src/modules/bluetooth/a2dp-codec-util.c
@@ -0,0 +1,56 @@
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2019 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#ifdef HAVE_CONFIG_H
+#include <config.h>
+#endif
+
+#include <pulsecore/core.h>
+#include <pulsecore/core-util.h>
+
+#include "a2dp-codec-util.h"
+
+extern const pa_a2dp_codec pa_a2dp_codec_sbc;
+
+/* This is list of supported codecs. Their order is important.
+ * Codec with higher index has higher priority. */
+const pa_a2dp_codec *pa_a2dp_codecs[] = {
+    &pa_a2dp_codec_sbc,
+};
+
+unsigned int pa_bluetooth_a2dp_codec_count(void) {
+    return PA_ELEMENTSOF(pa_a2dp_codecs);
+}
+
+const pa_a2dp_codec *pa_bluetooth_a2dp_codec_iter(unsigned int i) {
+    pa_assert(i < pa_bluetooth_a2dp_codec_count());
+    return pa_a2dp_codecs[i];
+}
+
+const pa_a2dp_codec *pa_bluetooth_get_a2dp_codec(const char *name) {
+    unsigned int i;
+    unsigned int count = pa_bluetooth_a2dp_codec_count();
+
+    for (i = 0; i < count; i++) {
+        if (pa_streq(pa_a2dp_codecs[i]->name, name))
+            return pa_a2dp_codecs[i];
+    }
+
+    return NULL;
+}
diff --git a/src/modules/bluetooth/a2dp-codec-util.h b/src/modules/bluetooth/a2dp-codec-util.h
new file mode 100644
index 0000000..86f233a
--- /dev/null
+++ b/src/modules/bluetooth/a2dp-codec-util.h
@@ -0,0 +1,34 @@
+#ifndef fooa2dpcodecutilhfoo
+#define fooa2dpcodecutilhfoo
+
+/***
+  This file is part of PulseAudio.
+
+  Copyright 2019 Pali Rohár <pali.rohar@gmail.com>
+
+  PulseAudio is free software; you can redistribute it and/or modify
+  it under the terms of the GNU Lesser General Public License as
+  published by the Free Software Foundation; either version 2.1 of the
+  License, or (at your option) any later version.
+
+  PulseAudio is distributed in the hope that it will be useful, but
+  WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
+  General Public License for more details.
+
+  You should have received a copy of the GNU Lesser General Public
+  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
+***/
+
+#include "a2dp-codec-api.h"
+
+/* Get number of supported A2DP codecs */
+unsigned int pa_bluetooth_a2dp_codec_count(void);
+
+/* Get i-th codec. Codec with higher number has higher priority */
+const pa_a2dp_codec *pa_bluetooth_a2dp_codec_iter(unsigned int i);
+
+/* Get codec by name */
+const pa_a2dp_codec *pa_bluetooth_get_a2dp_codec(const char *name);
+
+#endif
diff --git a/src/modules/bluetooth/a2dp-codecs.h b/src/modules/bluetooth/a2dp-codecs.h
index 8afcfcb..93e9d35 100644
--- a/src/modules/bluetooth/a2dp-codecs.h
+++ b/src/modules/bluetooth/a2dp-codecs.h
@@ -4,6 +4,7 @@
  *
  *  Copyright (C) 2006-2010  Nokia Corporation
  *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2018       Pali Rohár <pali.rohar@gmail.com>
  *
  *
  *  This library is free software; you can redistribute it and/or
@@ -17,14 +18,19 @@
  *  Lesser General Public License for more details.
  *
  *  You should have received a copy of the GNU Lesser General Public
- *  License along with this library; if not, see <http://www.gnu.org/licenses/>.
+ *  License along with this library; if not, write to the Free Software
+ *  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  *
  */
 
+#include <endian.h>
+#include <stdint.h>
+
 #define A2DP_CODEC_SBC			0x00
 #define A2DP_CODEC_MPEG12		0x01
 #define A2DP_CODEC_MPEG24		0x02
-#define A2DP_CODEC_ATRAC		0x03
+#define A2DP_CODEC_ATRAC		0x04
+#define A2DP_CODEC_VENDOR		0xFF
 
 #define SBC_SAMPLING_FREQ_16000		(1 << 3)
 #define SBC_SAMPLING_FREQ_32000		(1 << 2)
@@ -47,6 +53,23 @@
 #define SBC_ALLOCATION_SNR		(1 << 1)
 #define SBC_ALLOCATION_LOUDNESS		1
 
+#define SBC_MIN_BITPOOL			2
+#define SBC_MAX_BITPOOL			250
+
+/* Other settings:
+ * Block length = 16
+ * Allocation method = Loudness
+ * Subbands = 8
+ */
+#define SBC_BITPOOL_MQ_MONO_44100		19
+#define SBC_BITPOOL_MQ_MONO_48000		18
+#define SBC_BITPOOL_MQ_JOINT_STEREO_44100	35
+#define SBC_BITPOOL_MQ_JOINT_STEREO_48000	33
+#define SBC_BITPOOL_HQ_MONO_44100		31
+#define SBC_BITPOOL_HQ_MONO_48000		29
+#define SBC_BITPOOL_HQ_JOINT_STEREO_44100	53
+#define SBC_BITPOOL_HQ_JOINT_STEREO_48000	51
+
 #define MPEG_CHANNEL_MODE_MONO		(1 << 3)
 #define MPEG_CHANNEL_MODE_DUAL_CHANNEL	(1 << 2)
 #define MPEG_CHANNEL_MODE_STEREO	(1 << 1)
@@ -63,10 +86,228 @@
 #define MPEG_SAMPLING_FREQ_44100	(1 << 1)
 #define MPEG_SAMPLING_FREQ_48000	1
 
-#define MAX_BITPOOL 64
-#define MIN_BITPOOL 2
+#define MPEG_BIT_RATE_INDEX_0		(1 << 0)
+#define MPEG_BIT_RATE_INDEX_1		(1 << 1)
+#define MPEG_BIT_RATE_INDEX_2		(1 << 2)
+#define MPEG_BIT_RATE_INDEX_3		(1 << 3)
+#define MPEG_BIT_RATE_INDEX_4		(1 << 4)
+#define MPEG_BIT_RATE_INDEX_5		(1 << 5)
+#define MPEG_BIT_RATE_INDEX_6		(1 << 6)
+#define MPEG_BIT_RATE_INDEX_7		(1 << 7)
+#define MPEG_BIT_RATE_INDEX_8		(1 << 8)
+#define MPEG_BIT_RATE_INDEX_9		(1 << 9)
+#define MPEG_BIT_RATE_INDEX_10		(1 << 10)
+#define MPEG_BIT_RATE_INDEX_11		(1 << 11)
+#define MPEG_BIT_RATE_INDEX_12		(1 << 12)
+#define MPEG_BIT_RATE_INDEX_13		(1 << 13)
+#define MPEG_BIT_RATE_INDEX_14		(1 << 14)
+
+#define MPEG_MP1_BIT_RATE_32000		MPEG_BIT_RATE_INDEX_1
+#define MPEG_MP1_BIT_RATE_64000		MPEG_BIT_RATE_INDEX_2
+#define MPEG_MP1_BIT_RATE_96000		MPEG_BIT_RATE_INDEX_3
+#define MPEG_MP1_BIT_RATE_128000	MPEG_BIT_RATE_INDEX_4
+#define MPEG_MP1_BIT_RATE_160000	MPEG_BIT_RATE_INDEX_5
+#define MPEG_MP1_BIT_RATE_192000	MPEG_BIT_RATE_INDEX_6
+#define MPEG_MP1_BIT_RATE_224000	MPEG_BIT_RATE_INDEX_7
+#define MPEG_MP1_BIT_RATE_256000	MPEG_BIT_RATE_INDEX_8
+#define MPEG_MP1_BIT_RATE_288000	MPEG_BIT_RATE_INDEX_9
+#define MPEG_MP1_BIT_RATE_320000	MPEG_BIT_RATE_INDEX_10
+#define MPEG_MP1_BIT_RATE_352000	MPEG_BIT_RATE_INDEX_11
+#define MPEG_MP1_BIT_RATE_384000	MPEG_BIT_RATE_INDEX_12
+#define MPEG_MP1_BIT_RATE_416000	MPEG_BIT_RATE_INDEX_13
+#define MPEG_MP1_BIT_RATE_448000	MPEG_BIT_RATE_INDEX_14
+
+#define MPEG_MP2_BIT_RATE_32000		MPEG_BIT_RATE_INDEX_1
+#define MPEG_MP2_BIT_RATE_48000		MPEG_BIT_RATE_INDEX_2
+#define MPEG_MP2_BIT_RATE_56000		MPEG_BIT_RATE_INDEX_3
+#define MPEG_MP2_BIT_RATE_64000		MPEG_BIT_RATE_INDEX_4
+#define MPEG_MP2_BIT_RATE_80000		MPEG_BIT_RATE_INDEX_5
+#define MPEG_MP2_BIT_RATE_96000		MPEG_BIT_RATE_INDEX_6
+#define MPEG_MP2_BIT_RATE_112000	MPEG_BIT_RATE_INDEX_7
+#define MPEG_MP2_BIT_RATE_128000	MPEG_BIT_RATE_INDEX_8
+#define MPEG_MP2_BIT_RATE_160000	MPEG_BIT_RATE_INDEX_9
+#define MPEG_MP2_BIT_RATE_192000	MPEG_BIT_RATE_INDEX_10
+#define MPEG_MP2_BIT_RATE_224000	MPEG_BIT_RATE_INDEX_11
+#define MPEG_MP2_BIT_RATE_256000	MPEG_BIT_RATE_INDEX_12
+#define MPEG_MP2_BIT_RATE_320000	MPEG_BIT_RATE_INDEX_13
+#define MPEG_MP2_BIT_RATE_384000	MPEG_BIT_RATE_INDEX_14
+
+#define MPEG_MP3_BIT_RATE_32000		MPEG_BIT_RATE_INDEX_1
+#define MPEG_MP3_BIT_RATE_40000		MPEG_BIT_RATE_INDEX_2
+#define MPEG_MP3_BIT_RATE_48000		MPEG_BIT_RATE_INDEX_3
+#define MPEG_MP3_BIT_RATE_56000		MPEG_BIT_RATE_INDEX_4
+#define MPEG_MP3_BIT_RATE_64000		MPEG_BIT_RATE_INDEX_5
+#define MPEG_MP3_BIT_RATE_80000		MPEG_BIT_RATE_INDEX_6
+#define MPEG_MP3_BIT_RATE_96000		MPEG_BIT_RATE_INDEX_7
+#define MPEG_MP3_BIT_RATE_112000	MPEG_BIT_RATE_INDEX_8
+#define MPEG_MP3_BIT_RATE_128000	MPEG_BIT_RATE_INDEX_9
+#define MPEG_MP3_BIT_RATE_160000	MPEG_BIT_RATE_INDEX_10
+#define MPEG_MP3_BIT_RATE_192000	MPEG_BIT_RATE_INDEX_11
+#define MPEG_MP3_BIT_RATE_224000	MPEG_BIT_RATE_INDEX_12
+#define MPEG_MP3_BIT_RATE_256000	MPEG_BIT_RATE_INDEX_13
+#define MPEG_MP3_BIT_RATE_320000	MPEG_BIT_RATE_INDEX_14
+
+#define MPEG_BIT_RATE_FREE		MPEG_BIT_RATE_INDEX_0
+
+#define MPEG_GET_BITRATE(a) ((uint16_t)(a).bitrate1 << 8 | (a).bitrate2)
+#define MPEG_SET_BITRATE(a, b) \
+	do { \
+		(a).bitrate1 = ((b) >> 8) & 0x7f; \
+		(a).bitrate2 = (b) & 0xff; \
+	} while (0)
+
+#define AAC_OBJECT_TYPE_MPEG2_AAC_LC	0x80
+#define AAC_OBJECT_TYPE_MPEG4_AAC_LC	0x40
+#define AAC_OBJECT_TYPE_MPEG4_AAC_LTP	0x20
+#define AAC_OBJECT_TYPE_MPEG4_AAC_SCA	0x10
+
+#define AAC_SAMPLING_FREQ_8000		0x0800
+#define AAC_SAMPLING_FREQ_11025		0x0400
+#define AAC_SAMPLING_FREQ_12000		0x0200
+#define AAC_SAMPLING_FREQ_16000		0x0100
+#define AAC_SAMPLING_FREQ_22050		0x0080
+#define AAC_SAMPLING_FREQ_24000		0x0040
+#define AAC_SAMPLING_FREQ_32000		0x0020
+#define AAC_SAMPLING_FREQ_44100		0x0010
+#define AAC_SAMPLING_FREQ_48000		0x0008
+#define AAC_SAMPLING_FREQ_64000		0x0004
+#define AAC_SAMPLING_FREQ_88200		0x0002
+#define AAC_SAMPLING_FREQ_96000		0x0001
+
+#define AAC_CHANNELS_1			0x02
+#define AAC_CHANNELS_2			0x01
+
+#define AAC_GET_BITRATE(a) ((a).bitrate1 << 16 | \
+					(a).bitrate2 << 8 | (a).bitrate3)
+#define AAC_GET_FREQUENCY(a) ((a).frequency1 << 4 | (a).frequency2)
+
+#define AAC_SET_BITRATE(a, b) \
+	do { \
+		(a).bitrate1 = (b >> 16) & 0x7f; \
+		(a).bitrate2 = (b >> 8) & 0xff; \
+		(a).bitrate3 = b & 0xff; \
+	} while (0)
+#define AAC_SET_FREQUENCY(a, f) \
+	do { \
+		(a).frequency1 = (f >> 4) & 0xff; \
+		(a).frequency2 = f & 0x0f; \
+	} while (0)
+
+#define AAC_INIT_BITRATE(b) \
+	.bitrate1 = (b >> 16) & 0x7f, \
+	.bitrate2 = (b >> 8) & 0xff, \
+	.bitrate3 = b & 0xff,
+#define AAC_INIT_FREQUENCY(f) \
+	.frequency1 = (f >> 4) & 0xff, \
+	.frequency2 = f & 0x0f,
+
+#define APTX_VENDOR_ID			0x0000004f
+#define APTX_CODEC_ID			0x0001
+
+#define APTX_CHANNEL_MODE_MONO		0x01
+#define APTX_CHANNEL_MODE_STEREO	0x02
+
+#define APTX_SAMPLING_FREQ_16000	0x08
+#define APTX_SAMPLING_FREQ_32000	0x04
+#define APTX_SAMPLING_FREQ_44100	0x02
+#define APTX_SAMPLING_FREQ_48000	0x01
+
+#define FASTSTREAM_VENDOR_ID		0x0000000a
+#define FASTSTREAM_CODEC_ID		0x0001
+
+#define FASTSTREAM_DIRECTION_SINK	0x1
+#define FASTSTREAM_DIRECTION_SOURCE	0x2
+
+#define FASTSTREAM_SINK_SAMPLING_FREQ_44100	0x2
+#define FASTSTREAM_SINK_SAMPLING_FREQ_48000	0x1
+
+#define FASTSTREAM_SOURCE_SAMPLING_FREQ_16000	0x2
+
+#define APTX_LL_VENDOR_ID		0x0000000a
+#define APTX_LL_CODEC_ID		0x0002
+
+/* Default parameters for aptX Low Latency encoder */
+
+/* Target codec buffer level = 180 */
+#define APTX_LL_TARGET_LEVEL2	0xb4
+#define APTX_LL_TARGET_LEVEL1	0x00
+
+/* Initial codec buffer level = 360 */
+#define APTX_LL_INITIAL_LEVEL2	0x68
+#define APTX_LL_INITIAL_LEVEL1	0x01
+
+/* SRA max rate 0.005 * 10000 = 50 */
+#define APTX_LL_SRA_MAX_RATE		0x32
+
+/* SRA averaging time = 1s */
+#define APTX_LL_SRA_AVG_TIME		0x01
+
+/* Good working codec buffer level = 180 */
+#define APTX_LL_GOOD_WORKING_LEVEL2	0xB4
+#define APTX_LL_GOOD_WORKING_LEVEL1	0x00
+
+#define APTX_HD_VENDOR_ID		0x000000D7
+#define APTX_HD_CODEC_ID		0x0024
+
+#define LDAC_VENDOR_ID			0x0000012d
+#define LDAC_CODEC_ID			0x00aa
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#define LDAC_SAMPLING_FREQ_44100	0x20
+#define LDAC_SAMPLING_FREQ_48000	0x10
+#define LDAC_SAMPLING_FREQ_88200	0x08
+#define LDAC_SAMPLING_FREQ_96000	0x04
+#define LDAC_SAMPLING_FREQ_176400	0x02
+#define LDAC_SAMPLING_FREQ_192000	0x01
+
+#define LDAC_CHANNEL_MODE_MONO		0x04
+#define LDAC_CHANNEL_MODE_DUAL		0x02
+#define LDAC_CHANNEL_MODE_STEREO	0x01
+
+typedef struct {
+	uint8_t vendor_id4;
+	uint8_t vendor_id3;
+	uint8_t vendor_id2;
+	uint8_t vendor_id1;
+	uint8_t codec_id2;
+	uint8_t codec_id1;
+} __attribute__ ((packed)) a2dp_vendor_codec_t;
+
+#define A2DP_GET_VENDOR_ID(a) ( \
+		(((uint32_t)(a).vendor_id4) <<  0) | \
+		(((uint32_t)(a).vendor_id3) <<  8) | \
+		(((uint32_t)(a).vendor_id2) << 16) | \
+		(((uint32_t)(a).vendor_id1) << 24) \
+	)
+#define A2DP_GET_CODEC_ID(a) ((a).codec_id2 | (((uint16_t)(a).codec_id1) << 8))
+#define A2DP_SET_VENDOR_ID_CODEC_ID(v, c) ((a2dp_vendor_codec_t){ \
+		.vendor_id4 = (((v) >>  0) & 0xff), \
+		.vendor_id3 = (((v) >>  8) & 0xff), \
+		.vendor_id2 = (((v) >> 16) & 0xff), \
+		.vendor_id1 = (((v) >> 24) & 0xff), \
+		.codec_id2 = (((c) >> 0) & 0xff), \
+		.codec_id1 = (((c) >> 8) & 0xff), \
+	})
+
+typedef struct {
+	uint8_t reserved;
+	uint8_t target_level2;
+	uint8_t target_level1;
+	uint8_t initial_level2;
+	uint8_t initial_level1;
+	uint8_t sra_max_rate;
+	uint8_t sra_avg_time;
+	uint8_t good_working_level2;
+	uint8_t good_working_level1;
+} __attribute__ ((packed)) a2dp_aptx_ll_new_caps_t;
+
+typedef struct {
+	a2dp_vendor_codec_t info;
+	uint8_t frequency;
+	uint8_t channel_mode;
+} __attribute__ ((packed)) a2dp_ldac_t;
+
+#if defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \
+	__BYTE_ORDER == __LITTLE_ENDIAN
 
 typedef struct {
 	uint8_t channel_mode:4;
@@ -85,10 +326,46 @@ typedef struct {
 	uint8_t frequency:6;
 	uint8_t mpf:1;
 	uint8_t rfa:1;
-	uint16_t bitrate;
+	uint8_t bitrate1:7;
+	uint8_t vbr:1;
+	uint8_t bitrate2;
 } __attribute__ ((packed)) a2dp_mpeg_t;
 
-#elif __BYTE_ORDER == __BIG_ENDIAN
+typedef struct {
+	uint8_t object_type;
+	uint8_t frequency1;
+	uint8_t rfa:2;
+	uint8_t channels:2;
+	uint8_t frequency2:4;
+	uint8_t bitrate1:7;
+	uint8_t vbr:1;
+	uint8_t bitrate2;
+	uint8_t bitrate3;
+} __attribute__ ((packed)) a2dp_aac_t;
+
+typedef struct {
+	a2dp_vendor_codec_t info;
+	uint8_t channel_mode:4;
+	uint8_t frequency:4;
+} __attribute__ ((packed)) a2dp_aptx_t;
+
+typedef struct {
+	a2dp_vendor_codec_t info;
+	uint8_t direction;
+	uint8_t sink_frequency:4;
+	uint8_t source_frequency:4;
+} __attribute__ ((packed)) a2dp_faststream_t;
+
+typedef struct {
+	a2dp_aptx_t aptx;
+	uint8_t bidirect_link:1;
+	uint8_t has_new_caps:1;
+	uint8_t reserved:6;
+	a2dp_aptx_ll_new_caps_t new_caps[0];
+} __attribute__ ((packed)) a2dp_aptx_ll_t;
+
+#elif defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \
+	__BYTE_ORDER == __BIG_ENDIAN
 
 typedef struct {
 	uint8_t frequency:4;
@@ -107,9 +384,52 @@ typedef struct {
 	uint8_t rfa:1;
 	uint8_t mpf:1;
 	uint8_t frequency:6;
-	uint16_t bitrate;
+	uint8_t vbr:1;
+	uint8_t bitrate1:7;
+	uint8_t bitrate2;
 } __attribute__ ((packed)) a2dp_mpeg_t;
 
+typedef struct {
+	uint8_t object_type;
+	uint8_t frequency1;
+	uint8_t frequency2:4;
+	uint8_t channels:2;
+	uint8_t rfa:2;
+	uint8_t vbr:1;
+	uint8_t bitrate1:7;
+	uint8_t bitrate2;
+	uint8_t bitrate3;
+} __attribute__ ((packed)) a2dp_aac_t;
+
+typedef struct {
+	a2dp_vendor_codec_t info;
+	uint8_t frequency:4;
+	uint8_t channel_mode:4;
+} __attribute__ ((packed)) a2dp_aptx_t;
+
+typedef struct {
+	a2dp_vendor_codec_t info;
+	uint8_t direction;
+	uint8_t source_frequency:4;
+	uint8_t sink_frequency:4;
+} __attribute__ ((packed)) a2dp_faststream_t;
+
+typedef struct {
+	a2dp_aptx_t aptx;
+	uint8_t reserved:6;
+	uint8_t has_new_caps:1;
+	uint8_t bidirect_link:1;
+	a2dp_aptx_ll_new_caps_t new_caps[0];
+} __attribute__ ((packed)) a2dp_aptx_ll_t;
+
 #else
 #error "Unknown byte order"
 #endif
+
+typedef struct {
+	a2dp_aptx_t aptx;
+	uint8_t reserved0;
+	uint8_t reserved1;
+	uint8_t reserved2;
+	uint8_t reserved3;
+} __attribute__ ((packed)) a2dp_aptx_hd_t;
diff --git a/src/modules/bluetooth/backend-ofono.c b/src/modules/bluetooth/backend-ofono.c
index 2c51497..0e5bbe8 100644
--- a/src/modules/bluetooth/backend-ofono.c
+++ b/src/modules/bluetooth/backend-ofono.c
@@ -67,9 +67,10 @@ struct hf_audio_card {
 
     bool connecting;
     int fd;
-    uint8_t codec;
+    int (*acquire)(struct hf_audio_card *card);
 
     pa_bluetooth_transport *transport;
+    pa_hook_slot *device_unlink_slot;
 };
 
 struct pa_bluetooth_backend {
@@ -99,12 +100,109 @@ static pa_dbus_pending* hf_dbus_send_and_add_to_pending(pa_bluetooth_backend *ba
     return p;
 }
 
+static DBusMessage *card_send(struct hf_audio_card *card, const char *method, DBusError *err)
+{
+    pa_bluetooth_transport *t = card->transport;
+    DBusMessage *m, *r;
+
+    pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, "org.ofono.HandsfreeAudioCard", method));
+    r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(card->backend->connection), m, -1, err);
+    dbus_message_unref(m);
+
+    return r;
+}
+
+static int card_connect(struct hf_audio_card *card) {
+    DBusMessage *r;
+    DBusError err;
+
+    if (card->connecting)
+        return -EAGAIN;
+
+    card->connecting = true;
+
+    dbus_error_init(&err);
+    r = card_send(card, "Connect", &err);
+
+    if (!r) {
+        pa_log_error("Failed to connect %s: %s", err.name, err.message);
+        card->connecting = false;
+        dbus_error_free(&err);
+        return -1;
+    }
+
+    dbus_message_unref(r);
+
+    if (card->connecting)
+        return -EAGAIN;
+
+    return 0;
+}
+
+static int card_acquire(struct hf_audio_card *card) {
+    int fd;
+    uint8_t codec;
+    DBusMessage *r;
+    DBusError err;
+
+    /* Try acquiring the stream first which was introduced in 1.21 */
+    dbus_error_init(&err);
+    r = card_send(card, "Acquire", &err);
+
+    if (!r) {
+        if (!pa_streq(err.name, DBUS_ERROR_UNKNOWN_METHOD)) {
+            pa_log_error("Failed to acquire %s: %s", err.name, err.message);
+            dbus_error_free(&err);
+            return -1;
+        }
+        dbus_error_free(&err);
+        /* Fallback to Connect as this might be an old version of ofono */
+        card->acquire = card_connect;
+        return card_connect(card);
+    }
+
+    if ((dbus_message_get_args(r, NULL, DBUS_TYPE_UNIX_FD, &fd,
+                                      DBUS_TYPE_BYTE, &codec,
+                                      DBUS_TYPE_INVALID) == true)) {
+        dbus_message_unref(r);
+        if (codec != HFP_AUDIO_CODEC_CVSD) {
+            pa_log_error("Invalid codec: %u", codec);
+            /* shutdown to make sure connection is dropped immediately */
+            shutdown(fd, SHUT_RDWR);
+            close(fd);
+            return -1;
+        }
+        card->transport->codec = codec;
+        card->fd = fd;
+        return 0;
+    }
+
+    pa_log_error("Unable to acquire");
+    dbus_message_unref(r);
+    return -1;
+}
+
+static void hf_audio_agent_card_removed(pa_bluetooth_backend *backend, const char *path);
+
+static pa_hook_result_t device_unlink_cb(pa_bluetooth_discovery *y, const pa_bluetooth_device *d, struct hf_audio_card *card) {
+    pa_assert(d);
+    pa_assert(card);
+
+    hf_audio_agent_card_removed(card->backend, card->path);
+
+    return PA_HOOK_OK;
+}
+
 static struct hf_audio_card *hf_audio_card_new(pa_bluetooth_backend *backend, const char *path) {
     struct hf_audio_card *card = pa_xnew0(struct hf_audio_card, 1);
 
     card->path = pa_xstrdup(path);
     card->backend = backend;
     card->fd = -1;
+    card->acquire = card_acquire;
+
+    card->device_unlink_slot = pa_hook_connect(pa_bluetooth_discovery_hook(backend->discovery, PA_BLUETOOTH_HOOK_DEVICE_UNLINK),
+                                               PA_HOOK_NORMAL, (pa_hook_cb_t) device_unlink_cb, card);
 
     return card;
 }
@@ -112,6 +210,9 @@ static struct hf_audio_card *hf_audio_card_new(pa_bluetooth_backend *backend, co
 static void hf_audio_card_free(struct hf_audio_card *card) {
     pa_assert(card);
 
+    if (card->device_unlink_slot)
+        pa_hook_slot_free(card->device_unlink_slot);
+
     if (card->transport)
         pa_bluetooth_transport_free(card->transport);
 
@@ -157,28 +258,9 @@ static int hf_audio_agent_transport_acquire(pa_bluetooth_transport *t, bool opti
     pa_assert(card);
 
     if (!optional && card->fd < 0) {
-        DBusMessage *m, *r;
-        DBusError derr;
-
-        if (card->connecting)
-            return -EAGAIN;
-
-        card->connecting = true;
-
-        dbus_error_init(&derr);
-        pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, "org.ofono.HandsfreeAudioCard", "Connect"));
-        r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(card->backend->connection), m, -1, &derr);
-        dbus_message_unref(m);
-        m = NULL;
-
-        if (!r)
-            return -1;
-
-        dbus_message_unref(r);
-        r = NULL;
-
-        if (card->connecting)
-            return -EAGAIN;
+        err = card->acquire(card);
+        if (err < 0)
+            return err;
     }
 
     /* The correct block size should take into account the SCO MTU from
@@ -191,8 +273,6 @@ static int hf_audio_agent_transport_acquire(pa_bluetooth_transport *t, bool opti
     if (omtu)
         *omtu = 48;
 
-    t->codec = card->codec;
-
     err = socket_accept(card->fd);
     if (err < 0) {
         pa_log_error("Deferred setup failed on fd %d: %s", card->fd, pa_cstrerror(-err));
@@ -372,8 +452,8 @@ static void hf_audio_agent_register_reply(DBusPendingCall *pending, void *userda
     pa_assert_se(r = dbus_pending_call_steal_reply(pending));
 
     if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
-        pa_log_error("Failed to register as a handsfree audio agent with ofono: %s: %s",
-                     dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
+        pa_log_info("Failed to register as a handsfree audio agent with ofono: %s: %s",
+                    dbus_message_get_error_name(r), pa_dbus_get_error_message(r));
         goto finish;
     }
 
diff --git a/src/modules/bluetooth/bluez4-util.c b/src/modules/bluetooth/bluez4-util.c
deleted file mode 100644
index ca60619..0000000
--- a/src/modules/bluetooth/bluez4-util.c
+++ /dev/null
@@ -1,1851 +0,0 @@
-/***
-  This file is part of PulseAudio.
-
-  Copyright 2008-2013 João Paulo Rechi Vita
-
-  PulseAudio is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License as
-  published by the Free Software Foundation; either version 2.1 of the
-  License, or (at your option) any later version.
-
-  PulseAudio is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
-***/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <pulse/xmalloc.h>
-
-#include <pulsecore/core-util.h>
-#include <pulsecore/shared.h>
-#include <pulsecore/dbus-shared.h>
-
-#include "bluez4-util.h"
-#include "a2dp-codecs.h"
-
-#define ENDPOINT_PATH_HFP_AG "/MediaEndpoint/BlueZ4/HFPAG"
-#define ENDPOINT_PATH_HFP_HS "/MediaEndpoint/BlueZ4/HFPHS"
-#define ENDPOINT_PATH_A2DP_SOURCE "/MediaEndpoint/BlueZ4/A2DPSource"
-#define ENDPOINT_PATH_A2DP_SINK "/MediaEndpoint/BlueZ4/A2DPSink"
-
-#define ENDPOINT_INTROSPECT_XML                                         \
-    DBUS_INTROSPECT_1_0_XML_DOCTYPE_DECL_NODE                           \
-    "<node>"                                                            \
-    " <interface name=\"org.bluez.MediaEndpoint\">"                     \
-    "  <method name=\"SetConfiguration\">"                              \
-    "   <arg name=\"transport\" direction=\"in\" type=\"o\"/>"          \
-    "   <arg name=\"configuration\" direction=\"in\" type=\"ay\"/>"     \
-    "  </method>"                                                       \
-    "  <method name=\"SelectConfiguration\">"                           \
-    "   <arg name=\"capabilities\" direction=\"in\" type=\"ay\"/>"      \
-    "   <arg name=\"configuration\" direction=\"out\" type=\"ay\"/>"    \
-    "  </method>"                                                       \
-    "  <method name=\"ClearConfiguration\">"                            \
-    "  </method>"                                                       \
-    "  <method name=\"Release\">"                                       \
-    "  </method>"                                                       \
-    " </interface>"                                                     \
-    " <interface name=\"org.freedesktop.DBus.Introspectable\">"         \
-    "  <method name=\"Introspect\">"                                    \
-    "   <arg name=\"data\" type=\"s\" direction=\"out\"/>"              \
-    "  </method>"                                                       \
-    " </interface>"                                                     \
-    "</node>"
-
-struct pa_bluez4_discovery {
-    PA_REFCNT_DECLARE;
-
-    pa_core *core;
-    pa_dbus_connection *connection;
-    PA_LLIST_HEAD(pa_dbus_pending, pending);
-    bool adapters_listed;
-    pa_hashmap *devices;
-    pa_hashmap *transports;
-    pa_hook hooks[PA_BLUEZ4_HOOK_MAX];
-    bool filter_added;
-};
-
-static void get_properties_reply(DBusPendingCall *pending, void *userdata);
-static pa_dbus_pending* send_and_add_to_pending(pa_bluez4_discovery *y, DBusMessage *m, DBusPendingCallNotifyFunction func,
-                                                void *call_data);
-static void found_adapter(pa_bluez4_discovery *y, const char *path);
-static pa_bluez4_device *found_device(pa_bluez4_discovery *y, const char* path);
-static void transport_set_state(pa_bluez4_transport *transport, pa_bluez4_transport_state_t state);
-
-static pa_bluez4_audio_state_t audio_state_from_string(const char* value) {
-    pa_assert(value);
-
-    if (pa_streq(value, "disconnected"))
-        return PA_BLUEZ4_AUDIO_STATE_DISCONNECTED;
-    else if (pa_streq(value, "connecting"))
-        return PA_BLUEZ4_AUDIO_STATE_CONNECTING;
-    else if (pa_streq(value, "connected"))
-        return PA_BLUEZ4_AUDIO_STATE_CONNECTED;
-    else if (pa_streq(value, "playing"))
-        return PA_BLUEZ4_AUDIO_STATE_PLAYING;
-
-    return PA_BLUEZ4_AUDIO_STATE_INVALID;
-}
-
-const char *pa_bluez4_profile_to_string(pa_bluez4_profile_t profile) {
-    switch(profile) {
-        case PA_BLUEZ4_PROFILE_A2DP_SINK:
-            return "a2dp";
-        case PA_BLUEZ4_PROFILE_A2DP_SOURCE:
-            return "a2dp_source";
-        case PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT:
-            return "hsp";
-        case PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY:
-            return "hfgw";
-        case PA_BLUEZ4_PROFILE_OFF:
-            pa_assert_not_reached();
-    }
-
-    pa_assert_not_reached();
-}
-
-static int profile_from_interface(const char *interface, pa_bluez4_profile_t *p) {
-    pa_assert(interface);
-    pa_assert(p);
-
-    if (pa_streq(interface, "org.bluez.AudioSink")) {
-        *p = PA_BLUEZ4_PROFILE_A2DP_SINK;
-        return 0;
-    } else if (pa_streq(interface, "org.bluez.AudioSource")) {
-        *p = PA_BLUEZ4_PROFILE_A2DP_SOURCE;
-        return 0;
-    } else if (pa_streq(interface, "org.bluez.Headset")) {
-        *p = PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT;
-        return 0;
-    } else if (pa_streq(interface, "org.bluez.HandsfreeGateway")) {
-        *p = PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY;
-        return 0;
-    }
-
-    return -1;
-}
-
-static pa_bluez4_transport_state_t audio_state_to_transport_state(pa_bluez4_audio_state_t state) {
-    switch (state) {
-        case PA_BLUEZ4_AUDIO_STATE_INVALID: /* Typically if state hasn't been received yet */
-        case PA_BLUEZ4_AUDIO_STATE_DISCONNECTED:
-        case PA_BLUEZ4_AUDIO_STATE_CONNECTING:
-            return PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED;
-        case PA_BLUEZ4_AUDIO_STATE_CONNECTED:
-            return PA_BLUEZ4_TRANSPORT_STATE_IDLE;
-        case PA_BLUEZ4_AUDIO_STATE_PLAYING:
-            return PA_BLUEZ4_TRANSPORT_STATE_PLAYING;
-    }
-
-    pa_assert_not_reached();
-}
-
-static pa_bluez4_device* device_new(pa_bluez4_discovery *discovery, const char *path) {
-    pa_bluez4_device *d;
-    unsigned i;
-
-    pa_assert(discovery);
-    pa_assert(path);
-
-    d = pa_xnew0(pa_bluez4_device, 1);
-
-    d->discovery = discovery;
-    d->dead = false;
-
-    d->device_info_valid = 0;
-
-    d->name = NULL;
-    d->path = pa_xstrdup(path);
-    d->paired = -1;
-    d->alias = NULL;
-    d->uuids = pa_hashmap_new_full(pa_idxset_string_hash_func, pa_idxset_string_compare_func, NULL, pa_xfree);
-    d->address = NULL;
-    d->class = -1;
-    d->trusted = -1;
-
-    d->audio_state = PA_BLUEZ4_AUDIO_STATE_INVALID;
-
-    for (i = 0; i < PA_BLUEZ4_PROFILE_COUNT; i++)
-        d->profile_state[i] = PA_BLUEZ4_AUDIO_STATE_INVALID;
-
-    return d;
-}
-
-static void transport_free(pa_bluez4_transport *t) {
-    pa_assert(t);
-
-    pa_xfree(t->owner);
-    pa_xfree(t->path);
-    pa_xfree(t->config);
-    pa_xfree(t);
-}
-
-static void device_free(pa_bluez4_device *d) {
-    pa_bluez4_transport *t;
-    unsigned i;
-
-    pa_assert(d);
-
-    for (i = 0; i < PA_BLUEZ4_PROFILE_COUNT; i++) {
-        if (!(t = d->transports[i]))
-            continue;
-
-        d->transports[i] = NULL;
-        pa_hashmap_remove(d->discovery->transports, t->path);
-        transport_set_state(t, PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED);
-        transport_free(t);
-    }
-
-    if (d->uuids)
-        pa_hashmap_free(d->uuids);
-
-    pa_xfree(d->name);
-    pa_xfree(d->path);
-    pa_xfree(d->alias);
-    pa_xfree(d->address);
-    pa_xfree(d);
-}
-
-static const char *check_variant_property(DBusMessageIter *i) {
-    const char *key;
-
-    pa_assert(i);
-
-    if (dbus_message_iter_get_arg_type(i) != DBUS_TYPE_STRING) {
-        pa_log("Property name not a string.");
-        return NULL;
-    }
-
-    dbus_message_iter_get_basic(i, &key);
-
-    if (!dbus_message_iter_next(i)) {
-        pa_log("Property value missing");
-        return NULL;
-    }
-
-    if (dbus_message_iter_get_arg_type(i) != DBUS_TYPE_VARIANT) {
-        pa_log("Property value not a variant.");
-        return NULL;
-    }
-
-    return key;
-}
-
-static int parse_manager_property(pa_bluez4_discovery *y, DBusMessageIter *i, bool is_property_change) {
-    const char *key;
-    DBusMessageIter variant_i;
-
-    pa_assert(y);
-
-    key = check_variant_property(i);
-    if (key == NULL)
-        return -1;
-
-    dbus_message_iter_recurse(i, &variant_i);
-
-    switch (dbus_message_iter_get_arg_type(&variant_i)) {
-
-        case DBUS_TYPE_ARRAY: {
-
-            DBusMessageIter ai;
-            dbus_message_iter_recurse(&variant_i, &ai);
-
-            if (pa_streq(key, "Adapters")) {
-                y->adapters_listed = true;
-
-                if (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_OBJECT_PATH)
-                    break;
-
-                while (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_INVALID) {
-                    const char *value;
-
-                    dbus_message_iter_get_basic(&ai, &value);
-
-                    found_adapter(y, value);
-
-                    dbus_message_iter_next(&ai);
-                }
-            }
-
-            break;
-        }
-    }
-
-    return 0;
-}
-
-static int parse_adapter_property(pa_bluez4_discovery *y, DBusMessageIter *i, bool is_property_change) {
-    const char *key;
-    DBusMessageIter variant_i;
-
-    pa_assert(y);
-
-    key = check_variant_property(i);
-    if (key == NULL)
-        return -1;
-
-    dbus_message_iter_recurse(i, &variant_i);
-
-    switch (dbus_message_iter_get_arg_type(&variant_i)) {
-
-        case DBUS_TYPE_ARRAY: {
-
-            DBusMessageIter ai;
-            dbus_message_iter_recurse(&variant_i, &ai);
-
-            if (dbus_message_iter_get_arg_type(&ai) == DBUS_TYPE_OBJECT_PATH &&
-                pa_streq(key, "Devices")) {
-
-                while (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_INVALID) {
-                    const char *value;
-
-                    dbus_message_iter_get_basic(&ai, &value);
-
-                    found_device(y, value);
-
-                    dbus_message_iter_next(&ai);
-                }
-            }
-
-            break;
-        }
-    }
-
-    return 0;
-}
-
-static int parse_device_property(pa_bluez4_device *d, DBusMessageIter *i, bool is_property_change) {
-    const char *key;
-    DBusMessageIter variant_i;
-
-    pa_assert(d);
-
-    key = check_variant_property(i);
-    if (key == NULL)
-        return -1;
-
-    dbus_message_iter_recurse(i, &variant_i);
-
-/*     pa_log_debug("Parsing property org.bluez.Device.%s", key); */
-
-    switch (dbus_message_iter_get_arg_type(&variant_i)) {
-
-        case DBUS_TYPE_STRING: {
-
-            const char *value;
-            dbus_message_iter_get_basic(&variant_i, &value);
-
-            if (pa_streq(key, "Name")) {
-                pa_xfree(d->name);
-                d->name = pa_xstrdup(value);
-            } else if (pa_streq(key, "Alias")) {
-                pa_xfree(d->alias);
-                d->alias = pa_xstrdup(value);
-            } else if (pa_streq(key, "Address")) {
-                if (is_property_change) {
-                    pa_log("Device property 'Address' expected to be constant but changed for %s", d->path);
-                    return -1;
-                }
-
-                if (d->address) {
-                    pa_log("Device %s: Received a duplicate Address property.", d->path);
-                    return -1;
-                }
-
-                d->address = pa_xstrdup(value);
-            }
-
-/*             pa_log_debug("Value %s", value); */
-
-            break;
-        }
-
-        case DBUS_TYPE_BOOLEAN: {
-
-            dbus_bool_t value;
-            dbus_message_iter_get_basic(&variant_i, &value);
-
-            if (pa_streq(key, "Paired"))
-                d->paired = !!value;
-            else if (pa_streq(key, "Trusted"))
-                d->trusted = !!value;
-
-/*             pa_log_debug("Value %s", pa_yes_no(value)); */
-
-            break;
-        }
-
-        case DBUS_TYPE_UINT32: {
-
-            uint32_t value;
-            dbus_message_iter_get_basic(&variant_i, &value);
-
-            if (pa_streq(key, "Class"))
-                d->class = (int) value;
-
-/*             pa_log_debug("Value %u", (unsigned) value); */
-
-            break;
-        }
-
-        case DBUS_TYPE_ARRAY: {
-            DBusMessageIter ai;
-            dbus_message_iter_recurse(&variant_i, &ai);
-
-            if (dbus_message_iter_get_arg_type(&ai) == DBUS_TYPE_STRING && pa_streq(key, "UUIDs")) {
-                DBusMessage *m;
-                bool has_audio = false;
-
-                /* bluetoothd never removes UUIDs from a device object so we
-                 * don't need to check for disappeared UUIDs here. */
-                while (dbus_message_iter_get_arg_type(&ai) != DBUS_TYPE_INVALID) {
-                    const char *value;
-                    char *uuid;
-                    struct pa_bluez4_hook_uuid_data uuiddata;
-
-                    dbus_message_iter_get_basic(&ai, &value);
-
-                    if (pa_hashmap_get(d->uuids, value)) {
-                        dbus_message_iter_next(&ai);
-                        continue;
-                    }
-
-                    uuid = pa_xstrdup(value);
-                    pa_hashmap_put(d->uuids, uuid, uuid);
-
-                    pa_log_debug("%s: %s", key, value);
-
-                    uuiddata.device = d;
-                    uuiddata.uuid = value;
-                    pa_hook_fire(&d->discovery->hooks[PA_BLUEZ4_HOOK_DEVICE_UUID_ADDED], &uuiddata);
-
-                    /* Vudentz said the interfaces are here when the UUIDs are announced */
-                    if (pa_streq(PA_BLUEZ4_UUID_HSP_AG, value) || pa_streq(PA_BLUEZ4_UUID_HFP_AG, value)) {
-                        pa_assert_se(m = dbus_message_new_method_call("org.bluez", d->path, "org.bluez.HandsfreeGateway",
-                                                                      "GetProperties"));
-                        send_and_add_to_pending(d->discovery, m, get_properties_reply, d);
-                        has_audio = true;
-                    } else if (pa_streq(PA_BLUEZ4_UUID_HSP_HS, value) || pa_streq(PA_BLUEZ4_UUID_HFP_HF, value)) {
-                        pa_assert_se(m = dbus_message_new_method_call("org.bluez", d->path, "org.bluez.Headset",
-                                                                      "GetProperties"));
-                        send_and_add_to_pending(d->discovery, m, get_properties_reply, d);
-                        has_audio = true;
-                    } else if (pa_streq(PA_BLUEZ4_UUID_A2DP_SINK, value)) {
-                        pa_assert_se(m = dbus_message_new_method_call("org.bluez", d->path, "org.bluez.AudioSink",
-                                                                      "GetProperties"));
-                        send_and_add_to_pending(d->discovery, m, get_properties_reply, d);
-                        has_audio = true;
-                    } else if (pa_streq(PA_BLUEZ4_UUID_A2DP_SOURCE, value)) {
-                        pa_assert_se(m = dbus_message_new_method_call("org.bluez", d->path, "org.bluez.AudioSource",
-                                                                      "GetProperties"));
-                        send_and_add_to_pending(d->discovery, m, get_properties_reply, d);
-                        has_audio = true;
-                    }
-
-                    dbus_message_iter_next(&ai);
-                }
-
-                /* this might eventually be racy if .Audio is not there yet, but
-                   the State change will come anyway later, so this call is for
-                   cold-detection mostly */
-                if (has_audio) {
-                    pa_assert_se(m = dbus_message_new_method_call("org.bluez", d->path, "org.bluez.Audio", "GetProperties"));
-                    send_and_add_to_pending(d->discovery, m, get_properties_reply, d);
-                }
-            }
-
-            break;
-        }
-    }
-
-    return 0;
-}
-
-static const char *transport_state_to_string(pa_bluez4_transport_state_t state) {
-    switch (state) {
-        case PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED:
-            return "disconnected";
-        case PA_BLUEZ4_TRANSPORT_STATE_IDLE:
-            return "idle";
-        case PA_BLUEZ4_TRANSPORT_STATE_PLAYING:
-            return "playing";
-    }
-
-    pa_assert_not_reached();
-}
-
-static int parse_audio_property(pa_bluez4_device *d, const char *interface, DBusMessageIter *i, bool is_property_change) {
-    pa_bluez4_transport *transport;
-    const char *key;
-    DBusMessageIter variant_i;
-    bool is_audio_interface;
-    pa_bluez4_profile_t p = PA_BLUEZ4_PROFILE_OFF;
-
-    pa_assert(d);
-    pa_assert(interface);
-    pa_assert(i);
-
-    if (!(is_audio_interface = pa_streq(interface, "org.bluez.Audio")))
-        if (profile_from_interface(interface, &p) < 0)
-            return 0; /* Interface not known so silently ignore property */
-
-    key = check_variant_property(i);
-    if (key == NULL)
-        return -1;
-
-    transport = p == PA_BLUEZ4_PROFILE_OFF ? NULL : d->transports[p];
-
-    dbus_message_iter_recurse(i, &variant_i);
-
-/*     pa_log_debug("Parsing property org.bluez.{Audio|AudioSink|AudioSource|Headset}.%s", key); */
-
-    switch (dbus_message_iter_get_arg_type(&variant_i)) {
-
-        case DBUS_TYPE_STRING: {
-
-            const char *value;
-            dbus_message_iter_get_basic(&variant_i, &value);
-
-            if (pa_streq(key, "State")) {
-                pa_bluez4_audio_state_t state = audio_state_from_string(value);
-
-                pa_log_debug("Device %s interface %s property 'State' changed to value '%s'", d->path, interface, value);
-
-                if (state == PA_BLUEZ4_AUDIO_STATE_INVALID)
-                    return -1;
-
-                if (is_audio_interface) {
-                    d->audio_state = state;
-                    break;
-                }
-
-                pa_assert(p != PA_BLUEZ4_PROFILE_OFF);
-
-                d->profile_state[p] = state;
-
-                if (!transport)
-                    break;
-
-                transport_set_state(transport, audio_state_to_transport_state(state));
-            }
-
-            break;
-        }
-
-        case DBUS_TYPE_UINT16: {
-            uint16_t value;
-
-            dbus_message_iter_get_basic(&variant_i, &value);
-
-            if (pa_streq(key, "MicrophoneGain")) {
-                uint16_t gain;
-
-                pa_log_debug("dbus: property '%s' changed to value '%u'", key, value);
-
-                if (!transport) {
-                    pa_log("Volume change does not have an associated transport");
-                    return -1;
-                }
-
-                if ((gain = PA_MIN(value, HSP_MAX_GAIN)) == transport->microphone_gain)
-                    break;
-
-                transport->microphone_gain = gain;
-                pa_hook_fire(&d->discovery->hooks[PA_BLUEZ4_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED], transport);
-            } else if (pa_streq(key, "SpeakerGain")) {
-                uint16_t gain;
-
-                pa_log_debug("dbus: property '%s' changed to value '%u'", key, value);
-
-                if (!transport) {
-                    pa_log("Volume change does not have an associated transport");
-                    return -1;
-                }
-
-                if ((gain = PA_MIN(value, HSP_MAX_GAIN)) == transport->speaker_gain)
-                    break;
-
-                transport->speaker_gain = gain;
-                pa_hook_fire(&d->discovery->hooks[PA_BLUEZ4_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED], transport);
-            }
-
-            break;
-        }
-    }
-
-    return 0;
-}
-
-static void run_callback(pa_bluez4_device *d, bool dead) {
-    pa_assert(d);
-
-    if (d->device_info_valid != 1)
-        return;
-
-    d->dead = dead;
-    pa_hook_fire(&d->discovery->hooks[PA_BLUEZ4_HOOK_DEVICE_CONNECTION_CHANGED], d);
-}
-
-static void remove_all_devices(pa_bluez4_discovery *y) {
-    pa_bluez4_device *d;
-
-    pa_assert(y);
-
-    while ((d = pa_hashmap_steal_first(y->devices))) {
-        run_callback(d, true);
-        device_free(d);
-    }
-}
-
-static pa_bluez4_device *found_device(pa_bluez4_discovery *y, const char* path) {
-    DBusMessage *m;
-    pa_bluez4_device *d;
-
-    pa_assert(y);
-    pa_assert(path);
-
-    d = pa_hashmap_get(y->devices, path);
-    if (d)
-        return d;
-
-    d = device_new(y, path);
-
-    pa_hashmap_put(y->devices, d->path, d);
-
-    pa_assert_se(m = dbus_message_new_method_call("org.bluez", path, "org.bluez.Device", "GetProperties"));
-    send_and_add_to_pending(y, m, get_properties_reply, d);
-
-    /* Before we read the other properties (Audio, AudioSink, AudioSource,
-     * Headset) we wait that the UUID is read */
-    return d;
-}
-
-static void get_properties_reply(DBusPendingCall *pending, void *userdata) {
-    DBusMessage *r;
-    DBusMessageIter arg_i, element_i;
-    pa_dbus_pending *p;
-    pa_bluez4_device *d;
-    pa_bluez4_discovery *y;
-    int valid;
-    bool old_any_connected;
-
-    pa_assert_se(p = userdata);
-    pa_assert_se(y = p->context_data);
-    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
-
-/*     pa_log_debug("Got %s.GetProperties response for %s", */
-/*                  dbus_message_get_interface(p->message), */
-/*                  dbus_message_get_path(p->message)); */
-
-    /* We don't use p->call_data here right-away since the device
-     * might already be invalidated at this point */
-
-    if (dbus_message_has_interface(p->message, "org.bluez.Manager") ||
-        dbus_message_has_interface(p->message, "org.bluez.Adapter"))
-        d = NULL;
-    else if (!(d = pa_hashmap_get(y->devices, dbus_message_get_path(p->message)))) {
-        pa_log_warn("Received GetProperties() reply from unknown device: %s (device removed?)", dbus_message_get_path(p->message));
-        goto finish2;
-    }
-
-    pa_assert(p->call_data == d);
-
-    if (d != NULL) {
-        old_any_connected = pa_bluez4_device_any_audio_connected(d);
-        valid = dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR ? -1 : 1;
-
-        if (dbus_message_is_method_call(p->message, "org.bluez.Device", "GetProperties"))
-            d->device_info_valid = valid;
-    }
-
-    if (dbus_message_is_error(r, DBUS_ERROR_SERVICE_UNKNOWN)) {
-        pa_log_debug("Bluetooth daemon is apparently not available.");
-        remove_all_devices(y);
-        goto finish2;
-    }
-
-    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
-        pa_log("%s.GetProperties() failed: %s: %s", dbus_message_get_interface(p->message), dbus_message_get_error_name(r),
-               pa_dbus_get_error_message(r));
-        goto finish;
-    }
-
-    if (!dbus_message_iter_init(r, &arg_i)) {
-        pa_log("GetProperties reply has no arguments.");
-        goto finish;
-    }
-
-    if (dbus_message_iter_get_arg_type(&arg_i) != DBUS_TYPE_ARRAY) {
-        pa_log("GetProperties argument is not an array.");
-        goto finish;
-    }
-
-    dbus_message_iter_recurse(&arg_i, &element_i);
-    while (dbus_message_iter_get_arg_type(&element_i) != DBUS_TYPE_INVALID) {
-
-        if (dbus_message_iter_get_arg_type(&element_i) == DBUS_TYPE_DICT_ENTRY) {
-            DBusMessageIter dict_i;
-
-            dbus_message_iter_recurse(&element_i, &dict_i);
-
-            if (dbus_message_has_interface(p->message, "org.bluez.Manager")) {
-                if (parse_manager_property(y, &dict_i, false) < 0)
-                    goto finish;
-
-            } else if (dbus_message_has_interface(p->message, "org.bluez.Adapter")) {
-                if (parse_adapter_property(y, &dict_i, false) < 0)
-                    goto finish;
-
-            } else if (dbus_message_has_interface(p->message, "org.bluez.Device")) {
-                if (parse_device_property(d, &dict_i, false) < 0)
-                    goto finish;
-
-            } else if (parse_audio_property(d, dbus_message_get_interface(p->message), &dict_i, false) < 0)
-                goto finish;
-
-        }
-
-        dbus_message_iter_next(&element_i);
-    }
-
-finish:
-    if (d != NULL && old_any_connected != pa_bluez4_device_any_audio_connected(d))
-        run_callback(d, false);
-
-finish2:
-    dbus_message_unref(r);
-
-    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
-    pa_dbus_pending_free(p);
-}
-
-static pa_dbus_pending* send_and_add_to_pending(pa_bluez4_discovery *y, DBusMessage *m, DBusPendingCallNotifyFunction func,
-                                                void *call_data) {
-    pa_dbus_pending *p;
-    DBusPendingCall *call;
-
-    pa_assert(y);
-    pa_assert(m);
-
-    pa_assert_se(dbus_connection_send_with_reply(pa_dbus_connection_get(y->connection), m, &call, -1));
-
-    p = pa_dbus_pending_new(pa_dbus_connection_get(y->connection), m, call, y, call_data);
-    PA_LLIST_PREPEND(pa_dbus_pending, y->pending, p);
-    dbus_pending_call_set_notify(call, func, p, NULL);
-
-    return p;
-}
-
-static void register_endpoint_reply(DBusPendingCall *pending, void *userdata) {
-    DBusMessage *r;
-    pa_dbus_pending *p;
-    pa_bluez4_discovery *y;
-    char *endpoint;
-
-    pa_assert(pending);
-    pa_assert_se(p = userdata);
-    pa_assert_se(y = p->context_data);
-    pa_assert_se(endpoint = p->call_data);
-    pa_assert_se(r = dbus_pending_call_steal_reply(pending));
-
-    if (dbus_message_is_error(r, DBUS_ERROR_SERVICE_UNKNOWN)) {
-        pa_log_debug("Bluetooth daemon is apparently not available.");
-        remove_all_devices(y);
-        goto finish;
-    }
-
-    if (dbus_message_is_error(r, PA_BLUEZ4_ERROR_NOT_SUPPORTED)) {
-        pa_log_info("Couldn't register endpoint %s, because BlueZ is configured to disable the endpoint type.", endpoint);
-        goto finish;
-    }
-
-    if (dbus_message_get_type(r) == DBUS_MESSAGE_TYPE_ERROR) {
-        pa_log("org.bluez.Media.RegisterEndpoint() failed: %s: %s", dbus_message_get_error_name(r),
-               pa_dbus_get_error_message(r));
-        goto finish;
-    }
-
-finish:
-    dbus_message_unref(r);
-
-    PA_LLIST_REMOVE(pa_dbus_pending, y->pending, p);
-    pa_dbus_pending_free(p);
-
-    pa_xfree(endpoint);
-}
-
-static void register_endpoint(pa_bluez4_discovery *y, const char *path, const char *endpoint, const char *uuid) {
-    DBusMessage *m;
-    DBusMessageIter i, d;
-    uint8_t codec = 0;
-
-    pa_log_debug("Registering %s on adapter %s.", endpoint, path);
-
-    pa_assert_se(m = dbus_message_new_method_call("org.bluez", path, "org.bluez.Media", "RegisterEndpoint"));
-
-    dbus_message_iter_init_append(m, &i);
-
-    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_OBJECT_PATH, &endpoint));
-
-    dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING
-                                    DBUS_TYPE_STRING_AS_STRING DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING,
-                                    &d);
-
-    pa_dbus_append_basic_variant_dict_entry(&d, "UUID", DBUS_TYPE_STRING, &uuid);
-
-    pa_dbus_append_basic_variant_dict_entry(&d, "Codec", DBUS_TYPE_BYTE, &codec);
-
-    if (pa_streq(uuid, PA_BLUEZ4_UUID_HFP_AG) || pa_streq(uuid, PA_BLUEZ4_UUID_HFP_HF)) {
-        uint8_t capability = 0;
-        pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capability, 1);
-    } else {
-        a2dp_sbc_t capabilities;
-
-        capabilities.channel_mode = SBC_CHANNEL_MODE_MONO | SBC_CHANNEL_MODE_DUAL_CHANNEL |
-                                    SBC_CHANNEL_MODE_STEREO | SBC_CHANNEL_MODE_JOINT_STEREO;
-        capabilities.frequency = SBC_SAMPLING_FREQ_16000 | SBC_SAMPLING_FREQ_32000 |
-                                 SBC_SAMPLING_FREQ_44100 | SBC_SAMPLING_FREQ_48000;
-        capabilities.allocation_method = SBC_ALLOCATION_SNR | SBC_ALLOCATION_LOUDNESS;
-        capabilities.subbands = SBC_SUBBANDS_4 | SBC_SUBBANDS_8;
-        capabilities.block_length = SBC_BLOCK_LENGTH_4 | SBC_BLOCK_LENGTH_8 |
-                                    SBC_BLOCK_LENGTH_12 | SBC_BLOCK_LENGTH_16;
-        capabilities.min_bitpool = MIN_BITPOOL;
-        capabilities.max_bitpool = MAX_BITPOOL;
-
-        pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capabilities, sizeof(capabilities));
-    }
-
-    dbus_message_iter_close_container(&i, &d);
-
-    send_and_add_to_pending(y, m, register_endpoint_reply, pa_xstrdup(endpoint));
-}
-
-static void found_adapter(pa_bluez4_discovery *y, const char *path) {
-    DBusMessage *m;
-
-    pa_assert_se(m = dbus_message_new_method_call("org.bluez", path, "org.bluez.Adapter", "GetProperties"));
-    send_and_add_to_pending(y, m, get_properties_reply, NULL);
-
-    register_endpoint(y, path, ENDPOINT_PATH_HFP_AG, PA_BLUEZ4_UUID_HFP_AG);
-    register_endpoint(y, path, ENDPOINT_PATH_HFP_HS, PA_BLUEZ4_UUID_HFP_HF);
-    register_endpoint(y, path, ENDPOINT_PATH_A2DP_SOURCE, PA_BLUEZ4_UUID_A2DP_SOURCE);
-    register_endpoint(y, path, ENDPOINT_PATH_A2DP_SINK, PA_BLUEZ4_UUID_A2DP_SINK);
-}
-
-static void list_adapters(pa_bluez4_discovery *y) {
-    DBusMessage *m;
-    pa_assert(y);
-
-    pa_assert_se(m = dbus_message_new_method_call("org.bluez", "/", "org.bluez.Manager", "GetProperties"));
-    send_and_add_to_pending(y, m, get_properties_reply, NULL);
-}
-
-static int transport_parse_property(pa_bluez4_transport *t, DBusMessageIter *i) {
-    const char *key;
-    DBusMessageIter variant_i;
-
-    key = check_variant_property(i);
-    if (key == NULL)
-        return -1;
-
-    dbus_message_iter_recurse(i, &variant_i);
-
-    switch (dbus_message_iter_get_arg_type(&variant_i)) {
-
-        case DBUS_TYPE_BOOLEAN: {
-
-            dbus_bool_t value;
-            dbus_message_iter_get_basic(&variant_i, &value);
-
-            if (pa_streq(key, "NREC") && t->nrec != value) {
-                t->nrec = value;
-                pa_log_debug("Transport %s: Property 'NREC' changed to %s.", t->path, t->nrec ? "True" : "False");
-                pa_hook_fire(&t->device->discovery->hooks[PA_BLUEZ4_HOOK_TRANSPORT_NREC_CHANGED], t);
-            }
-
-            break;
-         }
-    }
-
-    return 0;
-}
-
-static DBusHandlerResult filter_cb(DBusConnection *bus, DBusMessage *m, void *userdata) {
-    DBusError err;
-    pa_bluez4_discovery *y;
-
-    pa_assert(bus);
-    pa_assert(m);
-
-    pa_assert_se(y = userdata);
-
-    dbus_error_init(&err);
-
-    pa_log_debug("dbus: interface=%s, path=%s, member=%s",
-            dbus_message_get_interface(m),
-            dbus_message_get_path(m),
-            dbus_message_get_member(m));
-
-    if (dbus_message_is_signal(m, "org.bluez.Adapter", "DeviceRemoved")) {
-        const char *path;
-        pa_bluez4_device *d;
-
-        if (!dbus_message_get_args(m, &err, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID)) {
-            pa_log("Failed to parse org.bluez.Adapter.DeviceRemoved: %s", err.message);
-            goto fail;
-        }
-
-        pa_log_debug("Device %s removed", path);
-
-        if ((d = pa_hashmap_remove(y->devices, path))) {
-            run_callback(d, true);
-            device_free(d);
-        }
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    } else if (dbus_message_is_signal(m, "org.bluez.Adapter", "DeviceCreated")) {
-        const char *path;
-
-        if (!dbus_message_get_args(m, &err, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID)) {
-            pa_log("Failed to parse org.bluez.Adapter.DeviceCreated: %s", err.message);
-            goto fail;
-        }
-
-        pa_log_debug("Device %s created", path);
-
-        found_device(y, path);
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    } else if (dbus_message_is_signal(m, "org.bluez.Manager", "AdapterAdded")) {
-        const char *path;
-
-        if (!dbus_message_get_args(m, &err, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID)) {
-            pa_log("Failed to parse org.bluez.Manager.AdapterAdded: %s", err.message);
-            goto fail;
-        }
-
-        if (!y->adapters_listed) {
-            pa_log_debug("Ignoring 'AdapterAdded' because initial adapter list has not been received yet.");
-            return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-        }
-
-        pa_log_debug("Adapter %s created", path);
-
-        found_adapter(y, path);
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    } else if (dbus_message_is_signal(m, "org.bluez.Audio", "PropertyChanged") ||
-               dbus_message_is_signal(m, "org.bluez.Headset", "PropertyChanged") ||
-               dbus_message_is_signal(m, "org.bluez.AudioSink", "PropertyChanged") ||
-               dbus_message_is_signal(m, "org.bluez.AudioSource", "PropertyChanged") ||
-               dbus_message_is_signal(m, "org.bluez.HandsfreeGateway", "PropertyChanged") ||
-               dbus_message_is_signal(m, "org.bluez.Device", "PropertyChanged")) {
-
-        pa_bluez4_device *d;
-
-        if ((d = pa_hashmap_get(y->devices, dbus_message_get_path(m)))) {
-            DBusMessageIter arg_i;
-            bool old_any_connected = pa_bluez4_device_any_audio_connected(d);
-
-            if (!dbus_message_iter_init(m, &arg_i)) {
-                pa_log("Failed to parse PropertyChanged for device %s", d->path);
-                goto fail;
-            }
-
-            if (dbus_message_has_interface(m, "org.bluez.Device")) {
-                if (parse_device_property(d, &arg_i, true) < 0)
-                    goto fail;
-
-            } else if (parse_audio_property(d, dbus_message_get_interface(m), &arg_i, true) < 0)
-                goto fail;
-
-            if (old_any_connected != pa_bluez4_device_any_audio_connected(d))
-                run_callback(d, false);
-        }
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    } else if (dbus_message_is_signal(m, "org.freedesktop.DBus", "NameOwnerChanged")) {
-        const char *name, *old_owner, *new_owner;
-
-        if (!dbus_message_get_args(m, &err,
-                                   DBUS_TYPE_STRING, &name,
-                                   DBUS_TYPE_STRING, &old_owner,
-                                   DBUS_TYPE_STRING, &new_owner,
-                                   DBUS_TYPE_INVALID)) {
-            pa_log("Failed to parse org.freedesktop.DBus.NameOwnerChanged: %s", err.message);
-            goto fail;
-        }
-
-        if (pa_streq(name, "org.bluez")) {
-            if (old_owner && *old_owner) {
-                pa_log_debug("Bluetooth daemon disappeared.");
-                remove_all_devices(y);
-                y->adapters_listed = false;
-            }
-
-            if (new_owner && *new_owner) {
-                pa_log_debug("Bluetooth daemon appeared.");
-                list_adapters(y);
-            }
-        }
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-    } else if (dbus_message_is_signal(m, "org.bluez.MediaTransport", "PropertyChanged")) {
-        pa_bluez4_transport *t;
-        DBusMessageIter arg_i;
-
-        if (!(t = pa_hashmap_get(y->transports, dbus_message_get_path(m))))
-            goto fail;
-
-        if (!dbus_message_iter_init(m, &arg_i)) {
-            pa_log("Failed to parse PropertyChanged for transport %s", t->path);
-            goto fail;
-        }
-
-        if (transport_parse_property(t, &arg_i) < 0)
-            goto fail;
-
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-    }
-
-fail:
-    dbus_error_free(&err);
-
-    return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-}
-
-pa_bluez4_device* pa_bluez4_discovery_get_by_address(pa_bluez4_discovery *y, const char* address) {
-    pa_bluez4_device *d;
-    void *state = NULL;
-
-    pa_assert(y);
-    pa_assert(PA_REFCNT_VALUE(y) > 0);
-    pa_assert(address);
-
-    while ((d = pa_hashmap_iterate(y->devices, &state, NULL)))
-        if (pa_streq(d->address, address))
-            return d->device_info_valid == 1 ? d : NULL;
-
-    return NULL;
-}
-
-pa_bluez4_device* pa_bluez4_discovery_get_by_path(pa_bluez4_discovery *y, const char* path) {
-    pa_bluez4_device *d;
-
-    pa_assert(y);
-    pa_assert(PA_REFCNT_VALUE(y) > 0);
-    pa_assert(path);
-
-    if ((d = pa_hashmap_get(y->devices, path)))
-        if (d->device_info_valid == 1)
-            return d;
-
-    return NULL;
-}
-
-bool pa_bluez4_device_any_audio_connected(const pa_bluez4_device *d) {
-    unsigned i;
-
-    pa_assert(d);
-
-    if (d->dead || d->device_info_valid != 1)
-        return false;
-
-    if (d->audio_state == PA_BLUEZ4_AUDIO_STATE_INVALID)
-        return false;
-
-    /* Make sure audio_state is *not* in CONNECTING state before we fire the
-     * hook to report the new device state. This is actually very important in
-     * order to make module-card-restore work well with headsets: if the headset
-     * supports both HSP and A2DP, one of those profiles is connected first and
-     * then the other, and lastly the Audio interface becomes connected.
-     * Checking only audio_state means that this function will return false at
-     * the time when only the first connection has been made. This is good,
-     * because otherwise, if the first connection is for HSP and we would
-     * already load a new device module instance, and module-card-restore tries
-     * to restore the A2DP profile, that would fail because A2DP is not yet
-     * connected. Waiting until the Audio interface gets connected means that
-     * both headset profiles will be connected when the device module is
-     * loaded. */
-    if (d->audio_state == PA_BLUEZ4_AUDIO_STATE_CONNECTING)
-        return false;
-
-    for (i = 0; i < PA_BLUEZ4_PROFILE_COUNT; i++)
-        if (d->transports[i] && d->transports[i]->state != PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED)
-            return true;
-
-    return false;
-}
-
-int pa_bluez4_transport_acquire(pa_bluez4_transport *t, bool optional, size_t *imtu, size_t *omtu) {
-    const char *accesstype = "rw";
-    DBusMessage *m, *r;
-    DBusError err;
-    int ret;
-    uint16_t i, o;
-
-    pa_assert(t);
-    pa_assert(t->device);
-    pa_assert(t->device->discovery);
-
-    if (optional) {
-        /* FIXME: we are trying to acquire the transport only if the stream is
-           playing, without actually initiating the stream request from our side
-           (which is typically undesireable specially for hfgw use-cases.
-           However this approach is racy, since the stream could have been
-           suspended in the meantime, so we can't really guarantee that the
-           stream will not be requested until BlueZ's API supports this
-           atomically. */
-        if (t->state < PA_BLUEZ4_TRANSPORT_STATE_PLAYING) {
-            pa_log_info("Failed optional acquire of transport %s", t->path);
-            return -1;
-        }
-    }
-
-    dbus_error_init(&err);
-
-    pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, "org.bluez.MediaTransport", "Acquire"));
-    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_STRING, &accesstype, DBUS_TYPE_INVALID));
-    r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(t->device->discovery->connection), m, -1, &err);
-    dbus_message_unref(m);
-    m = NULL;
-
-    if (!r) {
-        dbus_error_free(&err);
-        return -1;
-    }
-
-    if (!dbus_message_get_args(r, &err, DBUS_TYPE_UNIX_FD, &ret, DBUS_TYPE_UINT16, &i, DBUS_TYPE_UINT16, &o,
-                               DBUS_TYPE_INVALID)) {
-        pa_log("Failed to parse org.bluez.MediaTransport.Acquire(): %s", err.message);
-        ret = -1;
-        dbus_error_free(&err);
-        goto fail;
-    }
-
-    if (imtu)
-        *imtu = i;
-
-    if (omtu)
-        *omtu = o;
-
-fail:
-    dbus_message_unref(r);
-    return ret;
-}
-
-void pa_bluez4_transport_release(pa_bluez4_transport *t) {
-    const char *accesstype = "rw";
-    DBusMessage *m, *r;
-    DBusError err;
-
-    pa_assert(t);
-    pa_assert(t->device);
-    pa_assert(t->device->discovery);
-
-    dbus_error_init(&err);
-
-    pa_assert_se(m = dbus_message_new_method_call(t->owner, t->path, "org.bluez.MediaTransport", "Release"));
-    pa_assert_se(dbus_message_append_args(m, DBUS_TYPE_STRING, &accesstype, DBUS_TYPE_INVALID));
-    r = dbus_connection_send_with_reply_and_block(pa_dbus_connection_get(t->device->discovery->connection), m, -1, &err);
-    dbus_message_unref(m);
-    m = NULL;
-    if (r) {
-        dbus_message_unref(r);
-        r = NULL;
-    }
-
-    if (dbus_error_is_set(&err)) {
-        pa_log("Failed to release transport %s: %s", t->path, err.message);
-        dbus_error_free(&err);
-    } else
-        pa_log_info("Transport %s released", t->path);
-}
-
-static void set_property(pa_bluez4_discovery *y, const char *bus, const char *path, const char *interface,
-                         const char *prop_name, int prop_type, void *prop_value) {
-    DBusMessage *m;
-    DBusMessageIter i;
-
-    pa_assert(y);
-    pa_assert(path);
-    pa_assert(interface);
-    pa_assert(prop_name);
-
-    pa_assert_se(m = dbus_message_new_method_call(bus, path, interface, "SetProperty"));
-    dbus_message_iter_init_append(m, &i);
-    pa_assert_se(dbus_message_iter_append_basic(&i, DBUS_TYPE_STRING, &prop_name));
-    pa_dbus_append_basic_variant(&i, prop_type, prop_value);
-
-    dbus_message_set_no_reply(m, true);
-    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), m, NULL));
-    dbus_message_unref(m);
-}
-
-void pa_bluez4_transport_set_microphone_gain(pa_bluez4_transport *t, uint16_t value) {
-    dbus_uint16_t gain = PA_MIN(value, HSP_MAX_GAIN);
-
-    pa_assert(t);
-    pa_assert(t->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT);
-
-    set_property(t->device->discovery, "org.bluez", t->device->path, "org.bluez.Headset",
-                 "MicrophoneGain", DBUS_TYPE_UINT16, &gain);
-}
-
-void pa_bluez4_transport_set_speaker_gain(pa_bluez4_transport *t, uint16_t value) {
-    dbus_uint16_t gain = PA_MIN(value, HSP_MAX_GAIN);
-
-    pa_assert(t);
-    pa_assert(t->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT);
-
-    set_property(t->device->discovery, "org.bluez", t->device->path, "org.bluez.Headset",
-                 "SpeakerGain", DBUS_TYPE_UINT16, &gain);
-}
-
-static int setup_dbus(pa_bluez4_discovery *y) {
-    DBusError err;
-
-    dbus_error_init(&err);
-
-    if (!(y->connection = pa_dbus_bus_get(y->core, DBUS_BUS_SYSTEM, &err))) {
-        pa_log("Failed to get D-Bus connection: %s", err.message);
-        dbus_error_free(&err);
-        return -1;
-    }
-
-    return 0;
-}
-
-static pa_bluez4_transport *transport_new(pa_bluez4_device *d, const char *owner, const char *path, pa_bluez4_profile_t p,
-                                             const uint8_t *config, int size) {
-    pa_bluez4_transport *t;
-
-    t = pa_xnew0(pa_bluez4_transport, 1);
-    t->device = d;
-    t->owner = pa_xstrdup(owner);
-    t->path = pa_xstrdup(path);
-    t->profile = p;
-    t->config_size = size;
-
-    if (size > 0) {
-        t->config = pa_xnew(uint8_t, size);
-        memcpy(t->config, config, size);
-    }
-
-    t->state = audio_state_to_transport_state(d->profile_state[p]);
-
-    return t;
-}
-
-static void transport_set_state(pa_bluez4_transport *transport, pa_bluez4_transport_state_t state) {
-    if (transport->state == state)
-        return;
-
-    pa_log_debug("Transport %s state: %s -> %s",
-                 transport->path, transport_state_to_string(transport->state), transport_state_to_string(state));
-
-    transport->state = state;
-
-    pa_hook_fire(&transport->device->discovery->hooks[PA_BLUEZ4_HOOK_TRANSPORT_STATE_CHANGED], transport);
-}
-
-static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage *m, void *userdata) {
-    pa_bluez4_discovery *y = userdata;
-    pa_bluez4_device *d;
-    pa_bluez4_transport *t;
-    const char *sender, *path, *dev_path = NULL, *uuid = NULL;
-    uint8_t *config = NULL;
-    int size = 0;
-    bool nrec = false;
-    pa_bluez4_profile_t p;
-    DBusMessageIter args, props;
-    DBusMessage *r;
-    bool old_any_connected;
-
-    if (!dbus_message_iter_init(m, &args) || !pa_streq(dbus_message_get_signature(m), "oa{sv}")) {
-        pa_log("Invalid signature for method SetConfiguration");
-        goto fail2;
-    }
-
-    dbus_message_iter_get_basic(&args, &path);
-
-    if (pa_hashmap_get(y->transports, path)) {
-        pa_log("org.bluez.MediaEndpoint.SetConfiguration: Transport %s is already configured.", path);
-        goto fail2;
-    }
-
-    pa_assert_se(dbus_message_iter_next(&args));
-
-    dbus_message_iter_recurse(&args, &props);
-    if (dbus_message_iter_get_arg_type(&props) != DBUS_TYPE_DICT_ENTRY)
-        goto fail;
-
-    /* Read transport properties */
-    while (dbus_message_iter_get_arg_type(&props) == DBUS_TYPE_DICT_ENTRY) {
-        const char *key;
-        DBusMessageIter value, entry;
-        int var;
-
-        dbus_message_iter_recurse(&props, &entry);
-        dbus_message_iter_get_basic(&entry, &key);
-
-        dbus_message_iter_next(&entry);
-        dbus_message_iter_recurse(&entry, &value);
-
-        var = dbus_message_iter_get_arg_type(&value);
-
-        if (strcasecmp(key, "UUID") == 0) {
-            if (var != DBUS_TYPE_STRING)
-                goto fail;
-
-            dbus_message_iter_get_basic(&value, &uuid);
-        } else if (strcasecmp(key, "Device") == 0) {
-            if (var != DBUS_TYPE_OBJECT_PATH)
-                goto fail;
-
-            dbus_message_iter_get_basic(&value, &dev_path);
-        } else if (strcasecmp(key, "NREC") == 0) {
-            dbus_bool_t tmp_boolean;
-            if (var != DBUS_TYPE_BOOLEAN)
-                goto fail;
-
-            dbus_message_iter_get_basic(&value, &tmp_boolean);
-            nrec = tmp_boolean;
-        } else if (strcasecmp(key, "Configuration") == 0) {
-            DBusMessageIter array;
-            if (var != DBUS_TYPE_ARRAY)
-                goto fail;
-
-            dbus_message_iter_recurse(&value, &array);
-            dbus_message_iter_get_fixed_array(&array, &config, &size);
-        }
-
-        dbus_message_iter_next(&props);
-    }
-
-    d = found_device(y, dev_path);
-    if (!d)
-        goto fail;
-
-    if (dbus_message_has_path(m, ENDPOINT_PATH_HFP_AG))
-        p = PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT;
-    else if (dbus_message_has_path(m, ENDPOINT_PATH_HFP_HS))
-        p = PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY;
-    else if (dbus_message_has_path(m, ENDPOINT_PATH_A2DP_SOURCE))
-        p = PA_BLUEZ4_PROFILE_A2DP_SINK;
-    else
-        p = PA_BLUEZ4_PROFILE_A2DP_SOURCE;
-
-    if (d->transports[p] != NULL) {
-        pa_log("Cannot configure transport %s because profile %d is already used", path, p);
-        goto fail2;
-    }
-
-    old_any_connected = pa_bluez4_device_any_audio_connected(d);
-
-    sender = dbus_message_get_sender(m);
-
-    t = transport_new(d, sender, path, p, config, size);
-    if (nrec)
-        t->nrec = nrec;
-
-    d->transports[p] = t;
-    pa_assert_se(pa_hashmap_put(y->transports, t->path, t) >= 0);
-
-    pa_log_debug("Transport %s profile %d available", t->path, t->profile);
-
-    pa_assert_se(r = dbus_message_new_method_return(m));
-    pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), r, NULL));
-    dbus_message_unref(r);
-
-    if (old_any_connected != pa_bluez4_device_any_audio_connected(d))
-        run_callback(d, false);
-
-    return NULL;
-
-fail:
-    pa_log("org.bluez.MediaEndpoint.SetConfiguration: invalid arguments");
-
-fail2:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.MediaEndpoint.Error.InvalidArguments",
-                                            "Unable to set configuration"));
-    return r;
-}
-
-static DBusMessage *endpoint_clear_configuration(DBusConnection *c, DBusMessage *m, void *userdata) {
-    pa_bluez4_discovery *y = userdata;
-    pa_bluez4_transport *t;
-    DBusMessage *r;
-    DBusError e;
-    const char *path;
-
-    dbus_error_init(&e);
-
-    if (!dbus_message_get_args(m, &e, DBUS_TYPE_OBJECT_PATH, &path, DBUS_TYPE_INVALID)) {
-        pa_log("org.bluez.MediaEndpoint.ClearConfiguration: %s", e.message);
-        dbus_error_free(&e);
-        goto fail;
-    }
-
-    if ((t = pa_hashmap_get(y->transports, path))) {
-        bool old_any_connected = pa_bluez4_device_any_audio_connected(t->device);
-
-        pa_log_debug("Clearing transport %s profile %d", t->path, t->profile);
-        t->device->transports[t->profile] = NULL;
-        pa_hashmap_remove(y->transports, t->path);
-        transport_set_state(t, PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED);
-
-        if (old_any_connected != pa_bluez4_device_any_audio_connected(t->device))
-            run_callback(t->device, false);
-
-        transport_free(t);
-    }
-
-    pa_assert_se(r = dbus_message_new_method_return(m));
-
-    return r;
-
-fail:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.MediaEndpoint.Error.InvalidArguments",
-                                            "Unable to clear configuration"));
-    return r;
-}
-
-static uint8_t a2dp_default_bitpool(uint8_t freq, uint8_t mode) {
-
-    switch (freq) {
-        case SBC_SAMPLING_FREQ_16000:
-        case SBC_SAMPLING_FREQ_32000:
-            return 53;
-
-        case SBC_SAMPLING_FREQ_44100:
-
-            switch (mode) {
-                case SBC_CHANNEL_MODE_MONO:
-                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                    return 31;
-
-                case SBC_CHANNEL_MODE_STEREO:
-                case SBC_CHANNEL_MODE_JOINT_STEREO:
-                    return 53;
-
-                default:
-                    pa_log_warn("Invalid channel mode %u", mode);
-                    return 53;
-            }
-
-        case SBC_SAMPLING_FREQ_48000:
-
-            switch (mode) {
-                case SBC_CHANNEL_MODE_MONO:
-                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                    return 29;
-
-                case SBC_CHANNEL_MODE_STEREO:
-                case SBC_CHANNEL_MODE_JOINT_STEREO:
-                    return 51;
-
-                default:
-                    pa_log_warn("Invalid channel mode %u", mode);
-                    return 51;
-            }
-
-        default:
-            pa_log_warn("Invalid sampling freq %u", freq);
-            return 53;
-    }
-}
-
-static DBusMessage *endpoint_select_configuration(DBusConnection *c, DBusMessage *m, void *userdata) {
-    pa_bluez4_discovery *y = userdata;
-    a2dp_sbc_t *cap, config;
-    uint8_t *pconf = (uint8_t *) &config;
-    int i, size;
-    DBusMessage *r;
-    DBusError e;
-
-    static const struct {
-        uint32_t rate;
-        uint8_t cap;
-    } freq_table[] = {
-        { 16000U, SBC_SAMPLING_FREQ_16000 },
-        { 32000U, SBC_SAMPLING_FREQ_32000 },
-        { 44100U, SBC_SAMPLING_FREQ_44100 },
-        { 48000U, SBC_SAMPLING_FREQ_48000 }
-    };
-
-    dbus_error_init(&e);
-
-    if (!dbus_message_get_args(m, &e, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &cap, &size, DBUS_TYPE_INVALID)) {
-        pa_log("org.bluez.MediaEndpoint.SelectConfiguration: %s", e.message);
-        dbus_error_free(&e);
-        goto fail;
-    }
-
-    if (dbus_message_has_path(m, ENDPOINT_PATH_HFP_AG) || dbus_message_has_path(m, ENDPOINT_PATH_HFP_HS))
-        goto done;
-
-    pa_assert(size == sizeof(config));
-
-    memset(&config, 0, sizeof(config));
-
-    /* Find the lowest freq that is at least as high as the requested
-     * sampling rate */
-    for (i = 0; (unsigned) i < PA_ELEMENTSOF(freq_table); i++)
-        if (freq_table[i].rate >= y->core->default_sample_spec.rate && (cap->frequency & freq_table[i].cap)) {
-            config.frequency = freq_table[i].cap;
-            break;
-        }
-
-    if ((unsigned) i == PA_ELEMENTSOF(freq_table)) {
-        for (--i; i >= 0; i--) {
-            if (cap->frequency & freq_table[i].cap) {
-                config.frequency = freq_table[i].cap;
-                break;
-            }
-        }
-
-        if (i < 0) {
-            pa_log("Not suitable sample rate");
-            goto fail;
-        }
-    }
-
-    pa_assert((unsigned) i < PA_ELEMENTSOF(freq_table));
-
-    if (y->core->default_sample_spec.channels <= 1) {
-        if (cap->channel_mode & SBC_CHANNEL_MODE_MONO)
-            config.channel_mode = SBC_CHANNEL_MODE_MONO;
-    }
-
-    if (y->core->default_sample_spec.channels >= 2) {
-        if (cap->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
-            config.channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_STEREO)
-            config.channel_mode = SBC_CHANNEL_MODE_STEREO;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
-            config.channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_MONO) {
-            config.channel_mode = SBC_CHANNEL_MODE_MONO;
-        } else {
-            pa_log("No supported channel modes");
-            goto fail;
-        }
-    }
-
-    if (cap->block_length & SBC_BLOCK_LENGTH_16)
-        config.block_length = SBC_BLOCK_LENGTH_16;
-    else if (cap->block_length & SBC_BLOCK_LENGTH_12)
-        config.block_length = SBC_BLOCK_LENGTH_12;
-    else if (cap->block_length & SBC_BLOCK_LENGTH_8)
-        config.block_length = SBC_BLOCK_LENGTH_8;
-    else if (cap->block_length & SBC_BLOCK_LENGTH_4)
-        config.block_length = SBC_BLOCK_LENGTH_4;
-    else {
-        pa_log_error("No supported block lengths");
-        goto fail;
-    }
-
-    if (cap->subbands & SBC_SUBBANDS_8)
-        config.subbands = SBC_SUBBANDS_8;
-    else if (cap->subbands & SBC_SUBBANDS_4)
-        config.subbands = SBC_SUBBANDS_4;
-    else {
-        pa_log_error("No supported subbands");
-        goto fail;
-    }
-
-    if (cap->allocation_method & SBC_ALLOCATION_LOUDNESS)
-        config.allocation_method = SBC_ALLOCATION_LOUDNESS;
-    else if (cap->allocation_method & SBC_ALLOCATION_SNR)
-        config.allocation_method = SBC_ALLOCATION_SNR;
-
-    config.min_bitpool = (uint8_t) PA_MAX(MIN_BITPOOL, cap->min_bitpool);
-    config.max_bitpool = (uint8_t) PA_MIN(a2dp_default_bitpool(config.frequency, config.channel_mode), cap->max_bitpool);
-
-done:
-    pa_assert_se(r = dbus_message_new_method_return(m));
-
-    pa_assert_se(dbus_message_append_args(
-                                     r,
-                                     DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &pconf, size,
-                                     DBUS_TYPE_INVALID));
-
-    return r;
-
-fail:
-    pa_assert_se(r = dbus_message_new_error(m, "org.bluez.MediaEndpoint.Error.InvalidArguments",
-                                            "Unable to select configuration"));
-    return r;
-}
-
-static DBusHandlerResult endpoint_handler(DBusConnection *c, DBusMessage *m, void *userdata) {
-    struct pa_bluez4_discovery *y = userdata;
-    DBusMessage *r = NULL;
-    DBusError e;
-    const char *path, *interface, *member;
-
-    pa_assert(y);
-
-    path = dbus_message_get_path(m);
-    interface = dbus_message_get_interface(m);
-    member = dbus_message_get_member(m);
-
-    pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
-
-    dbus_error_init(&e);
-
-    if (!pa_streq(path, ENDPOINT_PATH_A2DP_SOURCE) && !pa_streq(path, ENDPOINT_PATH_A2DP_SINK)
-            && !pa_streq(path, ENDPOINT_PATH_HFP_AG) && !pa_streq(path, ENDPOINT_PATH_HFP_HS))
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
-        const char *xml = ENDPOINT_INTROSPECT_XML;
-
-        pa_assert_se(r = dbus_message_new_method_return(m));
-        pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_STRING, &xml, DBUS_TYPE_INVALID));
-
-    } else if (dbus_message_is_method_call(m, "org.bluez.MediaEndpoint", "SetConfiguration"))
-        r = endpoint_set_configuration(c, m, userdata);
-    else if (dbus_message_is_method_call(m, "org.bluez.MediaEndpoint", "SelectConfiguration"))
-        r = endpoint_select_configuration(c, m, userdata);
-    else if (dbus_message_is_method_call(m, "org.bluez.MediaEndpoint", "ClearConfiguration"))
-        r = endpoint_clear_configuration(c, m, userdata);
-    else
-        return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
-
-    if (r) {
-        pa_assert_se(dbus_connection_send(pa_dbus_connection_get(y->connection), r, NULL));
-        dbus_message_unref(r);
-    }
-
-    return DBUS_HANDLER_RESULT_HANDLED;
-}
-
-pa_bluez4_discovery* pa_bluez4_discovery_get(pa_core *c) {
-    DBusError err;
-    pa_bluez4_discovery *y;
-    DBusConnection *conn;
-    unsigned i;
-    static const DBusObjectPathVTable vtable_endpoint = {
-        .message_function = endpoint_handler,
-    };
-
-    pa_assert(c);
-
-    dbus_error_init(&err);
-
-    if ((y = pa_shared_get(c, "bluez4-discovery")))
-        return pa_bluez4_discovery_ref(y);
-
-    y = pa_xnew0(pa_bluez4_discovery, 1);
-    PA_REFCNT_INIT(y);
-    y->core = c;
-    y->devices = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
-    y->transports = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
-    PA_LLIST_HEAD_INIT(pa_dbus_pending, y->pending);
-
-    for (i = 0; i < PA_BLUEZ4_HOOK_MAX; i++)
-        pa_hook_init(&y->hooks[i], y);
-
-    pa_shared_set(c, "bluez4-discovery", y);
-
-    if (setup_dbus(y) < 0)
-        goto fail;
-
-    conn = pa_dbus_connection_get(y->connection);
-
-    /* dynamic detection of bluetooth audio devices */
-    if (!dbus_connection_add_filter(conn, filter_cb, y, NULL)) {
-        pa_log_error("Failed to add filter function");
-        goto fail;
-    }
-
-    y->filter_added = true;
-
-    if (pa_dbus_add_matches(
-                conn, &err,
-                "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged'"
-                ",arg0='org.bluez'",
-                "type='signal',sender='org.bluez',interface='org.bluez.Manager',member='AdapterAdded'",
-                "type='signal',sender='org.bluez',interface='org.bluez.Adapter',member='DeviceRemoved'",
-                "type='signal',sender='org.bluez',interface='org.bluez.Adapter',member='DeviceCreated'",
-                "type='signal',sender='org.bluez',interface='org.bluez.Device',member='PropertyChanged'",
-                "type='signal',sender='org.bluez',interface='org.bluez.Audio',member='PropertyChanged'",
-                "type='signal',sender='org.bluez',interface='org.bluez.Headset',member='PropertyChanged'",
-                "type='signal',sender='org.bluez',interface='org.bluez.AudioSink',member='PropertyChanged'",
-                "type='signal',sender='org.bluez',interface='org.bluez.AudioSource',member='PropertyChanged'",
-                "type='signal',sender='org.bluez',interface='org.bluez.HandsfreeGateway',member='PropertyChanged'",
-                "type='signal',sender='org.bluez',interface='org.bluez.MediaTransport',member='PropertyChanged'",
-                NULL) < 0) {
-        pa_log("Failed to add D-Bus matches: %s", err.message);
-        goto fail;
-    }
-
-    pa_assert_se(dbus_connection_register_object_path(conn, ENDPOINT_PATH_HFP_AG, &vtable_endpoint, y));
-    pa_assert_se(dbus_connection_register_object_path(conn, ENDPOINT_PATH_HFP_HS, &vtable_endpoint, y));
-    pa_assert_se(dbus_connection_register_object_path(conn, ENDPOINT_PATH_A2DP_SOURCE, &vtable_endpoint, y));
-    pa_assert_se(dbus_connection_register_object_path(conn, ENDPOINT_PATH_A2DP_SINK, &vtable_endpoint, y));
-
-    list_adapters(y);
-
-    return y;
-
-fail:
-    if (y)
-        pa_bluez4_discovery_unref(y);
-
-    dbus_error_free(&err);
-
-    return NULL;
-}
-
-pa_bluez4_discovery* pa_bluez4_discovery_ref(pa_bluez4_discovery *y) {
-    pa_assert(y);
-    pa_assert(PA_REFCNT_VALUE(y) > 0);
-
-    PA_REFCNT_INC(y);
-
-    return y;
-}
-
-void pa_bluez4_discovery_unref(pa_bluez4_discovery *y) {
-    unsigned i;
-
-    pa_assert(y);
-    pa_assert(PA_REFCNT_VALUE(y) > 0);
-
-    if (PA_REFCNT_DEC(y) > 0)
-        return;
-
-    pa_dbus_free_pending_list(&y->pending);
-
-    if (y->devices) {
-        remove_all_devices(y);
-        pa_hashmap_free(y->devices);
-    }
-
-    if (y->transports) {
-        pa_assert(pa_hashmap_isempty(y->transports));
-        pa_hashmap_free(y->transports);
-    }
-
-    if (y->connection) {
-        dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), ENDPOINT_PATH_HFP_AG);
-        dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), ENDPOINT_PATH_HFP_HS);
-        dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), ENDPOINT_PATH_A2DP_SOURCE);
-        dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), ENDPOINT_PATH_A2DP_SINK);
-        pa_dbus_remove_matches(
-            pa_dbus_connection_get(y->connection),
-            "type='signal',sender='org.freedesktop.DBus',interface='org.freedesktop.DBus',member='NameOwnerChanged'"
-            ",arg0='org.bluez'",
-            "type='signal',sender='org.bluez',interface='org.bluez.Manager',member='AdapterAdded'",
-            "type='signal',sender='org.bluez',interface='org.bluez.Manager',member='AdapterRemoved'",
-            "type='signal',sender='org.bluez',interface='org.bluez.Adapter',member='DeviceRemoved'",
-            "type='signal',sender='org.bluez',interface='org.bluez.Adapter',member='DeviceCreated'",
-            "type='signal',sender='org.bluez',interface='org.bluez.Device',member='PropertyChanged'",
-            "type='signal',sender='org.bluez',interface='org.bluez.Audio',member='PropertyChanged'",
-            "type='signal',sender='org.bluez',interface='org.bluez.Headset',member='PropertyChanged'",
-            "type='signal',sender='org.bluez',interface='org.bluez.AudioSink',member='PropertyChanged'",
-            "type='signal',sender='org.bluez',interface='org.bluez.AudioSource',member='PropertyChanged'",
-            "type='signal',sender='org.bluez',interface='org.bluez.HandsfreeGateway',member='PropertyChanged'",
-            "type='signal',sender='org.bluez',interface='org.bluez.MediaTransport',member='PropertyChanged'",
-            NULL);
-
-        if (y->filter_added)
-            dbus_connection_remove_filter(pa_dbus_connection_get(y->connection), filter_cb, y);
-
-        pa_dbus_connection_unref(y->connection);
-    }
-
-    for (i = 0; i < PA_BLUEZ4_HOOK_MAX; i++)
-        pa_hook_done(&y->hooks[i]);
-
-    if (y->core)
-        pa_shared_remove(y->core, "bluez4-discovery");
-
-    pa_xfree(y);
-}
-
-pa_hook* pa_bluez4_discovery_hook(pa_bluez4_discovery *y, pa_bluez4_hook_t hook) {
-    pa_assert(y);
-    pa_assert(PA_REFCNT_VALUE(y) > 0);
-
-    return &y->hooks[hook];
-}
-
-pa_bluez4_form_factor_t pa_bluez4_get_form_factor(uint32_t class) {
-    unsigned major, minor;
-    pa_bluez4_form_factor_t r;
-
-    static const pa_bluez4_form_factor_t table[] = {
-        [1] = PA_BLUEZ4_FORM_FACTOR_HEADSET,
-        [2] = PA_BLUEZ4_FORM_FACTOR_HANDSFREE,
-        [4] = PA_BLUEZ4_FORM_FACTOR_MICROPHONE,
-        [5] = PA_BLUEZ4_FORM_FACTOR_SPEAKER,
-        [6] = PA_BLUEZ4_FORM_FACTOR_HEADPHONE,
-        [7] = PA_BLUEZ4_FORM_FACTOR_PORTABLE,
-        [8] = PA_BLUEZ4_FORM_FACTOR_CAR,
-        [10] = PA_BLUEZ4_FORM_FACTOR_HIFI
-    };
-
-    /*
-     * See Bluetooth Assigned Numbers:
-     * https://www.bluetooth.org/Technical/AssignedNumbers/baseband.htm
-     */
-    major = (class >> 8) & 0x1F;
-    minor = (class >> 2) & 0x3F;
-
-    switch (major) {
-        case 2:
-            return PA_BLUEZ4_FORM_FACTOR_PHONE;
-        case 4:
-            break;
-        default:
-            pa_log_debug("Unknown Bluetooth major device class %u", major);
-            return PA_BLUEZ4_FORM_FACTOR_UNKNOWN;
-    }
-
-    r = minor < PA_ELEMENTSOF(table) ? table[minor] : PA_BLUEZ4_FORM_FACTOR_UNKNOWN;
-
-    if (!r)
-        pa_log_debug("Unknown Bluetooth minor device class %u", minor);
-
-    return r;
-}
-
-const char *pa_bluez4_form_factor_to_string(pa_bluez4_form_factor_t ff) {
-    switch (ff) {
-        case PA_BLUEZ4_FORM_FACTOR_UNKNOWN:
-            return "unknown";
-        case PA_BLUEZ4_FORM_FACTOR_HEADSET:
-            return "headset";
-        case PA_BLUEZ4_FORM_FACTOR_HANDSFREE:
-            return "hands-free";
-        case PA_BLUEZ4_FORM_FACTOR_MICROPHONE:
-            return "microphone";
-        case PA_BLUEZ4_FORM_FACTOR_SPEAKER:
-            return "speaker";
-        case PA_BLUEZ4_FORM_FACTOR_HEADPHONE:
-            return "headphone";
-        case PA_BLUEZ4_FORM_FACTOR_PORTABLE:
-            return "portable";
-        case PA_BLUEZ4_FORM_FACTOR_CAR:
-            return "car";
-        case PA_BLUEZ4_FORM_FACTOR_HIFI:
-            return "hifi";
-        case PA_BLUEZ4_FORM_FACTOR_PHONE:
-            return "phone";
-    }
-
-    pa_assert_not_reached();
-}
diff --git a/src/modules/bluetooth/bluez4-util.h b/src/modules/bluetooth/bluez4-util.h
deleted file mode 100644
index f4b5ca3..0000000
--- a/src/modules/bluetooth/bluez4-util.h
+++ /dev/null
@@ -1,160 +0,0 @@
-#ifndef foobluez4utilhfoo
-#define foobluez4utilhfoo
-
-/***
-  This file is part of PulseAudio.
-
-  Copyright 2008-2013 João Paulo Rechi Vita
-
-  PulseAudio is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License as
-  published by the Free Software Foundation; either version 2.1 of the
-  License, or (at your option) any later version.
-
-  PulseAudio is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
-***/
-
-#include <dbus/dbus.h>
-
-#include <pulsecore/llist.h>
-#include <pulsecore/macro.h>
-
-#define PA_BLUEZ4_ERROR_NOT_SUPPORTED "org.bluez.Error.NotSupported"
-
-#define PA_BLUEZ4_UUID_A2DP_SOURCE "0000110a-0000-1000-8000-00805f9b34fb"
-#define PA_BLUEZ4_UUID_A2DP_SINK   "0000110b-0000-1000-8000-00805f9b34fb"
-#define PA_BLUEZ4_UUID_HSP_HS      "00001108-0000-1000-8000-00805f9b34fb"
-#define PA_BLUEZ4_UUID_HSP_AG      "00001112-0000-1000-8000-00805f9b34fb"
-#define PA_BLUEZ4_UUID_HFP_HF      "0000111e-0000-1000-8000-00805f9b34fb"
-#define PA_BLUEZ4_UUID_HFP_AG      "0000111f-0000-1000-8000-00805f9b34fb"
-
-#define HSP_MAX_GAIN 15
-
-typedef struct pa_bluez4_device pa_bluez4_device;
-typedef struct pa_bluez4_discovery pa_bluez4_discovery;
-typedef struct pa_bluez4_transport pa_bluez4_transport;
-
-struct userdata;
-
-typedef enum pa_bluez4_profile {
-    PA_BLUEZ4_PROFILE_A2DP_SINK,
-    PA_BLUEZ4_PROFILE_A2DP_SOURCE,
-    PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT,
-    PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY,
-    PA_BLUEZ4_PROFILE_OFF
-} pa_bluez4_profile_t;
-
-#define PA_BLUEZ4_PROFILE_COUNT PA_BLUEZ4_PROFILE_OFF
-
-struct pa_bluez4_hook_uuid_data {
-    pa_bluez4_device *device;
-    const char *uuid;
-};
-
-/* Hook data: pa_bluez4_discovery pointer. */
-typedef enum pa_bluez4_hook {
-    PA_BLUEZ4_HOOK_DEVICE_CONNECTION_CHANGED, /* Call data: pa_bluez4_device */
-    PA_BLUEZ4_HOOK_DEVICE_UUID_ADDED, /* Call data: pa_bluez4_hook_uuid_data */
-    PA_BLUEZ4_HOOK_TRANSPORT_STATE_CHANGED, /* Call data: pa_bluez4_transport */
-    PA_BLUEZ4_HOOK_TRANSPORT_NREC_CHANGED, /* Call data: pa_bluez4_transport */
-    PA_BLUEZ4_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED, /* Call data: pa_bluez4_transport */
-    PA_BLUEZ4_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED, /* Call data: pa_bluez4_transport */
-    PA_BLUEZ4_HOOK_MAX
-} pa_bluez4_hook_t;
-
-typedef enum pa_bluez4_transport_state {
-    PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED,
-    PA_BLUEZ4_TRANSPORT_STATE_IDLE, /* Connected but not playing */
-    PA_BLUEZ4_TRANSPORT_STATE_PLAYING
-} pa_bluez4_transport_state_t;
-
-struct pa_bluez4_transport {
-    pa_bluez4_device *device;
-    char *owner;
-    char *path;
-    pa_bluez4_profile_t profile;
-    uint8_t codec;
-    uint8_t *config;
-    int config_size;
-
-    pa_bluez4_transport_state_t state;
-    bool nrec;
-    uint16_t microphone_gain; /* Used for HSP/HFP */
-    uint16_t speaker_gain; /* Used for HSP/HFP */
-};
-
-/* This enum is shared among Audio, Headset, AudioSink, and AudioSource, although not all values are acceptable in all profiles */
-typedef enum pa_bluez4_audio_state {
-    PA_BLUEZ4_AUDIO_STATE_INVALID = -1,
-    PA_BLUEZ4_AUDIO_STATE_DISCONNECTED,
-    PA_BLUEZ4_AUDIO_STATE_CONNECTING,
-    PA_BLUEZ4_AUDIO_STATE_CONNECTED,
-    PA_BLUEZ4_AUDIO_STATE_PLAYING
-} pa_bluez4_audio_state_t;
-
-struct pa_bluez4_device {
-    pa_bluez4_discovery *discovery;
-    bool dead;
-
-    int device_info_valid;      /* 0: no results yet; 1: good results; -1: bad results ... */
-
-    /* Device information */
-    char *name;
-    char *path;
-    pa_bluez4_transport *transports[PA_BLUEZ4_PROFILE_COUNT];
-    int paired;
-    char *alias;
-    char *address;
-    int class;
-    pa_hashmap *uuids; /* char* -> char* (hashmap-as-a-set) */
-    int trusted;
-
-    /* Audio state */
-    pa_bluez4_audio_state_t audio_state;
-
-    /* AudioSink, AudioSource, Headset and HandsfreeGateway states */
-    pa_bluez4_audio_state_t profile_state[PA_BLUEZ4_PROFILE_COUNT];
-};
-
-pa_bluez4_discovery* pa_bluez4_discovery_get(pa_core *core);
-pa_bluez4_discovery* pa_bluez4_discovery_ref(pa_bluez4_discovery *y);
-void pa_bluez4_discovery_unref(pa_bluez4_discovery *d);
-
-pa_bluez4_device* pa_bluez4_discovery_get_by_path(pa_bluez4_discovery *d, const char* path);
-pa_bluez4_device* pa_bluez4_discovery_get_by_address(pa_bluez4_discovery *d, const char* address);
-
-bool pa_bluez4_device_any_audio_connected(const pa_bluez4_device *d);
-
-int pa_bluez4_transport_acquire(pa_bluez4_transport *t, bool optional, size_t *imtu, size_t *omtu);
-void pa_bluez4_transport_release(pa_bluez4_transport *t);
-
-void pa_bluez4_transport_set_microphone_gain(pa_bluez4_transport *t, uint16_t value);
-void pa_bluez4_transport_set_speaker_gain(pa_bluez4_transport *t, uint16_t value);
-
-pa_hook* pa_bluez4_discovery_hook(pa_bluez4_discovery *y, pa_bluez4_hook_t hook);
-
-typedef enum pa_bluez4_form_factor {
-    PA_BLUEZ4_FORM_FACTOR_UNKNOWN,
-    PA_BLUEZ4_FORM_FACTOR_HEADSET,
-    PA_BLUEZ4_FORM_FACTOR_HANDSFREE,
-    PA_BLUEZ4_FORM_FACTOR_MICROPHONE,
-    PA_BLUEZ4_FORM_FACTOR_SPEAKER,
-    PA_BLUEZ4_FORM_FACTOR_HEADPHONE,
-    PA_BLUEZ4_FORM_FACTOR_PORTABLE,
-    PA_BLUEZ4_FORM_FACTOR_CAR,
-    PA_BLUEZ4_FORM_FACTOR_HIFI,
-    PA_BLUEZ4_FORM_FACTOR_PHONE,
-} pa_bluez4_form_factor_t;
-
-pa_bluez4_form_factor_t pa_bluez4_get_form_factor(uint32_t class);
-const char *pa_bluez4_form_factor_to_string(pa_bluez4_form_factor_t ff);
-
-const char *pa_bluez4_profile_to_string(pa_bluez4_profile_t profile);
-
-#endif
diff --git a/src/modules/bluetooth/bluez5-util.c b/src/modules/bluetooth/bluez5-util.c
index 2d83373..d95c9c1 100644
--- a/src/modules/bluetooth/bluez5-util.c
+++ b/src/modules/bluetooth/bluez5-util.c
@@ -2,6 +2,7 @@
   This file is part of PulseAudio.
 
   Copyright 2008-2013 João Paulo Rechi Vita
+  Copyrigth 2018-2019 Pali Rohár <pali.rohar@gmail.com>
 
   PulseAudio is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
@@ -33,6 +34,7 @@
 #include <pulsecore/refcnt.h>
 #include <pulsecore/shared.h>
 
+#include "a2dp-codec-util.h"
 #include "a2dp-codecs.h"
 
 #include "bluez5-util.h"
@@ -560,6 +562,8 @@ static void device_free(pa_bluetooth_device *d) {
 
     device_stop_waiting_for_profiles(d);
 
+    pa_hook_fire(&d->discovery->hooks[PA_BLUETOOTH_HOOK_DEVICE_UNLINK], d);
+
     for (i = 0; i < PA_BLUETOOTH_PROFILE_COUNT; i++) {
         pa_bluetooth_transport *t;
 
@@ -885,13 +889,19 @@ finish:
     pa_xfree(endpoint);
 }
 
-static void register_endpoint(pa_bluetooth_discovery *y, const char *path, const char *endpoint, const char *uuid) {
+static void register_endpoint(pa_bluetooth_discovery *y, const pa_a2dp_codec *a2dp_codec, const char *path, const char *endpoint, const char *uuid) {
     DBusMessage *m;
     DBusMessageIter i, d;
-    uint8_t codec = 0;
+    uint8_t capabilities[MAX_A2DP_CAPS_SIZE];
+    size_t capabilities_size;
+    uint8_t codec_id;
 
     pa_log_debug("Registering %s on adapter %s", endpoint, path);
 
+    codec_id = a2dp_codec->id.codec_id;
+    capabilities_size = a2dp_codec->fill_capabilities(capabilities);
+    pa_assert(capabilities_size != 0);
+
     pa_assert_se(m = dbus_message_new_method_call(BLUEZ_SERVICE, path, BLUEZ_MEDIA_INTERFACE, "RegisterEndpoint"));
 
     dbus_message_iter_init_append(m, &i);
@@ -899,23 +909,8 @@ static void register_endpoint(pa_bluetooth_discovery *y, const char *path, const
     dbus_message_iter_open_container(&i, DBUS_TYPE_ARRAY, DBUS_DICT_ENTRY_BEGIN_CHAR_AS_STRING DBUS_TYPE_STRING_AS_STRING
                                          DBUS_TYPE_VARIANT_AS_STRING DBUS_DICT_ENTRY_END_CHAR_AS_STRING, &d);
     pa_dbus_append_basic_variant_dict_entry(&d, "UUID", DBUS_TYPE_STRING, &uuid);
-    pa_dbus_append_basic_variant_dict_entry(&d, "Codec", DBUS_TYPE_BYTE, &codec);
-
-    if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE) || pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK)) {
-        a2dp_sbc_t capabilities;
-
-        capabilities.channel_mode = SBC_CHANNEL_MODE_MONO | SBC_CHANNEL_MODE_DUAL_CHANNEL | SBC_CHANNEL_MODE_STEREO |
-                                    SBC_CHANNEL_MODE_JOINT_STEREO;
-        capabilities.frequency = SBC_SAMPLING_FREQ_16000 | SBC_SAMPLING_FREQ_32000 | SBC_SAMPLING_FREQ_44100 |
-                                 SBC_SAMPLING_FREQ_48000;
-        capabilities.allocation_method = SBC_ALLOCATION_SNR | SBC_ALLOCATION_LOUDNESS;
-        capabilities.subbands = SBC_SUBBANDS_4 | SBC_SUBBANDS_8;
-        capabilities.block_length = SBC_BLOCK_LENGTH_4 | SBC_BLOCK_LENGTH_8 | SBC_BLOCK_LENGTH_12 | SBC_BLOCK_LENGTH_16;
-        capabilities.min_bitpool = MIN_BITPOOL;
-        capabilities.max_bitpool = MAX_BITPOOL;
-
-        pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capabilities, sizeof(capabilities));
-    }
+    pa_dbus_append_basic_variant_dict_entry(&d, "Codec", DBUS_TYPE_BYTE, &codec_id);
+    pa_dbus_append_basic_array_variant_dict_entry(&d, "Capabilities", DBUS_TYPE_BYTE, &capabilities, capabilities_size);
 
     dbus_message_iter_close_container(&i, &d);
 
@@ -950,6 +945,7 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
 
         if (pa_streq(interface, BLUEZ_ADAPTER_INTERFACE)) {
             pa_bluetooth_adapter *a;
+            unsigned a2dp_codec_i;
 
             if ((a = pa_hashmap_get(y->adapters, path))) {
                 pa_log_error("Found duplicated D-Bus path for adapter %s", path);
@@ -964,8 +960,20 @@ static void parse_interfaces_and_properties(pa_bluetooth_discovery *y, DBusMessa
             if (!a->valid)
                 return;
 
-            register_endpoint(y, path, A2DP_SOURCE_ENDPOINT, PA_BLUETOOTH_UUID_A2DP_SOURCE);
-            register_endpoint(y, path, A2DP_SINK_ENDPOINT, PA_BLUETOOTH_UUID_A2DP_SINK);
+            /* Order is important. bluez prefers endpoints registered earlier.
+             * And codec with higher number has higher priority. So iterate in reverse order. */
+            for (a2dp_codec_i = pa_bluetooth_a2dp_codec_count(); a2dp_codec_i > 0; a2dp_codec_i--) {
+                const pa_a2dp_codec *a2dp_codec = pa_bluetooth_a2dp_codec_iter(a2dp_codec_i-1);
+                char *endpoint;
+
+                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
+                register_endpoint(y, a2dp_codec, path, endpoint, PA_BLUETOOTH_UUID_A2DP_SINK);
+                pa_xfree(endpoint);
+
+                endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
+                register_endpoint(y, a2dp_codec, path, endpoint, PA_BLUETOOTH_UUID_A2DP_SOURCE);
+                pa_xfree(endpoint);
+            }
 
         } else if (pa_streq(interface, BLUEZ_DEVICE_INTERFACE)) {
 
@@ -1257,48 +1265,6 @@ fail:
     return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 }
 
-static uint8_t a2dp_default_bitpool(uint8_t freq, uint8_t mode) {
-    /* These bitpool values were chosen based on the A2DP spec recommendation */
-    switch (freq) {
-        case SBC_SAMPLING_FREQ_16000:
-        case SBC_SAMPLING_FREQ_32000:
-            return 53;
-
-        case SBC_SAMPLING_FREQ_44100:
-
-            switch (mode) {
-                case SBC_CHANNEL_MODE_MONO:
-                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                    return 31;
-
-                case SBC_CHANNEL_MODE_STEREO:
-                case SBC_CHANNEL_MODE_JOINT_STEREO:
-                    return 53;
-            }
-
-            pa_log_warn("Invalid channel mode %u", mode);
-            return 53;
-
-        case SBC_SAMPLING_FREQ_48000:
-
-            switch (mode) {
-                case SBC_CHANNEL_MODE_MONO:
-                case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                    return 29;
-
-                case SBC_CHANNEL_MODE_STEREO:
-                case SBC_CHANNEL_MODE_JOINT_STEREO:
-                    return 51;
-            }
-
-            pa_log_warn("Invalid channel mode %u", mode);
-            return 51;
-    }
-
-    pa_log_warn("Invalid sampling freq %u", freq);
-    return 53;
-}
-
 const char *pa_bluetooth_profile_to_string(pa_bluetooth_profile_t profile) {
     switch(profile) {
         case PA_BLUETOOTH_PROFILE_A2DP_SINK:
@@ -1316,10 +1282,24 @@ const char *pa_bluetooth_profile_to_string(pa_bluetooth_profile_t profile) {
     return NULL;
 }
 
+static const pa_a2dp_codec *a2dp_endpoint_to_a2dp_codec(const char *endpoint) {
+    const char *codec_name;
+
+    if (pa_startswith(endpoint, A2DP_SINK_ENDPOINT "/"))
+        codec_name = endpoint + strlen(A2DP_SINK_ENDPOINT "/");
+    else if (pa_startswith(endpoint, A2DP_SOURCE_ENDPOINT "/"))
+        codec_name = endpoint + strlen(A2DP_SOURCE_ENDPOINT "/");
+    else
+        return NULL;
+
+    return pa_bluetooth_get_a2dp_codec(codec_name);
+}
+
 static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage *m, void *userdata) {
     pa_bluetooth_discovery *y = userdata;
     pa_bluetooth_device *d;
     pa_bluetooth_transport *t;
+    const pa_a2dp_codec *a2dp_codec = NULL;
     const char *sender, *path, *endpoint_path, *dev_path = NULL, *uuid = NULL;
     const uint8_t *config = NULL;
     int size = 0;
@@ -1345,6 +1325,8 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
     if (dbus_message_iter_get_arg_type(&props) != DBUS_TYPE_DICT_ENTRY)
         goto fail;
 
+    endpoint_path = dbus_message_get_path(m);
+
     /* Read transport properties */
     while (dbus_message_iter_get_arg_type(&props) == DBUS_TYPE_DICT_ENTRY) {
         const char *key;
@@ -1367,16 +1349,13 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
 
             dbus_message_iter_get_basic(&value, &uuid);
 
-            endpoint_path = dbus_message_get_path(m);
-            if (pa_streq(endpoint_path, A2DP_SOURCE_ENDPOINT)) {
-                if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE))
-                    p = PA_BLUETOOTH_PROFILE_A2DP_SINK;
-            } else if (pa_streq(endpoint_path, A2DP_SINK_ENDPOINT)) {
-                if (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK))
-                    p = PA_BLUETOOTH_PROFILE_A2DP_SOURCE;
-            }
+            if (pa_startswith(endpoint_path, A2DP_SINK_ENDPOINT "/"))
+                p = PA_BLUETOOTH_PROFILE_A2DP_SOURCE;
+            else if (pa_startswith(endpoint_path, A2DP_SOURCE_ENDPOINT "/"))
+                p = PA_BLUETOOTH_PROFILE_A2DP_SINK;
 
-            if (p == PA_BLUETOOTH_PROFILE_OFF) {
+            if ((pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SOURCE) && p != PA_BLUETOOTH_PROFILE_A2DP_SINK) ||
+                (pa_streq(uuid, PA_BLUETOOTH_UUID_A2DP_SINK) && p != PA_BLUETOOTH_PROFILE_A2DP_SOURCE)) {
                 pa_log_error("UUID %s of transport %s incompatible with endpoint %s", uuid, path, endpoint_path);
                 goto fail;
             }
@@ -1389,7 +1368,6 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
             dbus_message_iter_get_basic(&value, &dev_path);
         } else if (pa_streq(key, "Configuration")) {
             DBusMessageIter array;
-            a2dp_sbc_t *c;
 
             if (var != DBUS_TYPE_ARRAY) {
                 pa_log_error("Property %s of wrong type %c", key, (char)var);
@@ -1404,45 +1382,20 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
             }
 
             dbus_message_iter_get_fixed_array(&array, &config, &size);
-            if (size != sizeof(a2dp_sbc_t)) {
-                pa_log_error("Configuration array of invalid size");
-                goto fail;
-            }
-
-            c = (a2dp_sbc_t *) config;
-
-            if (c->frequency != SBC_SAMPLING_FREQ_16000 && c->frequency != SBC_SAMPLING_FREQ_32000 &&
-                c->frequency != SBC_SAMPLING_FREQ_44100 && c->frequency != SBC_SAMPLING_FREQ_48000) {
-                pa_log_error("Invalid sampling frequency in configuration");
-                goto fail;
-            }
-
-            if (c->channel_mode != SBC_CHANNEL_MODE_MONO && c->channel_mode != SBC_CHANNEL_MODE_DUAL_CHANNEL &&
-                c->channel_mode != SBC_CHANNEL_MODE_STEREO && c->channel_mode != SBC_CHANNEL_MODE_JOINT_STEREO) {
-                pa_log_error("Invalid channel mode in configuration");
-                goto fail;
-            }
-
-            if (c->allocation_method != SBC_ALLOCATION_SNR && c->allocation_method != SBC_ALLOCATION_LOUDNESS) {
-                pa_log_error("Invalid allocation method in configuration");
-                goto fail;
-            }
 
-            if (c->subbands != SBC_SUBBANDS_4 && c->subbands != SBC_SUBBANDS_8) {
-                pa_log_error("Invalid SBC subbands in configuration");
-                goto fail;
-            }
+            a2dp_codec = a2dp_endpoint_to_a2dp_codec(endpoint_path);
+            pa_assert(a2dp_codec);
 
-            if (c->block_length != SBC_BLOCK_LENGTH_4 && c->block_length != SBC_BLOCK_LENGTH_8 &&
-                c->block_length != SBC_BLOCK_LENGTH_12 && c->block_length != SBC_BLOCK_LENGTH_16) {
-                pa_log_error("Invalid block length in configuration");
+            if (!a2dp_codec->is_configuration_valid(config, size))
                 goto fail;
-            }
         }
 
         dbus_message_iter_next(&props);
     }
 
+    if (!a2dp_codec)
+        goto fail2;
+
     if ((d = pa_hashmap_get(y->devices, dev_path))) {
         if (!d->valid) {
             pa_log_error("Information about device %s is invalid", dev_path);
@@ -1466,6 +1419,7 @@ static DBusMessage *endpoint_set_configuration(DBusConnection *conn, DBusMessage
     dbus_message_unref(r);
 
     t = pa_bluetooth_transport_new(d, sender, path, p, config, size);
+    t->a2dp_codec = a2dp_codec;
     t->acquire = bluez5_transport_acquire_cb;
     t->release = bluez5_transport_release_cb;
     pa_bluetooth_transport_put(t);
@@ -1484,21 +1438,17 @@ fail2:
 
 static DBusMessage *endpoint_select_configuration(DBusConnection *conn, DBusMessage *m, void *userdata) {
     pa_bluetooth_discovery *y = userdata;
-    a2dp_sbc_t *cap, config;
-    uint8_t *pconf = (uint8_t *) &config;
-    int i, size;
+    const char *endpoint_path;
+    uint8_t *cap;
+    int size;
+    const pa_a2dp_codec *a2dp_codec;
+    uint8_t config[MAX_A2DP_CAPS_SIZE];
+    uint8_t *config_ptr = config;
+    size_t config_size;
     DBusMessage *r;
     DBusError err;
 
-    static const struct {
-        uint32_t rate;
-        uint8_t cap;
-    } freq_table[] = {
-        { 16000U, SBC_SAMPLING_FREQ_16000 },
-        { 32000U, SBC_SAMPLING_FREQ_32000 },
-        { 44100U, SBC_SAMPLING_FREQ_44100 },
-        { 48000U, SBC_SAMPLING_FREQ_48000 }
-    };
+    endpoint_path = dbus_message_get_path(m);
 
     dbus_error_init(&err);
 
@@ -1508,101 +1458,15 @@ static DBusMessage *endpoint_select_configuration(DBusConnection *conn, DBusMess
         goto fail;
     }
 
-    if (size != sizeof(config)) {
-        pa_log_error("Capabilities array has invalid size");
-        goto fail;
-    }
-
-    pa_zero(config);
-
-    /* Find the lowest freq that is at least as high as the requested sampling rate */
-    for (i = 0; (unsigned) i < PA_ELEMENTSOF(freq_table); i++)
-        if (freq_table[i].rate >= y->core->default_sample_spec.rate && (cap->frequency & freq_table[i].cap)) {
-            config.frequency = freq_table[i].cap;
-            break;
-        }
+    a2dp_codec = a2dp_endpoint_to_a2dp_codec(endpoint_path);
+    pa_assert(a2dp_codec);
 
-    if ((unsigned) i == PA_ELEMENTSOF(freq_table)) {
-        for (--i; i >= 0; i--) {
-            if (cap->frequency & freq_table[i].cap) {
-                config.frequency = freq_table[i].cap;
-                break;
-            }
-        }
-
-        if (i < 0) {
-            pa_log_error("Not suitable sample rate");
-            goto fail;
-        }
-    }
-
-    pa_assert((unsigned) i < PA_ELEMENTSOF(freq_table));
-
-    if (y->core->default_sample_spec.channels <= 1) {
-        if (cap->channel_mode & SBC_CHANNEL_MODE_MONO)
-            config.channel_mode = SBC_CHANNEL_MODE_MONO;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
-            config.channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_STEREO)
-            config.channel_mode = SBC_CHANNEL_MODE_STEREO;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
-            config.channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
-        else {
-            pa_log_error("No supported channel modes");
-            goto fail;
-        }
-    }
-
-    if (y->core->default_sample_spec.channels >= 2) {
-        if (cap->channel_mode & SBC_CHANNEL_MODE_JOINT_STEREO)
-            config.channel_mode = SBC_CHANNEL_MODE_JOINT_STEREO;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_STEREO)
-            config.channel_mode = SBC_CHANNEL_MODE_STEREO;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_DUAL_CHANNEL)
-            config.channel_mode = SBC_CHANNEL_MODE_DUAL_CHANNEL;
-        else if (cap->channel_mode & SBC_CHANNEL_MODE_MONO)
-            config.channel_mode = SBC_CHANNEL_MODE_MONO;
-        else {
-            pa_log_error("No supported channel modes");
-            goto fail;
-        }
-    }
-
-    if (cap->block_length & SBC_BLOCK_LENGTH_16)
-        config.block_length = SBC_BLOCK_LENGTH_16;
-    else if (cap->block_length & SBC_BLOCK_LENGTH_12)
-        config.block_length = SBC_BLOCK_LENGTH_12;
-    else if (cap->block_length & SBC_BLOCK_LENGTH_8)
-        config.block_length = SBC_BLOCK_LENGTH_8;
-    else if (cap->block_length & SBC_BLOCK_LENGTH_4)
-        config.block_length = SBC_BLOCK_LENGTH_4;
-    else {
-        pa_log_error("No supported block lengths");
-        goto fail;
-    }
-
-    if (cap->subbands & SBC_SUBBANDS_8)
-        config.subbands = SBC_SUBBANDS_8;
-    else if (cap->subbands & SBC_SUBBANDS_4)
-        config.subbands = SBC_SUBBANDS_4;
-    else {
-        pa_log_error("No supported subbands");
-        goto fail;
-    }
-
-    if (cap->allocation_method & SBC_ALLOCATION_LOUDNESS)
-        config.allocation_method = SBC_ALLOCATION_LOUDNESS;
-    else if (cap->allocation_method & SBC_ALLOCATION_SNR)
-        config.allocation_method = SBC_ALLOCATION_SNR;
-
-    config.min_bitpool = (uint8_t) PA_MAX(MIN_BITPOOL, cap->min_bitpool);
-    config.max_bitpool = (uint8_t) PA_MIN(a2dp_default_bitpool(config.frequency, config.channel_mode), cap->max_bitpool);
-
-    if (config.min_bitpool > config.max_bitpool)
+    config_size = a2dp_codec->fill_preferred_configuration(&y->core->default_sample_spec, cap, size, config);
+    if (config_size == 0)
         goto fail;
 
     pa_assert_se(r = dbus_message_new_method_return(m));
-    pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &pconf, size, DBUS_TYPE_INVALID));
+    pa_assert_se(dbus_message_append_args(r, DBUS_TYPE_ARRAY, DBUS_TYPE_BYTE, &config_ptr, config_size, DBUS_TYPE_INVALID));
 
     return r;
 
@@ -1677,7 +1541,7 @@ static DBusHandlerResult endpoint_handler(DBusConnection *c, DBusMessage *m, voi
 
     pa_log_debug("dbus: path=%s, interface=%s, member=%s", path, interface, member);
 
-    if (!pa_streq(path, A2DP_SOURCE_ENDPOINT) && !pa_streq(path, A2DP_SINK_ENDPOINT))
+    if (!a2dp_endpoint_to_a2dp_codec(path))
         return DBUS_HANDLER_RESULT_NOT_YET_HANDLED;
 
     if (dbus_message_is_method_call(m, "org.freedesktop.DBus.Introspectable", "Introspect")) {
@@ -1705,49 +1569,32 @@ static DBusHandlerResult endpoint_handler(DBusConnection *c, DBusMessage *m, voi
     return DBUS_HANDLER_RESULT_HANDLED;
 }
 
-static void endpoint_init(pa_bluetooth_discovery *y, pa_bluetooth_profile_t profile) {
+static void endpoint_init(pa_bluetooth_discovery *y, const char *endpoint) {
     static const DBusObjectPathVTable vtable_endpoint = {
         .message_function = endpoint_handler,
     };
 
     pa_assert(y);
+    pa_assert(endpoint);
 
-    switch(profile) {
-        case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-            pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(y->connection), A2DP_SOURCE_ENDPOINT,
-                                                              &vtable_endpoint, y));
-            break;
-        case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(y->connection), A2DP_SINK_ENDPOINT,
-                                                              &vtable_endpoint, y));
-            break;
-        default:
-            pa_assert_not_reached();
-            break;
-    }
+    pa_assert_se(dbus_connection_register_object_path(pa_dbus_connection_get(y->connection), endpoint,
+                                                      &vtable_endpoint, y));
 }
 
-static void endpoint_done(pa_bluetooth_discovery *y, pa_bluetooth_profile_t profile) {
+static void endpoint_done(pa_bluetooth_discovery *y, const char *endpoint) {
     pa_assert(y);
+    pa_assert(endpoint);
 
-    switch(profile) {
-        case PA_BLUETOOTH_PROFILE_A2DP_SINK:
-            dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), A2DP_SOURCE_ENDPOINT);
-            break;
-        case PA_BLUETOOTH_PROFILE_A2DP_SOURCE:
-            dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), A2DP_SINK_ENDPOINT);
-            break;
-        default:
-            pa_assert_not_reached();
-            break;
-    }
+    dbus_connection_unregister_object_path(pa_dbus_connection_get(y->connection), endpoint);
 }
 
 pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backend) {
     pa_bluetooth_discovery *y;
     DBusError err;
     DBusConnection *conn;
-    unsigned i;
+    unsigned i, count;
+    const pa_a2dp_codec *a2dp_codec;
+    char *endpoint;
 
     y = pa_xnew0(pa_bluetooth_discovery, 1);
     PA_REFCNT_INIT(y);
@@ -1799,8 +1646,18 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_get(pa_core *c, int headset_backe
     }
     y->matches_added = true;
 
-    endpoint_init(y, PA_BLUETOOTH_PROFILE_A2DP_SINK);
-    endpoint_init(y, PA_BLUETOOTH_PROFILE_A2DP_SOURCE);
+    count = pa_bluetooth_a2dp_codec_count();
+    for (i = 0; i < count; i++) {
+        a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
+
+        endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
+        endpoint_init(y, endpoint);
+        pa_xfree(endpoint);
+
+        endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
+        endpoint_init(y, endpoint);
+        pa_xfree(endpoint);
+    }
 
     get_managed_objects(y);
 
@@ -1823,6 +1680,10 @@ pa_bluetooth_discovery* pa_bluetooth_discovery_ref(pa_bluetooth_discovery *y) {
 }
 
 void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y) {
+    unsigned i, count;
+    const pa_a2dp_codec *a2dp_codec;
+    char *endpoint;
+
     pa_assert(y);
     pa_assert(PA_REFCNT_VALUE(y) > 0);
 
@@ -1868,8 +1729,18 @@ void pa_bluetooth_discovery_unref(pa_bluetooth_discovery *y) {
         if (y->filter_added)
             dbus_connection_remove_filter(pa_dbus_connection_get(y->connection), filter_cb, y);
 
-        endpoint_done(y, PA_BLUETOOTH_PROFILE_A2DP_SINK);
-        endpoint_done(y, PA_BLUETOOTH_PROFILE_A2DP_SOURCE);
+        count = pa_bluetooth_a2dp_codec_count();
+        for (i = 0; i < count; i++) {
+            a2dp_codec = pa_bluetooth_a2dp_codec_iter(i);
+
+            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SINK_ENDPOINT, a2dp_codec->name);
+            endpoint_done(y, endpoint);
+            pa_xfree(endpoint);
+
+            endpoint = pa_sprintf_malloc("%s/%s", A2DP_SOURCE_ENDPOINT, a2dp_codec->name);
+            endpoint_done(y, endpoint);
+            pa_xfree(endpoint);
+        }
 
         pa_dbus_connection_unref(y->connection);
     }
diff --git a/src/modules/bluetooth/bluez5-util.h b/src/modules/bluetooth/bluez5-util.h
index ad30708..ff172e0 100644
--- a/src/modules/bluetooth/bluez5-util.h
+++ b/src/modules/bluetooth/bluez5-util.h
@@ -5,6 +5,7 @@
   This file is part of PulseAudio.
 
   Copyright 2008-2013 João Paulo Rechi Vita
+  Copyrigth 2018-2019 Pali Rohár <pali.rohar@gmail.com>
 
   PulseAudio is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
@@ -22,6 +23,8 @@
 
 #include <pulsecore/core.h>
 
+#include "a2dp-codec-util.h"
+
 #define PA_BLUETOOTH_UUID_A2DP_SOURCE "0000110a-0000-1000-8000-00805f9b34fb"
 #define PA_BLUETOOTH_UUID_A2DP_SINK   "0000110b-0000-1000-8000-00805f9b34fb"
 
@@ -44,6 +47,7 @@ typedef struct pa_bluetooth_backend pa_bluetooth_backend;
 
 typedef enum pa_bluetooth_hook {
     PA_BLUETOOTH_HOOK_DEVICE_CONNECTION_CHANGED,          /* Call data: pa_bluetooth_device */
+    PA_BLUETOOTH_HOOK_DEVICE_UNLINK,                      /* Call data: pa_bluetooth_device */
     PA_BLUETOOTH_HOOK_TRANSPORT_STATE_CHANGED,            /* Call data: pa_bluetooth_transport */
     PA_BLUETOOTH_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED,  /* Call data: pa_bluetooth_transport */
     PA_BLUETOOTH_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED,     /* Call data: pa_bluetooth_transport */
@@ -82,6 +86,8 @@ struct pa_bluetooth_transport {
     uint8_t *config;
     size_t config_size;
 
+    const pa_a2dp_codec *a2dp_codec;
+
     uint16_t microphone_gain;
     uint16_t speaker_gain;
 
diff --git a/src/modules/bluetooth/module-bluetooth-discover.c b/src/modules/bluetooth/module-bluetooth-discover.c
index 49718c0..cf8c7ee 100644
--- a/src/modules/bluetooth/module-bluetooth-discover.c
+++ b/src/modules/bluetooth/module-bluetooth-discover.c
@@ -30,13 +30,12 @@ PA_MODULE_DESCRIPTION("Detect available Bluetooth daemon and load the correspond
 PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(true);
 PA_MODULE_USAGE(
-    "headset=ofono|native|auto (bluez 5 only)"
-    "autodetect_mtu=<boolean> (bluez 5 only)"
+    "headset=ofono|native|auto"
+    "autodetect_mtu=<boolean>"
 );
 
 struct userdata {
     uint32_t bluez5_module_idx;
-    uint32_t bluez4_module_idx;
 };
 
 int pa__init(pa_module* m) {
@@ -47,7 +46,6 @@ int pa__init(pa_module* m) {
 
     m->userdata = u = pa_xnew0(struct userdata, 1);
     u->bluez5_module_idx = PA_INVALID_INDEX;
-    u->bluez4_module_idx = PA_INVALID_INDEX;
 
     if (pa_module_exists("module-bluez5-discover")) {
         pa_module_load(&mm, m->core, "module-bluez5-discover", m->argument);
@@ -55,13 +53,7 @@ int pa__init(pa_module* m) {
             u->bluez5_module_idx = mm->index;
     }
 
-    if (pa_module_exists("module-bluez4-discover")) {
-        pa_module_load(&mm, m->core, "module-bluez4-discover",  NULL);
-        if (mm)
-            u->bluez4_module_idx = mm->index;
-    }
-
-    if (u->bluez5_module_idx == PA_INVALID_INDEX && u->bluez4_module_idx == PA_INVALID_INDEX) {
+    if (u->bluez5_module_idx == PA_INVALID_INDEX) {
         pa_xfree(u);
         return -1;
     }
@@ -80,8 +72,5 @@ void pa__done(pa_module* m) {
     if (u->bluez5_module_idx != PA_INVALID_INDEX)
         pa_module_unload_by_index(m->core, u->bluez5_module_idx, true);
 
-    if (u->bluez4_module_idx != PA_INVALID_INDEX)
-        pa_module_unload_by_index(m->core, u->bluez4_module_idx, true);
-
     pa_xfree(u);
 }
diff --git a/src/modules/bluetooth/module-bluetooth-policy.c b/src/modules/bluetooth/module-bluetooth-policy.c
index a6a812b..0a6d59d 100644
--- a/src/modules/bluetooth/module-bluetooth-policy.c
+++ b/src/modules/bluetooth/module-bluetooth-policy.c
@@ -38,8 +38,7 @@ PA_MODULE_LOAD_ONCE(true);
 PA_MODULE_USAGE(
         "auto_switch=<Switch between hsp and a2dp profile? (0 - never, 1 - media.role=phone, 2 - heuristic> "
         "a2dp_source=<Handle a2dp_source card profile (sink role)?> "
-        "ag=<Handle headset_audio_gateway card profile (headset role)?> "
-        "hfgw=<Handle hfgw card profile (headset role)?> DEPRECATED");
+        "ag=<Handle headset_audio_gateway card profile (headset role)?> ");
 
 static const char* const valid_modargs[] = {
     "auto_switch",
@@ -88,8 +87,7 @@ static pa_hook_result_t source_put_hook_callback(pa_core *c, pa_source *source,
 
     if (u->enable_a2dp_source && pa_streq(s, "a2dp_source"))
         role = "music";
-    /* TODO: remove hfgw when we remove BlueZ 4 support */
-    else if (u->enable_ag && (pa_streq(s, "hfgw") || pa_streq(s, "headset_audio_gateway")))
+    else if (u->enable_ag && pa_streq(s, "headset_audio_gateway"))
         role = "phone";
     else {
         pa_log_debug("Profile %s cannot be selected for loopback", s);
@@ -128,8 +126,7 @@ static pa_hook_result_t sink_put_hook_callback(pa_core *c, pa_sink *sink, void *
     if (!s)
         return PA_HOOK_OK;
 
-    /* TODO: remove hfgw when we remove BlueZ 4 support */
-    if (u->enable_ag && (pa_streq(s, "hfgw") || pa_streq(s, "headset_audio_gateway")))
+    if (u->enable_ag && pa_streq(s, "headset_audio_gateway"))
         role = "phone";
     else {
         pa_log_debug("Profile %s cannot be selected for loopback", s);
@@ -157,10 +154,10 @@ static void card_set_profile(struct userdata *u, pa_card *card, bool revert_to_a
 
         /* Check for correct profile based on revert_to_a2dp */
         if (revert_to_a2dp) {
-            if (!pa_streq(profile->name, "a2dp") && !pa_streq(profile->name, "a2dp_sink"))
+            if (!pa_streq(profile->name, "a2dp_sink"))
                 continue;
         } else {
-            if (!pa_streq(profile->name, "hsp") && !pa_streq(profile->name, "headset_head_unit"))
+            if (!pa_streq(profile->name, "headset_head_unit"))
                 continue;
         }
 
@@ -195,19 +192,19 @@ static void switch_profile(pa_card *card, bool revert_to_a2dp, void *userdata) {
             return;
 
         /* Skip card if does not have active hsp profile */
-        if (!pa_streq(card->active_profile->name, "hsp") && !pa_streq(card->active_profile->name, "headset_head_unit"))
+        if (!pa_streq(card->active_profile->name, "headset_head_unit"))
             return;
 
         /* Skip card if already has active a2dp profile */
-        if (pa_streq(card->active_profile->name, "a2dp") || pa_streq(card->active_profile->name, "a2dp_sink"))
+        if (pa_streq(card->active_profile->name, "a2dp_sink"))
             return;
     } else {
         /* Skip card if does not have active a2dp profile */
-        if (!pa_streq(card->active_profile->name, "a2dp") && !pa_streq(card->active_profile->name, "a2dp_sink"))
+        if (!pa_streq(card->active_profile->name, "a2dp_sink"))
             return;
 
         /* Skip card if already has active hsp profile */
-        if (pa_streq(card->active_profile->name, "hsp") || pa_streq(card->active_profile->name, "headset_head_unit"))
+        if (pa_streq(card->active_profile->name, "headset_head_unit"))
             return;
     }
 
@@ -310,7 +307,6 @@ static pa_hook_result_t card_init_profile_hook_callback(pa_core *c, pa_card *car
 
     /* Ignore card if has already set other initial profile than a2dp */
     if (card->active_profile &&
-        !pa_streq(card->active_profile->name, "a2dp") &&
         !pa_streq(card->active_profile->name, "a2dp_sink"))
         return PA_HOOK_OK;
 
@@ -363,9 +359,7 @@ static pa_hook_result_t profile_available_hook_callback(pa_core *c, pa_card_prof
         return PA_HOOK_OK;
 
     /* Do not automatically switch profiles for headsets, just in case */
-    /* TODO: remove a2dp and hsp when we remove BlueZ 4 support */
-    if (pa_streq(profile->name, "hsp") || pa_streq(profile->name, "a2dp") || pa_streq(profile->name, "a2dp_sink") ||
-        pa_streq(profile->name, "headset_head_unit"))
+    if (pa_streq(profile->name, "a2dp_sink") || pa_streq(profile->name, "headset_head_unit"))
         return PA_HOOK_OK;
 
     is_active_profile = card->active_profile == profile;
@@ -448,10 +442,6 @@ int pa__init(pa_module *m) {
     }
 
     u->enable_ag = true;
-    if (pa_modargs_get_value_boolean(ma, "hfgw", &u->enable_ag) < 0) {
-        pa_log("Failed to parse hfgw argument.");
-        goto fail;
-    }
     if (pa_modargs_get_value_boolean(ma, "ag", &u->enable_ag) < 0) {
         pa_log("Failed to parse ag argument.");
         goto fail;
diff --git a/src/modules/bluetooth/module-bluez4-device.c b/src/modules/bluetooth/module-bluez4-device.c
deleted file mode 100644
index 79d75c1..0000000
--- a/src/modules/bluetooth/module-bluez4-device.c
+++ /dev/null
@@ -1,2664 +0,0 @@
-/***
-  This file is part of PulseAudio.
-
-  Copyright 2008-2013 João Paulo Rechi Vita
-  Copyright 2011-2013 BMW Car IT GmbH.
-
-  PulseAudio is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License as
-  published by the Free Software Foundation; either version 2.1 of the
-  License, or (at your option) any later version.
-
-  PulseAudio is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
-***/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <string.h>
-#include <errno.h>
-#include <math.h>
-#include <linux/sockios.h>
-#include <arpa/inet.h>
-
-#include <pulse/rtclock.h>
-#include <pulse/sample.h>
-#include <pulse/timeval.h>
-#include <pulse/utf8.h>
-#include <pulse/xmalloc.h>
-
-#include <pulsecore/i18n.h>
-#include <pulsecore/module.h>
-#include <pulsecore/modargs.h>
-#include <pulsecore/core-rtclock.h>
-#include <pulsecore/core-util.h>
-#include <pulsecore/core-error.h>
-#include <pulsecore/shared.h>
-#include <pulsecore/socket-util.h>
-#include <pulsecore/thread.h>
-#include <pulsecore/thread-mq.h>
-#include <pulsecore/poll.h>
-#include <pulsecore/rtpoll.h>
-#include <pulsecore/time-smoother.h>
-#include <pulsecore/namereg.h>
-
-#include <sbc/sbc.h>
-
-#include "a2dp-codecs.h"
-#include "rtp.h"
-#include "bluez4-util.h"
-
-#define BITPOOL_DEC_LIMIT 32
-#define BITPOOL_DEC_STEP 5
-
-PA_MODULE_AUTHOR("João Paulo Rechi Vita");
-PA_MODULE_DESCRIPTION("BlueZ 4 Bluetooth audio sink and source");
-PA_MODULE_VERSION(PACKAGE_VERSION);
-PA_MODULE_LOAD_ONCE(false);
-PA_MODULE_USAGE(
-        "name=<name for the card/sink/source, to be prefixed> "
-        "card_name=<name for the card> "
-        "card_properties=<properties for the card> "
-        "sink_name=<name for the sink> "
-        "sink_properties=<properties for the sink> "
-        "source_name=<name for the source> "
-        "source_properties=<properties for the source> "
-        "address=<address of the device> "
-        "profile=<a2dp|hsp|hfgw> "
-        "rate=<sample rate> "
-        "channels=<number of channels> "
-        "path=<device object path> "
-        "sco_sink=<SCO over PCM sink name> "
-        "sco_source=<SCO over PCM source name>");
-
-/* TODO: not close fd when entering suspend mode in a2dp */
-
-static const char* const valid_modargs[] = {
-    "name",
-    "card_name",
-    "card_properties",
-    "sink_name",
-    "sink_properties",
-    "source_name",
-    "source_properties",
-    "address",
-    "profile",
-    "rate",
-    "channels",
-    "path",
-    "sco_sink",
-    "sco_source",
-    NULL
-};
-
-struct a2dp_info {
-    sbc_t sbc;                           /* Codec data */
-    bool sbc_initialized;                /* Keep track if the encoder is initialized */
-    size_t codesize, frame_length;       /* SBC Codesize, frame_length. We simply cache those values here */
-
-    void* buffer;                        /* Codec transfer buffer */
-    size_t buffer_size;                  /* Size of the buffer */
-
-    uint16_t seq_num;                    /* Cumulative packet sequence */
-    uint8_t min_bitpool;
-    uint8_t max_bitpool;
-};
-
-struct hsp_info {
-    pa_sink *sco_sink;
-    void (*sco_sink_set_volume)(pa_sink *s);
-    pa_source *sco_source;
-    void (*sco_source_set_volume)(pa_source *s);
-};
-
-struct bluetooth_msg {
-    pa_msgobject parent;
-    pa_card *card;
-};
-
-typedef struct bluetooth_msg bluetooth_msg;
-PA_DEFINE_PRIVATE_CLASS(bluetooth_msg, pa_msgobject);
-#define BLUETOOTH_MSG(o) (bluetooth_msg_cast(o))
-
-struct userdata {
-    pa_core *core;
-    pa_module *module;
-
-    pa_bluez4_device *device;
-    pa_hook_slot *uuid_added_slot;
-    char *address;
-    char *path;
-    pa_bluez4_transport *transport;
-    bool transport_acquired;
-    pa_hook_slot *discovery_slot;
-    pa_hook_slot *sink_state_changed_slot;
-    pa_hook_slot *source_state_changed_slot;
-    pa_hook_slot *transport_state_changed_slot;
-    pa_hook_slot *transport_nrec_changed_slot;
-    pa_hook_slot *transport_microphone_changed_slot;
-    pa_hook_slot *transport_speaker_changed_slot;
-
-    pa_bluez4_discovery *discovery;
-
-    char *output_port_name;
-    char *input_port_name;
-
-    pa_card *card;
-    pa_sink *sink;
-    pa_source *source;
-
-    pa_thread_mq thread_mq;
-    pa_rtpoll *rtpoll;
-    pa_rtpoll_item *rtpoll_item;
-    pa_thread *thread;
-    bluetooth_msg *msg;
-
-    uint64_t read_index, write_index;
-    pa_usec_t started_at;
-    pa_smoother *read_smoother;
-
-    pa_memchunk write_memchunk;
-
-    pa_sample_spec sample_spec, requested_sample_spec;
-
-    int stream_fd;
-
-    size_t read_link_mtu;
-    size_t read_block_size;
-
-    size_t write_link_mtu;
-    size_t write_block_size;
-
-    struct a2dp_info a2dp;
-    struct hsp_info hsp;
-
-    pa_bluez4_profile_t profile;
-
-    pa_modargs *modargs;
-
-    int stream_write_type;
-};
-
-enum {
-    BLUETOOTH_MESSAGE_IO_THREAD_FAILED,
-    BLUETOOTH_MESSAGE_MAX
-};
-
-#define FIXED_LATENCY_PLAYBACK_A2DP (25*PA_USEC_PER_MSEC)
-#define FIXED_LATENCY_RECORD_A2DP (25*PA_USEC_PER_MSEC)
-#define FIXED_LATENCY_PLAYBACK_HSP (125*PA_USEC_PER_MSEC)
-#define FIXED_LATENCY_RECORD_HSP (25*PA_USEC_PER_MSEC)
-
-#define MAX_PLAYBACK_CATCH_UP_USEC (100*PA_USEC_PER_MSEC)
-
-#define USE_SCO_OVER_PCM(u) (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT && (u->hsp.sco_sink && u->hsp.sco_source))
-
-static int init_profile(struct userdata *u);
-
-/* from IO thread */
-static void a2dp_set_bitpool(struct userdata *u, uint8_t bitpool) {
-    struct a2dp_info *a2dp;
-
-    pa_assert(u);
-
-    a2dp = &u->a2dp;
-
-    if (a2dp->sbc.bitpool == bitpool)
-        return;
-
-    if (bitpool > a2dp->max_bitpool)
-        bitpool = a2dp->max_bitpool;
-    else if (bitpool < a2dp->min_bitpool)
-        bitpool = a2dp->min_bitpool;
-
-    a2dp->sbc.bitpool = bitpool;
-
-    a2dp->codesize = sbc_get_codesize(&a2dp->sbc);
-    a2dp->frame_length = sbc_get_frame_length(&a2dp->sbc);
-
-    pa_log_debug("Bitpool has changed to %u", a2dp->sbc.bitpool);
-
-    u->read_block_size =
-        (u->read_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-        / a2dp->frame_length * a2dp->codesize;
-
-    u->write_block_size =
-        (u->write_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-        / a2dp->frame_length * a2dp->codesize;
-
-    pa_sink_set_max_request_within_thread(u->sink, u->write_block_size);
-    pa_sink_set_fixed_latency_within_thread(u->sink,
-            FIXED_LATENCY_PLAYBACK_A2DP + pa_bytes_to_usec(u->write_block_size, &u->sample_spec));
-}
-
-/* from IO thread, except in SCO over PCM */
-static void bt_transport_config_mtu(struct userdata *u) {
-    /* Calculate block sizes */
-    if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        u->read_block_size = u->read_link_mtu;
-        u->write_block_size = u->write_link_mtu;
-    } else {
-        u->read_block_size =
-            (u->read_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-            / u->a2dp.frame_length * u->a2dp.codesize;
-
-        u->write_block_size =
-            (u->write_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-            / u->a2dp.frame_length * u->a2dp.codesize;
-    }
-
-    if (USE_SCO_OVER_PCM(u))
-        return;
-
-    if (u->sink) {
-        pa_sink_set_max_request_within_thread(u->sink, u->write_block_size);
-        pa_sink_set_fixed_latency_within_thread(u->sink,
-                                                (u->profile == PA_BLUEZ4_PROFILE_A2DP_SINK ?
-                                                 FIXED_LATENCY_PLAYBACK_A2DP : FIXED_LATENCY_PLAYBACK_HSP) +
-                                                pa_bytes_to_usec(u->write_block_size, &u->sample_spec));
-    }
-
-    if (u->source)
-        pa_source_set_fixed_latency_within_thread(u->source,
-                                                  (u->profile == PA_BLUEZ4_PROFILE_A2DP_SOURCE ?
-                                                   FIXED_LATENCY_RECORD_A2DP : FIXED_LATENCY_RECORD_HSP) +
-                                                  pa_bytes_to_usec(u->read_block_size, &u->sample_spec));
-}
-
-/* from IO thread, except in SCO over PCM */
-
-static void setup_stream(struct userdata *u) {
-    struct pollfd *pollfd;
-    int one;
-
-    pa_log_info("Transport %s resuming", u->transport->path);
-
-    bt_transport_config_mtu(u);
-
-    pa_make_fd_nonblock(u->stream_fd);
-    pa_make_socket_low_delay(u->stream_fd);
-
-    one = 1;
-    if (setsockopt(u->stream_fd, SOL_SOCKET, SO_TIMESTAMP, &one, sizeof(one)) < 0)
-        pa_log_warn("Failed to enable SO_TIMESTAMP: %s", pa_cstrerror(errno));
-
-    pa_log_debug("Stream properly set up, we're ready to roll!");
-
-    if (u->profile == PA_BLUEZ4_PROFILE_A2DP_SINK)
-        a2dp_set_bitpool(u, u->a2dp.max_bitpool);
-
-    u->rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, 1);
-    pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
-    pollfd->fd = u->stream_fd;
-    pollfd->events = pollfd->revents = 0;
-
-    u->read_index = u->write_index = 0;
-    u->started_at = 0;
-
-    if (u->source)
-        u->read_smoother = pa_smoother_new(
-                PA_USEC_PER_SEC,
-                PA_USEC_PER_SEC*2,
-                true,
-                true,
-                10,
-                pa_rtclock_now(),
-                true);
-}
-
-static void teardown_stream(struct userdata *u) {
-    if (u->rtpoll_item) {
-        pa_rtpoll_item_free(u->rtpoll_item);
-        u->rtpoll_item = NULL;
-    }
-
-    if (u->stream_fd >= 0) {
-        pa_close(u->stream_fd);
-        u->stream_fd = -1;
-    }
-
-    if (u->read_smoother) {
-        pa_smoother_free(u->read_smoother);
-        u->read_smoother = NULL;
-    }
-
-    if (u->write_memchunk.memblock) {
-        pa_memblock_unref(u->write_memchunk.memblock);
-        pa_memchunk_reset(&u->write_memchunk);
-    }
-
-    pa_log_debug("Audio stream torn down");
-}
-
-static void bt_transport_release(struct userdata *u) {
-    pa_assert(u->transport);
-
-    /* Ignore if already released */
-    if (!u->transport_acquired)
-        return;
-
-    pa_log_debug("Releasing transport %s", u->transport->path);
-
-    pa_bluez4_transport_release(u->transport);
-
-    u->transport_acquired = false;
-
-    teardown_stream(u);
-}
-
-static int bt_transport_acquire(struct userdata *u, bool optional) {
-    pa_assert(u->transport);
-
-    if (u->transport_acquired)
-        return 0;
-
-    pa_log_debug("Acquiring transport %s", u->transport->path);
-
-    u->stream_fd = pa_bluez4_transport_acquire(u->transport, optional, &u->read_link_mtu, &u->write_link_mtu);
-    if (u->stream_fd < 0) {
-        if (!optional)
-            pa_log("Failed to acquire transport %s", u->transport->path);
-        else
-            pa_log_info("Failed optional acquire of transport %s", u->transport->path);
-
-        return -1;
-    }
-
-    u->transport_acquired = true;
-    pa_log_info("Transport %s acquired: fd %d", u->transport->path, u->stream_fd);
-
-    return 0;
-}
-
-/* Run from IO thread */
-static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
-    struct userdata *u = PA_SINK(o)->userdata;
-
-    pa_assert(u->sink == PA_SINK(o));
-    pa_assert(u->transport);
-
-    switch (code) {
-
-        case PA_SINK_MESSAGE_GET_LATENCY: {
-
-            if (u->read_smoother) {
-                int64_t wi, ri;
-
-                ri = pa_smoother_get(u->read_smoother, pa_rtclock_now());
-                wi = pa_bytes_to_usec(u->write_index + u->write_block_size, &u->sample_spec);
-
-                *((int64_t*) data) = wi - ri;
-            } else {
-                int64_t ri, wi;
-
-                ri = pa_rtclock_now() - u->started_at;
-                wi = pa_bytes_to_usec(u->write_index, &u->sample_spec);
-
-                *((int64_t*) data) = wi - ri;
-            }
-
-            *((int64_t*) data) += u->sink->thread_info.fixed_latency;
-            return 0;
-        }
-    }
-
-    return pa_sink_process_msg(o, code, data, offset, chunk);
-}
-
-/* Called from the IO thread. */
-static int sink_set_state_in_io_thread_cb(pa_sink *s, pa_sink_state_t new_state, pa_suspend_cause_t new_suspend_cause) {
-    struct userdata *u;
-
-    pa_assert(s);
-    pa_assert_se(u = s->userdata);
-
-    switch (new_state) {
-
-        case PA_SINK_SUSPENDED:
-            /* Ignore if transition is PA_SINK_INIT->PA_SINK_SUSPENDED */
-            if (!PA_SINK_IS_OPENED(u->sink->thread_info.state))
-                break;
-
-            /* Stop the device if the source is suspended as well */
-            if (!u->source || u->source->state == PA_SOURCE_SUSPENDED)
-                /* We deliberately ignore whether stopping
-                 * actually worked. Since the stream_fd is
-                 * closed it doesn't really matter */
-                bt_transport_release(u);
-
-            break;
-
-        case PA_SINK_IDLE:
-        case PA_SINK_RUNNING:
-            if (u->sink->thread_info.state != PA_SINK_SUSPENDED)
-                break;
-
-            /* Resume the device if the source was suspended as well */
-            if (!u->source || !PA_SOURCE_IS_OPENED(u->source->thread_info.state)) {
-                if (bt_transport_acquire(u, false) < 0)
-                    return -1;
-                else
-                    setup_stream(u);
-            }
-            break;
-
-        case PA_SINK_UNLINKED:
-        case PA_SINK_INIT:
-        case PA_SINK_INVALID_STATE:
-            break;
-    }
-
-    return 0;
-}
-
-/* Run from IO thread */
-static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t offset, pa_memchunk *chunk) {
-    struct userdata *u = PA_SOURCE(o)->userdata;
-
-    pa_assert(u->source == PA_SOURCE(o));
-    pa_assert(u->transport);
-
-    switch (code) {
-
-        case PA_SOURCE_MESSAGE_GET_LATENCY: {
-            int64_t wi, ri;
-
-            if (u->read_smoother) {
-                wi = pa_smoother_get(u->read_smoother, pa_rtclock_now());
-                ri = pa_bytes_to_usec(u->read_index, &u->sample_spec);
-
-                *((int64_t*) data) = wi - ri + u->source->thread_info.fixed_latency;
-            } else
-                *((int64_t*) data) = 0;
-
-            return 0;
-        }
-
-    }
-
-    return pa_source_process_msg(o, code, data, offset, chunk);
-}
-
-/* Called from the IO thread. */
-static int source_set_state_in_io_thread_cb(pa_source *s, pa_source_state_t new_state, pa_suspend_cause_t new_suspend_cause) {
-    struct userdata *u;
-
-    pa_assert(s);
-    pa_assert_se(u = s->userdata);
-
-    switch (new_state) {
-
-        case PA_SOURCE_SUSPENDED:
-            /* Ignore if transition is PA_SOURCE_INIT->PA_SOURCE_SUSPENDED */
-            if (!PA_SOURCE_IS_OPENED(u->source->thread_info.state))
-                break;
-
-            /* Stop the device if the sink is suspended as well */
-            if (!u->sink || u->sink->state == PA_SINK_SUSPENDED)
-                bt_transport_release(u);
-
-            if (u->read_smoother)
-                pa_smoother_pause(u->read_smoother, pa_rtclock_now());
-            break;
-
-        case PA_SOURCE_IDLE:
-        case PA_SOURCE_RUNNING:
-            if (u->source->thread_info.state != PA_SOURCE_SUSPENDED)
-                break;
-
-            /* Resume the device if the sink was suspended as well */
-            if (!u->sink || !PA_SINK_IS_OPENED(u->sink->thread_info.state)) {
-                if (bt_transport_acquire(u, false) < 0)
-                    return -1;
-                else
-                    setup_stream(u);
-            }
-            /* We don't resume the smoother here. Instead we
-             * wait until the first packet arrives */
-            break;
-
-        case PA_SOURCE_UNLINKED:
-        case PA_SOURCE_INIT:
-        case PA_SOURCE_INVALID_STATE:
-            break;
-    }
-
-    return 0;
-}
-
-/* Called from main thread context */
-static int device_process_msg(pa_msgobject *obj, int code, void *data, int64_t offset, pa_memchunk *chunk) {
-    struct bluetooth_msg *u = BLUETOOTH_MSG(obj);
-
-    switch (code) {
-        case BLUETOOTH_MESSAGE_IO_THREAD_FAILED: {
-            if (u->card->module->unload_requested)
-                break;
-
-            pa_log_debug("Switching the profile to off due to IO thread failure.");
-
-            pa_assert_se(pa_card_set_profile(u->card, pa_hashmap_get(u->card->profiles, "off"), false) >= 0);
-            break;
-        }
-    }
-    return 0;
-}
-
-/* Run from IO thread */
-static int hsp_process_render(struct userdata *u) {
-    int ret = 0;
-
-    pa_assert(u);
-    pa_assert(u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY);
-    pa_assert(u->sink);
-
-    /* First, render some data */
-    if (!u->write_memchunk.memblock)
-        pa_sink_render_full(u->sink, u->write_block_size, &u->write_memchunk);
-
-    pa_assert(u->write_memchunk.length == u->write_block_size);
-
-    for (;;) {
-        ssize_t l;
-        const void *p;
-
-        /* Now write that data to the socket. The socket is of type
-         * SEQPACKET, and we generated the data of the MTU size, so this
-         * should just work. */
-
-        p = (const uint8_t *) pa_memblock_acquire_chunk(&u->write_memchunk);
-        l = pa_write(u->stream_fd, p, u->write_memchunk.length, &u->stream_write_type);
-        pa_memblock_release(u->write_memchunk.memblock);
-
-        pa_assert(l != 0);
-
-        if (l < 0) {
-
-            if (errno == EINTR)
-                /* Retry right away if we got interrupted */
-                continue;
-
-            else if (errno == EAGAIN)
-                /* Hmm, apparently the socket was not writable, give up for now */
-                break;
-
-            pa_log_error("Failed to write data to SCO socket: %s", pa_cstrerror(errno));
-            ret = -1;
-            break;
-        }
-
-        pa_assert((size_t) l <= u->write_memchunk.length);
-
-        if ((size_t) l != u->write_memchunk.length) {
-            pa_log_error("Wrote memory block to socket only partially! %llu written, wanted to write %llu.",
-                        (unsigned long long) l,
-                        (unsigned long long) u->write_memchunk.length);
-            ret = -1;
-            break;
-        }
-
-        u->write_index += (uint64_t) u->write_memchunk.length;
-        pa_memblock_unref(u->write_memchunk.memblock);
-        pa_memchunk_reset(&u->write_memchunk);
-
-        ret = 1;
-        break;
-    }
-
-    return ret;
-}
-
-/* Run from IO thread */
-static int hsp_process_push(struct userdata *u) {
-    int ret = 0;
-    pa_memchunk memchunk;
-
-    pa_assert(u);
-    pa_assert(u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY);
-    pa_assert(u->source);
-    pa_assert(u->read_smoother);
-
-    memchunk.memblock = pa_memblock_new(u->core->mempool, u->read_block_size);
-    memchunk.index = memchunk.length = 0;
-
-    for (;;) {
-        ssize_t l;
-        void *p;
-        struct msghdr m;
-        struct cmsghdr *cm;
-        uint8_t aux[1024];
-        struct iovec iov;
-        bool found_tstamp = false;
-        pa_usec_t tstamp;
-
-        memset(&m, 0, sizeof(m));
-        memset(&aux, 0, sizeof(aux));
-        memset(&iov, 0, sizeof(iov));
-
-        m.msg_iov = &iov;
-        m.msg_iovlen = 1;
-        m.msg_control = aux;
-        m.msg_controllen = sizeof(aux);
-
-        p = pa_memblock_acquire(memchunk.memblock);
-        iov.iov_base = p;
-        iov.iov_len = pa_memblock_get_length(memchunk.memblock);
-        l = recvmsg(u->stream_fd, &m, 0);
-        pa_memblock_release(memchunk.memblock);
-
-        if (l <= 0) {
-
-            if (l < 0 && errno == EINTR)
-                /* Retry right away if we got interrupted */
-                continue;
-
-            else if (l < 0 && errno == EAGAIN)
-                /* Hmm, apparently the socket was not readable, give up for now. */
-                break;
-
-            pa_log_error("Failed to read data from SCO socket: %s", l < 0 ? pa_cstrerror(errno) : "EOF");
-            ret = -1;
-            break;
-        }
-
-        pa_assert((size_t) l <= pa_memblock_get_length(memchunk.memblock));
-
-        /* In some rare occasions, we might receive packets of a very strange
-         * size. This could potentially be possible if the SCO packet was
-         * received partially over-the-air, or more probably due to hardware
-         * issues in our Bluetooth adapter. In these cases, in order to avoid
-         * an assertion failure due to unaligned data, just discard the whole
-         * packet */
-        if (!pa_frame_aligned(l, &u->sample_spec)) {
-            pa_log_warn("SCO packet received of unaligned size: %zu", l);
-            break;
-        }
-
-        memchunk.length = (size_t) l;
-        u->read_index += (uint64_t) l;
-
-        for (cm = CMSG_FIRSTHDR(&m); cm; cm = CMSG_NXTHDR(&m, cm))
-            if (cm->cmsg_level == SOL_SOCKET && cm->cmsg_type == SO_TIMESTAMP) {
-                struct timeval *tv = (struct timeval*) CMSG_DATA(cm);
-                pa_rtclock_from_wallclock(tv);
-                tstamp = pa_timeval_load(tv);
-                found_tstamp = true;
-                break;
-            }
-
-        if (!found_tstamp) {
-            pa_log_warn("Couldn't find SO_TIMESTAMP data in auxiliary recvmsg() data!");
-            tstamp = pa_rtclock_now();
-        }
-
-        pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->sample_spec));
-        pa_smoother_resume(u->read_smoother, tstamp, true);
-
-        pa_source_post(u->source, &memchunk);
-
-        ret = l;
-        break;
-    }
-
-    pa_memblock_unref(memchunk.memblock);
-
-    return ret;
-}
-
-/* Run from IO thread */
-static void a2dp_prepare_buffer(struct userdata *u) {
-    size_t min_buffer_size = PA_MAX(u->read_link_mtu, u->write_link_mtu);
-
-    pa_assert(u);
-
-    if (u->a2dp.buffer_size >= min_buffer_size)
-        return;
-
-    u->a2dp.buffer_size = 2 * min_buffer_size;
-    pa_xfree(u->a2dp.buffer);
-    u->a2dp.buffer = pa_xmalloc(u->a2dp.buffer_size);
-}
-
-/* Run from IO thread */
-static int a2dp_process_render(struct userdata *u) {
-    struct a2dp_info *a2dp;
-    struct rtp_header *header;
-    struct rtp_payload *payload;
-    size_t nbytes;
-    void *d;
-    const void *p;
-    size_t to_write, to_encode;
-    unsigned frame_count;
-    int ret = 0;
-
-    pa_assert(u);
-    pa_assert(u->profile == PA_BLUEZ4_PROFILE_A2DP_SINK);
-    pa_assert(u->sink);
-
-    /* First, render some data */
-    if (!u->write_memchunk.memblock)
-        pa_sink_render_full(u->sink, u->write_block_size, &u->write_memchunk);
-
-    pa_assert(u->write_memchunk.length == u->write_block_size);
-
-    a2dp_prepare_buffer(u);
-
-    a2dp = &u->a2dp;
-    header = a2dp->buffer;
-    payload = (struct rtp_payload*) ((uint8_t*) a2dp->buffer + sizeof(*header));
-
-    frame_count = 0;
-
-    /* Try to create a packet of the full MTU */
-
-    p = (const uint8_t *) pa_memblock_acquire_chunk(&u->write_memchunk);
-    to_encode = u->write_memchunk.length;
-
-    d = (uint8_t*) a2dp->buffer + sizeof(*header) + sizeof(*payload);
-    to_write = a2dp->buffer_size - sizeof(*header) - sizeof(*payload);
-
-    while (PA_LIKELY(to_encode > 0 && to_write > 0)) {
-        ssize_t written;
-        ssize_t encoded;
-
-        encoded = sbc_encode(&a2dp->sbc,
-                             p, to_encode,
-                             d, to_write,
-                             &written);
-
-        if (PA_UNLIKELY(encoded <= 0)) {
-            pa_log_error("SBC encoding error (%li)", (long) encoded);
-            pa_memblock_release(u->write_memchunk.memblock);
-            return -1;
-        }
-
-/*         pa_log_debug("SBC: encoded: %lu; written: %lu", (unsigned long) encoded, (unsigned long) written); */
-/*         pa_log_debug("SBC: codesize: %lu; frame_length: %lu", (unsigned long) a2dp->codesize, (unsigned long) a2dp->frame_length); */
-
-        pa_assert_fp((size_t) encoded <= to_encode);
-        pa_assert_fp((size_t) encoded == a2dp->codesize);
-
-        pa_assert_fp((size_t) written <= to_write);
-        pa_assert_fp((size_t) written == a2dp->frame_length);
-
-        p = (const uint8_t*) p + encoded;
-        to_encode -= encoded;
-
-        d = (uint8_t*) d + written;
-        to_write -= written;
-
-        frame_count++;
-    }
-
-    pa_memblock_release(u->write_memchunk.memblock);
-
-    pa_assert(to_encode == 0);
-
-    PA_ONCE_BEGIN {
-        pa_log_debug("Using SBC encoder implementation: %s", pa_strnull(sbc_get_implementation_info(&a2dp->sbc)));
-    } PA_ONCE_END;
-
-    /* write it to the fifo */
-    memset(a2dp->buffer, 0, sizeof(*header) + sizeof(*payload));
-    header->v = 2;
-    header->pt = 1;
-    header->sequence_number = htons(a2dp->seq_num++);
-    header->timestamp = htonl(u->write_index / pa_frame_size(&u->sample_spec));
-    header->ssrc = htonl(1);
-    payload->frame_count = frame_count;
-
-    nbytes = (uint8_t*) d - (uint8_t*) a2dp->buffer;
-
-    for (;;) {
-        ssize_t l;
-
-        l = pa_write(u->stream_fd, a2dp->buffer, nbytes, &u->stream_write_type);
-
-        pa_assert(l != 0);
-
-        if (l < 0) {
-
-            if (errno == EINTR)
-                /* Retry right away if we got interrupted */
-                continue;
-
-            else if (errno == EAGAIN)
-                /* Hmm, apparently the socket was not writable, give up for now */
-                break;
-
-            pa_log_error("Failed to write data to socket: %s", pa_cstrerror(errno));
-            ret = -1;
-            break;
-        }
-
-        pa_assert((size_t) l <= nbytes);
-
-        if ((size_t) l != nbytes) {
-            pa_log_warn("Wrote memory block to socket only partially! %llu written, wanted to write %llu.",
-                        (unsigned long long) l,
-                        (unsigned long long) nbytes);
-            ret = -1;
-            break;
-        }
-
-        u->write_index += (uint64_t) u->write_memchunk.length;
-        pa_memblock_unref(u->write_memchunk.memblock);
-        pa_memchunk_reset(&u->write_memchunk);
-
-        ret = 1;
-
-        break;
-    }
-
-    return ret;
-}
-
-static int a2dp_process_push(struct userdata *u) {
-    int ret = 0;
-    pa_memchunk memchunk;
-
-    pa_assert(u);
-    pa_assert(u->profile == PA_BLUEZ4_PROFILE_A2DP_SOURCE);
-    pa_assert(u->source);
-    pa_assert(u->read_smoother);
-
-    memchunk.memblock = pa_memblock_new(u->core->mempool, u->read_block_size);
-    memchunk.index = memchunk.length = 0;
-
-    for (;;) {
-        bool found_tstamp = false;
-        pa_usec_t tstamp;
-        struct a2dp_info *a2dp;
-        struct rtp_header *header;
-        struct rtp_payload *payload;
-        const void *p;
-        void *d;
-        ssize_t l;
-        size_t to_write, to_decode;
-        size_t total_written = 0;
-
-        a2dp_prepare_buffer(u);
-
-        a2dp = &u->a2dp;
-        header = a2dp->buffer;
-        payload = (struct rtp_payload*) ((uint8_t*) a2dp->buffer + sizeof(*header));
-
-        l = pa_read(u->stream_fd, a2dp->buffer, a2dp->buffer_size, &u->stream_write_type);
-
-        if (l <= 0) {
-
-            if (l < 0 && errno == EINTR)
-                /* Retry right away if we got interrupted */
-                continue;
-
-            else if (l < 0 && errno == EAGAIN)
-                /* Hmm, apparently the socket was not readable, give up for now. */
-                break;
-
-            pa_log_error("Failed to read data from socket: %s", l < 0 ? pa_cstrerror(errno) : "EOF");
-            ret = -1;
-            break;
-        }
-
-        pa_assert((size_t) l <= a2dp->buffer_size);
-
-        /* TODO: get timestamp from rtp */
-        if (!found_tstamp) {
-            /* pa_log_warn("Couldn't find SO_TIMESTAMP data in auxiliary recvmsg() data!"); */
-            tstamp = pa_rtclock_now();
-        }
-
-        p = (uint8_t*) a2dp->buffer + sizeof(*header) + sizeof(*payload);
-        to_decode = l - sizeof(*header) - sizeof(*payload);
-
-        d = pa_memblock_acquire(memchunk.memblock);
-        to_write = memchunk.length = pa_memblock_get_length(memchunk.memblock);
-
-        while (PA_LIKELY(to_decode > 0)) {
-            size_t written;
-            ssize_t decoded;
-
-            decoded = sbc_decode(&a2dp->sbc,
-                                 p, to_decode,
-                                 d, to_write,
-                                 &written);
-
-            if (PA_UNLIKELY(decoded <= 0)) {
-                pa_log_error("SBC decoding error (%li)", (long) decoded);
-                pa_memblock_release(memchunk.memblock);
-                pa_memblock_unref(memchunk.memblock);
-                return 0;
-            }
-
-/*             pa_log_debug("SBC: decoded: %lu; written: %lu", (unsigned long) decoded, (unsigned long) written); */
-/*             pa_log_debug("SBC: frame_length: %lu; codesize: %lu", (unsigned long) a2dp->frame_length, (unsigned long) a2dp->codesize); */
-
-            total_written += written;
-
-            /* Reset frame length, it can be changed due to bitpool change */
-            a2dp->frame_length = sbc_get_frame_length(&a2dp->sbc);
-
-            pa_assert_fp((size_t) decoded <= to_decode);
-            pa_assert_fp((size_t) decoded == a2dp->frame_length);
-
-            pa_assert_fp((size_t) written == a2dp->codesize);
-
-            p = (const uint8_t*) p + decoded;
-            to_decode -= decoded;
-
-            d = (uint8_t*) d + written;
-            to_write -= written;
-        }
-
-        u->read_index += (uint64_t) total_written;
-        pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->sample_spec));
-        pa_smoother_resume(u->read_smoother, tstamp, true);
-
-        memchunk.length -= to_write;
-
-        pa_memblock_release(memchunk.memblock);
-
-        pa_source_post(u->source, &memchunk);
-
-        ret = l;
-        break;
-    }
-
-    pa_memblock_unref(memchunk.memblock);
-
-    return ret;
-}
-
-static void a2dp_reduce_bitpool(struct userdata *u) {
-    struct a2dp_info *a2dp;
-    uint8_t bitpool;
-
-    pa_assert(u);
-
-    a2dp = &u->a2dp;
-
-    /* Check if bitpool is already at its limit */
-    if (a2dp->sbc.bitpool <= BITPOOL_DEC_LIMIT)
-        return;
-
-    bitpool = a2dp->sbc.bitpool - BITPOOL_DEC_STEP;
-
-    if (bitpool < BITPOOL_DEC_LIMIT)
-        bitpool = BITPOOL_DEC_LIMIT;
-
-    a2dp_set_bitpool(u, bitpool);
-}
-
-static void thread_func(void *userdata) {
-    struct userdata *u = userdata;
-    unsigned do_write = 0;
-    unsigned pending_read_bytes = 0;
-    bool writable = false;
-
-    pa_assert(u);
-    pa_assert(u->transport);
-
-    pa_log_debug("IO Thread starting up");
-
-    if (u->core->realtime_scheduling)
-        pa_make_realtime(u->core->realtime_priority);
-
-    pa_thread_mq_install(&u->thread_mq);
-
-    /* Setup the stream only if the transport was already acquired */
-    if (u->transport_acquired)
-        setup_stream(u);
-
-    for (;;) {
-        struct pollfd *pollfd;
-        int ret;
-        bool disable_timer = true;
-
-        pollfd = u->rtpoll_item ? pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL) : NULL;
-
-        if (u->source && PA_SOURCE_IS_LINKED(u->source->thread_info.state)) {
-
-            /* We should send two blocks to the device before we expect
-             * a response. */
-
-            if (u->write_index == 0 && u->read_index <= 0)
-                do_write = 2;
-
-            if (pollfd && (pollfd->revents & POLLIN)) {
-                int n_read;
-
-                if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY)
-                    n_read = hsp_process_push(u);
-                else
-                    n_read = a2dp_process_push(u);
-
-                if (n_read < 0)
-                    goto io_fail;
-
-                if (n_read > 0) {
-                    /* We just read something, so we are supposed to write something, too */
-                    pending_read_bytes += n_read;
-                    do_write += pending_read_bytes / u->write_block_size;
-                    pending_read_bytes = pending_read_bytes % u->write_block_size;
-                }
-            }
-        }
-
-        if (u->sink && PA_SINK_IS_LINKED(u->sink->thread_info.state)) {
-
-            if (PA_UNLIKELY(u->sink->thread_info.rewind_requested))
-                pa_sink_process_rewind(u->sink, 0);
-
-            if (pollfd) {
-                if (pollfd->revents & POLLOUT)
-                    writable = true;
-
-                if ((!u->source || !PA_SOURCE_IS_LINKED(u->source->thread_info.state)) && do_write <= 0 && writable) {
-                    pa_usec_t time_passed;
-                    pa_usec_t audio_sent;
-
-                    /* Hmm, there is no input stream we could synchronize
-                     * to. So let's do things by time */
-
-                    time_passed = pa_rtclock_now() - u->started_at;
-                    audio_sent = pa_bytes_to_usec(u->write_index, &u->sample_spec);
-
-                    if (audio_sent <= time_passed) {
-                        pa_usec_t audio_to_send = time_passed - audio_sent;
-
-                        /* Never try to catch up for more than 100ms */
-                        if (u->write_index > 0 && audio_to_send > MAX_PLAYBACK_CATCH_UP_USEC) {
-                            pa_usec_t skip_usec;
-                            uint64_t skip_bytes;
-
-                            skip_usec = audio_to_send - MAX_PLAYBACK_CATCH_UP_USEC;
-                            skip_bytes = pa_usec_to_bytes(skip_usec, &u->sample_spec);
-
-                            if (skip_bytes > 0) {
-                                pa_memchunk tmp;
-
-                                pa_log_warn("Skipping %llu us (= %llu bytes) in audio stream",
-                                            (unsigned long long) skip_usec,
-                                            (unsigned long long) skip_bytes);
-
-                                pa_sink_render_full(u->sink, skip_bytes, &tmp);
-                                pa_memblock_unref(tmp.memblock);
-                                u->write_index += skip_bytes;
-
-                                if (u->profile == PA_BLUEZ4_PROFILE_A2DP_SINK)
-                                    a2dp_reduce_bitpool(u);
-                            }
-                        }
-
-                        do_write = 1;
-                        pending_read_bytes = 0;
-                    }
-                }
-
-                if (writable && do_write > 0) {
-                    int n_written;
-
-                    if (u->write_index <= 0)
-                        u->started_at = pa_rtclock_now();
-
-                    if (u->profile == PA_BLUEZ4_PROFILE_A2DP_SINK) {
-                        if ((n_written = a2dp_process_render(u)) < 0)
-                            goto io_fail;
-                    } else {
-                        if ((n_written = hsp_process_render(u)) < 0)
-                            goto io_fail;
-                    }
-
-                    if (n_written == 0)
-                        pa_log("Broken kernel: we got EAGAIN on write() after POLLOUT!");
-
-                    do_write -= n_written;
-                    writable = false;
-                }
-
-                if ((!u->source || !PA_SOURCE_IS_LINKED(u->source->thread_info.state)) && do_write <= 0) {
-                    pa_usec_t sleep_for;
-                    pa_usec_t time_passed, next_write_at;
-
-                    if (writable) {
-                        /* Hmm, there is no input stream we could synchronize
-                         * to. So let's estimate when we need to wake up the latest */
-                        time_passed = pa_rtclock_now() - u->started_at;
-                        next_write_at = pa_bytes_to_usec(u->write_index, &u->sample_spec);
-                        sleep_for = time_passed < next_write_at ? next_write_at - time_passed : 0;
-                        /* pa_log("Sleeping for %lu; time passed %lu, next write at %lu", (unsigned long) sleep_for, (unsigned long) time_passed, (unsigned long)next_write_at); */
-                    } else
-                        /* drop stream every 500 ms */
-                        sleep_for = PA_USEC_PER_MSEC * 500;
-
-                    pa_rtpoll_set_timer_relative(u->rtpoll, sleep_for);
-                    disable_timer = false;
-                }
-            }
-        }
-
-        if (disable_timer)
-            pa_rtpoll_set_timer_disabled(u->rtpoll);
-
-        /* Hmm, nothing to do. Let's sleep */
-        if (pollfd)
-            pollfd->events = (short) (((u->sink && PA_SINK_IS_LINKED(u->sink->thread_info.state) && !writable) ? POLLOUT : 0) |
-                                      (u->source && PA_SOURCE_IS_LINKED(u->source->thread_info.state) ? POLLIN : 0));
-
-        if ((ret = pa_rtpoll_run(u->rtpoll)) < 0) {
-            pa_log_debug("pa_rtpoll_run failed with: %d", ret);
-            goto fail;
-        }
-        if (ret == 0) {
-            pa_log_debug("IO thread shutdown requested, stopping cleanly");
-            bt_transport_release(u);
-            goto finish;
-        }
-
-        pollfd = u->rtpoll_item ? pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL) : NULL;
-
-        if (pollfd && (pollfd->revents & ~(POLLOUT|POLLIN))) {
-            pa_log_info("FD error: %s%s%s%s",
-                        pollfd->revents & POLLERR ? "POLLERR " :"",
-                        pollfd->revents & POLLHUP ? "POLLHUP " :"",
-                        pollfd->revents & POLLPRI ? "POLLPRI " :"",
-                        pollfd->revents & POLLNVAL ? "POLLNVAL " :"");
-            goto io_fail;
-        }
-
-        continue;
-
-io_fail:
-        /* In case of HUP, just tear down the streams */
-        if (!pollfd || (pollfd->revents & POLLHUP) == 0)
-            goto fail;
-
-        do_write = 0;
-        pending_read_bytes = 0;
-        writable = false;
-
-        teardown_stream(u);
-    }
-
-fail:
-    /* If this was no regular exit from the loop we have to continue processing messages until we receive PA_MESSAGE_SHUTDOWN */
-    pa_log_debug("IO thread failed");
-    pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(u->msg), BLUETOOTH_MESSAGE_IO_THREAD_FAILED, NULL, 0, NULL, NULL);
-    pa_asyncmsgq_wait_for(u->thread_mq.inq, PA_MESSAGE_SHUTDOWN);
-
-finish:
-    pa_log_debug("IO thread shutting down");
-}
-
-static pa_available_t transport_state_to_availability(pa_bluez4_transport_state_t state) {
-    if (state == PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED)
-        return PA_AVAILABLE_NO;
-    else if (state >= PA_BLUEZ4_TRANSPORT_STATE_PLAYING)
-        return PA_AVAILABLE_YES;
-    else
-        return PA_AVAILABLE_UNKNOWN;
-}
-
-static pa_direction_t get_profile_direction(pa_bluez4_profile_t p) {
-    static const pa_direction_t profile_direction[] = {
-        [PA_BLUEZ4_PROFILE_A2DP_SINK] = PA_DIRECTION_OUTPUT,
-        [PA_BLUEZ4_PROFILE_A2DP_SOURCE] = PA_DIRECTION_INPUT,
-        [PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
-        [PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY] = PA_DIRECTION_INPUT | PA_DIRECTION_OUTPUT,
-        [PA_BLUEZ4_PROFILE_OFF] = 0
-    };
-
-    return profile_direction[p];
-}
-
-/* Run from main thread */
-static pa_available_t get_port_availability(struct userdata *u, pa_direction_t direction) {
-    pa_available_t result = PA_AVAILABLE_NO;
-    unsigned i;
-
-    pa_assert(u);
-    pa_assert(u->device);
-
-    for (i = 0; i < PA_BLUEZ4_PROFILE_COUNT; i++) {
-        pa_bluez4_transport *transport;
-
-        if (!(get_profile_direction(i) & direction))
-            continue;
-
-        if (!(transport = u->device->transports[i]))
-            continue;
-
-        switch(transport->state) {
-            case PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED:
-                continue;
-
-            case PA_BLUEZ4_TRANSPORT_STATE_IDLE:
-                if (result == PA_AVAILABLE_NO)
-                    result = PA_AVAILABLE_UNKNOWN;
-
-                break;
-
-            case PA_BLUEZ4_TRANSPORT_STATE_PLAYING:
-                return PA_AVAILABLE_YES;
-        }
-    }
-
-    return result;
-}
-
-/* Run from main thread */
-static void handle_transport_state_change(struct userdata *u, struct pa_bluez4_transport *transport) {
-    bool acquire = false;
-    bool release = false;
-    pa_bluez4_profile_t profile;
-    pa_card_profile *cp;
-    pa_bluez4_transport_state_t state;
-    pa_device_port *port;
-
-    pa_assert(u);
-    pa_assert(transport);
-
-    profile = transport->profile;
-    state = transport->state;
-
-    /* Update profile availability */
-    if (!(cp = pa_hashmap_get(u->card->profiles, pa_bluez4_profile_to_string(profile))))
-        return;
-
-    pa_card_profile_set_available(cp, transport_state_to_availability(state));
-
-    /* Update port availability */
-    pa_assert_se(port = pa_hashmap_get(u->card->ports, u->output_port_name));
-    pa_device_port_set_available(port, get_port_availability(u, PA_DIRECTION_OUTPUT));
-
-    pa_assert_se(port = pa_hashmap_get(u->card->ports, u->input_port_name));
-    pa_device_port_set_available(port, get_port_availability(u, PA_DIRECTION_INPUT));
-
-    /* Acquire or release transport as needed */
-    acquire = (state == PA_BLUEZ4_TRANSPORT_STATE_PLAYING && u->profile == profile);
-    release = (state != PA_BLUEZ4_TRANSPORT_STATE_PLAYING && u->profile == profile);
-
-    if (acquire)
-        if (bt_transport_acquire(u, true) >= 0) {
-            if (u->source) {
-                pa_log_debug("Resuming source %s, because the bluetooth audio state changed to 'playing'.", u->source->name);
-                pa_source_suspend(u->source, false, PA_SUSPEND_IDLE|PA_SUSPEND_USER);
-            }
-
-            if (u->sink) {
-                pa_log_debug("Resuming sink %s, because the bluetooth audio state changed to 'playing'.", u->sink->name);
-                pa_sink_suspend(u->sink, false, PA_SUSPEND_IDLE|PA_SUSPEND_USER);
-            }
-        }
-
-    if (release && u->transport_acquired) {
-        /* FIXME: this release is racy, since the audio stream might have
-           been set up again in the meantime (but not processed yet by PA).
-           BlueZ should probably release the transport automatically, and
-           in that case we would just mark the transport as released */
-
-        /* Remote side closed the stream so we consider it PA_SUSPEND_USER */
-        if (u->source) {
-            pa_log_debug("Suspending source %s, because the remote end closed the stream.", u->source->name);
-            pa_source_suspend(u->source, true, PA_SUSPEND_USER);
-        }
-
-        if (u->sink) {
-            pa_log_debug("Suspending sink %s, because the remote end closed the stream.", u->sink->name);
-            pa_sink_suspend(u->sink, true, PA_SUSPEND_USER);
-        }
-    }
-}
-
-/* Run from main thread */
-static void sink_set_volume_cb(pa_sink *s) {
-    uint16_t gain;
-    pa_volume_t volume;
-    struct userdata *u;
-    char *k;
-
-    pa_assert(s);
-    pa_assert(s->core);
-
-    k = pa_sprintf_malloc("bluetooth-device@%p", (void*) s);
-    u = pa_shared_get(s->core, k);
-    pa_xfree(k);
-
-    pa_assert(u);
-    pa_assert(u->sink == s);
-    pa_assert(u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT);
-    pa_assert(u->transport);
-
-    gain = (dbus_uint16_t) round((double) pa_cvolume_max(&s->real_volume) * HSP_MAX_GAIN / PA_VOLUME_NORM);
-    volume = (pa_volume_t) round((double) gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
-
-    pa_cvolume_set(&s->real_volume, u->sample_spec.channels, volume);
-
-    pa_bluez4_transport_set_speaker_gain(u->transport, gain);
-}
-
-/* Run from main thread */
-static void source_set_volume_cb(pa_source *s) {
-    uint16_t gain;
-    pa_volume_t volume;
-    struct userdata *u;
-    char *k;
-
-    pa_assert(s);
-    pa_assert(s->core);
-
-    k = pa_sprintf_malloc("bluetooth-device@%p", (void*) s);
-    u = pa_shared_get(s->core, k);
-    pa_xfree(k);
-
-    pa_assert(u);
-    pa_assert(u->source == s);
-    pa_assert(u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT);
-    pa_assert(u->transport);
-
-    gain = (dbus_uint16_t) round((double) pa_cvolume_max(&s->real_volume) * HSP_MAX_GAIN / PA_VOLUME_NORM);
-    volume = (pa_volume_t) round((double) gain * PA_VOLUME_NORM / HSP_MAX_GAIN);
-
-    pa_cvolume_set(&s->real_volume, u->sample_spec.channels, volume);
-
-    pa_bluez4_transport_set_microphone_gain(u->transport, gain);
-}
-
-/* Run from main thread */
-static char *get_name(const char *type, pa_modargs *ma, const char *device_id, const char *profile, bool *namereg_fail) {
-    char *t;
-    const char *n;
-
-    pa_assert(type);
-    pa_assert(ma);
-    pa_assert(device_id);
-    pa_assert(namereg_fail);
-
-    t = pa_sprintf_malloc("%s_name", type);
-    n = pa_modargs_get_value(ma, t, NULL);
-    pa_xfree(t);
-
-    if (n) {
-        *namereg_fail = true;
-        return pa_xstrdup(n);
-    }
-
-    if ((n = pa_modargs_get_value(ma, "name", NULL)))
-        *namereg_fail = true;
-    else {
-        n = device_id;
-        *namereg_fail = false;
-    }
-
-    if (profile)
-        return pa_sprintf_malloc("bluez_%s.%s.%s", type, n, profile);
-    else
-        return pa_sprintf_malloc("bluez_%s.%s", type, n);
-}
-
-static int sco_over_pcm_state_update(struct userdata *u, bool changed) {
-    pa_assert(u);
-    pa_assert(USE_SCO_OVER_PCM(u));
-
-    if (PA_SINK_IS_OPENED(pa_sink_get_state(u->hsp.sco_sink)) ||
-        PA_SOURCE_IS_OPENED(pa_source_get_state(u->hsp.sco_source))) {
-
-        if (u->stream_fd >= 0)
-            return 0;
-
-        pa_log_debug("Resuming SCO over PCM");
-        if (init_profile(u) < 0) {
-            pa_log("Can't resume SCO over PCM");
-            return -1;
-        }
-
-        if (bt_transport_acquire(u, false) < 0)
-            return -1;
-
-        setup_stream(u);
-
-        return 0;
-    }
-
-    if (changed) {
-        if (u->stream_fd < 0)
-            return 0;
-
-        pa_log_debug("Closing SCO over PCM");
-
-        bt_transport_release(u);
-    }
-
-    return 0;
-}
-
-static pa_hook_result_t sink_state_changed_cb(pa_core *c, pa_sink *s, struct userdata *u) {
-    pa_assert(c);
-    pa_sink_assert_ref(s);
-    pa_assert(u);
-
-    if (!USE_SCO_OVER_PCM(u) || s != u->hsp.sco_sink)
-        return PA_HOOK_OK;
-
-    sco_over_pcm_state_update(u, true);
-
-    return PA_HOOK_OK;
-}
-
-static pa_hook_result_t source_state_changed_cb(pa_core *c, pa_source *s, struct userdata *u) {
-    pa_assert(c);
-    pa_source_assert_ref(s);
-    pa_assert(u);
-
-    if (!USE_SCO_OVER_PCM(u) || s != u->hsp.sco_source)
-        return PA_HOOK_OK;
-
-    sco_over_pcm_state_update(u, true);
-
-    return PA_HOOK_OK;
-}
-
-static pa_hook_result_t transport_nrec_changed_cb(pa_bluez4_discovery *y, pa_bluez4_transport *t, struct userdata *u) {
-    pa_proplist *p;
-
-    pa_assert(t);
-    pa_assert(u);
-
-    if (t != u->transport)
-        return PA_HOOK_OK;
-
-    p = pa_proplist_new();
-    pa_proplist_sets(p, "bluetooth.nrec", t->nrec ? "1" : "0");
-    pa_source_update_proplist(u->source, PA_UPDATE_REPLACE, p);
-    pa_proplist_free(p);
-
-    return PA_HOOK_OK;
-}
-
-static pa_hook_result_t transport_microphone_gain_changed_cb(pa_bluez4_discovery *y, pa_bluez4_transport *t,
-                                                             struct userdata *u) {
-    pa_cvolume v;
-
-    pa_assert(t);
-    pa_assert(u);
-
-    if (t != u->transport)
-        return PA_HOOK_OK;
-
-    pa_assert(u->source);
-
-    pa_cvolume_set(&v, u->sample_spec.channels,
-                   (pa_volume_t) round((double) t->microphone_gain * PA_VOLUME_NORM / HSP_MAX_GAIN));
-    pa_source_volume_changed(u->source, &v);
-
-    return PA_HOOK_OK;
-}
-
-static pa_hook_result_t transport_speaker_gain_changed_cb(pa_bluez4_discovery *y, pa_bluez4_transport *t,
-                                                          struct userdata *u) {
-    pa_cvolume v;
-
-    pa_assert(t);
-    pa_assert(u);
-
-    if (t != u->transport)
-        return PA_HOOK_OK;
-
-    pa_assert(u->sink);
-
-    pa_cvolume_set(&v, u->sample_spec.channels, (pa_volume_t) round((double) t->speaker_gain * PA_VOLUME_NORM / HSP_MAX_GAIN));
-    pa_sink_volume_changed(u->sink, &v);
-
-    return PA_HOOK_OK;
-}
-
-static void connect_ports(struct userdata *u, void *sink_or_source_new_data, pa_direction_t direction) {
-    pa_device_port *port;
-
-    if (direction == PA_DIRECTION_OUTPUT) {
-        pa_sink_new_data *sink_new_data = sink_or_source_new_data;
-
-        pa_assert_se(port = pa_hashmap_get(u->card->ports, u->output_port_name));
-        pa_assert_se(pa_hashmap_put(sink_new_data->ports, port->name, port) >= 0);
-        pa_device_port_ref(port);
-    } else {
-        pa_source_new_data *source_new_data = sink_or_source_new_data;
-
-        pa_assert_se(port = pa_hashmap_get(u->card->ports, u->input_port_name));
-        pa_assert_se(pa_hashmap_put(source_new_data->ports, port->name, port) >= 0);
-        pa_device_port_ref(port);
-    }
-}
-
-static int sink_set_port_cb(pa_sink *s, pa_device_port *p) {
-    return 0;
-}
-
-static int source_set_port_cb(pa_source *s, pa_device_port *p) {
-    return 0;
-}
-
-/* Run from main thread */
-static int add_sink(struct userdata *u) {
-    char *k;
-
-    pa_assert(u->transport);
-
-    if (USE_SCO_OVER_PCM(u)) {
-        pa_proplist *p;
-
-        u->sink = u->hsp.sco_sink;
-        p = pa_proplist_new();
-        pa_proplist_sets(p, "bluetooth.protocol", pa_bluez4_profile_to_string(u->profile));
-        pa_proplist_update(u->sink->proplist, PA_UPDATE_MERGE, p);
-        pa_proplist_free(p);
-    } else {
-        pa_sink_new_data data;
-        bool b;
-
-        pa_sink_new_data_init(&data);
-        data.driver = __FILE__;
-        data.module = u->module;
-        pa_sink_new_data_set_sample_spec(&data, &u->sample_spec);
-        pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluez4_profile_to_string(u->profile));
-        if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT)
-            pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
-        data.card = u->card;
-        data.name = get_name("sink", u->modargs, u->address, pa_bluez4_profile_to_string(u->profile), &b);
-        data.namereg_fail = b;
-
-        if (pa_modargs_get_proplist(u->modargs, "sink_properties", data.proplist, PA_UPDATE_REPLACE) < 0) {
-            pa_log("Invalid properties");
-            pa_sink_new_data_done(&data);
-            return -1;
-        }
-        connect_ports(u, &data, PA_DIRECTION_OUTPUT);
-
-        if (!u->transport_acquired)
-            switch (u->profile) {
-                case PA_BLUEZ4_PROFILE_A2DP_SINK:
-                case PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT:
-                    pa_assert_not_reached(); /* Profile switch should have failed */
-                    break;
-                case PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY:
-                    data.suspend_cause = PA_SUSPEND_USER;
-                    break;
-                case PA_BLUEZ4_PROFILE_A2DP_SOURCE:
-                case PA_BLUEZ4_PROFILE_OFF:
-                    pa_assert_not_reached();
-            }
-
-        u->sink = pa_sink_new(u->core, &data, PA_SINK_HARDWARE|PA_SINK_LATENCY);
-        pa_sink_new_data_done(&data);
-
-        if (!u->sink) {
-            pa_log_error("Failed to create sink");
-            return -1;
-        }
-
-        u->sink->userdata = u;
-        u->sink->parent.process_msg = sink_process_msg;
-        u->sink->set_state_in_io_thread = sink_set_state_in_io_thread_cb;
-        u->sink->set_port = sink_set_port_cb;
-    }
-
-    if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT) {
-        pa_sink_set_set_volume_callback(u->sink, sink_set_volume_cb);
-        u->sink->n_volume_steps = 16;
-
-        k = pa_sprintf_malloc("bluetooth-device@%p", (void*) u->sink);
-        pa_shared_set(u->core, k, u);
-        pa_xfree(k);
-    }
-
-    return 0;
-}
-
-/* Run from main thread */
-static int add_source(struct userdata *u) {
-    char *k;
-
-    pa_assert(u->transport);
-
-    if (USE_SCO_OVER_PCM(u)) {
-        u->source = u->hsp.sco_source;
-        pa_proplist_sets(u->source->proplist, "bluetooth.protocol", pa_bluez4_profile_to_string(u->profile));
-    } else {
-        pa_source_new_data data;
-        bool b;
-
-        pa_source_new_data_init(&data);
-        data.driver = __FILE__;
-        data.module = u->module;
-        pa_source_new_data_set_sample_spec(&data, &u->sample_spec);
-        pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluez4_profile_to_string(u->profile));
-        if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT)
-            pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
-
-        data.card = u->card;
-        data.name = get_name("source", u->modargs, u->address, pa_bluez4_profile_to_string(u->profile), &b);
-        data.namereg_fail = b;
-
-        if (pa_modargs_get_proplist(u->modargs, "source_properties", data.proplist, PA_UPDATE_REPLACE) < 0) {
-            pa_log("Invalid properties");
-            pa_source_new_data_done(&data);
-            return -1;
-        }
-
-        connect_ports(u, &data, PA_DIRECTION_INPUT);
-
-        if (!u->transport_acquired)
-            switch (u->profile) {
-                case PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT:
-                    pa_assert_not_reached(); /* Profile switch should have failed */
-                    break;
-                case PA_BLUEZ4_PROFILE_A2DP_SOURCE:
-                case PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY:
-                    data.suspend_cause = PA_SUSPEND_USER;
-                    break;
-                case PA_BLUEZ4_PROFILE_A2DP_SINK:
-                case PA_BLUEZ4_PROFILE_OFF:
-                    pa_assert_not_reached();
-            }
-
-        u->source = pa_source_new(u->core, &data, PA_SOURCE_HARDWARE|PA_SOURCE_LATENCY);
-        pa_source_new_data_done(&data);
-
-        if (!u->source) {
-            pa_log_error("Failed to create source");
-            return -1;
-        }
-
-        u->source->userdata = u;
-        u->source->parent.process_msg = source_process_msg;
-        u->source->set_state_in_io_thread = source_set_state_in_io_thread_cb;
-        u->source->set_port = source_set_port_cb;
-    }
-
-    if ((u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT) || (u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY)) {
-        pa_bluez4_transport *t = u->transport;
-        pa_proplist_sets(u->source->proplist, "bluetooth.nrec", t->nrec ? "1" : "0");
-    }
-
-    if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT) {
-        pa_source_set_set_volume_callback(u->source, source_set_volume_cb);
-        u->source->n_volume_steps = 16;
-
-        k = pa_sprintf_malloc("bluetooth-device@%p", (void*) u->source);
-        pa_shared_set(u->core, k, u);
-        pa_xfree(k);
-    }
-
-    return 0;
-}
-
-static void bt_transport_config_a2dp(struct userdata *u) {
-    const pa_bluez4_transport *t;
-    struct a2dp_info *a2dp = &u->a2dp;
-    a2dp_sbc_t *config;
-
-    t = u->transport;
-    pa_assert(t);
-
-    config = (a2dp_sbc_t *) t->config;
-
-    u->sample_spec.format = PA_SAMPLE_S16LE;
-
-    if (a2dp->sbc_initialized)
-        sbc_reinit(&a2dp->sbc, 0);
-    else
-        sbc_init(&a2dp->sbc, 0);
-    a2dp->sbc_initialized = true;
-
-    switch (config->frequency) {
-        case SBC_SAMPLING_FREQ_16000:
-            a2dp->sbc.frequency = SBC_FREQ_16000;
-            u->sample_spec.rate = 16000U;
-            break;
-        case SBC_SAMPLING_FREQ_32000:
-            a2dp->sbc.frequency = SBC_FREQ_32000;
-            u->sample_spec.rate = 32000U;
-            break;
-        case SBC_SAMPLING_FREQ_44100:
-            a2dp->sbc.frequency = SBC_FREQ_44100;
-            u->sample_spec.rate = 44100U;
-            break;
-        case SBC_SAMPLING_FREQ_48000:
-            a2dp->sbc.frequency = SBC_FREQ_48000;
-            u->sample_spec.rate = 48000U;
-            break;
-        default:
-            pa_assert_not_reached();
-    }
-
-    switch (config->channel_mode) {
-        case SBC_CHANNEL_MODE_MONO:
-            a2dp->sbc.mode = SBC_MODE_MONO;
-            u->sample_spec.channels = 1;
-            break;
-        case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-            a2dp->sbc.mode = SBC_MODE_DUAL_CHANNEL;
-            u->sample_spec.channels = 2;
-            break;
-        case SBC_CHANNEL_MODE_STEREO:
-            a2dp->sbc.mode = SBC_MODE_STEREO;
-            u->sample_spec.channels = 2;
-            break;
-        case SBC_CHANNEL_MODE_JOINT_STEREO:
-            a2dp->sbc.mode = SBC_MODE_JOINT_STEREO;
-            u->sample_spec.channels = 2;
-            break;
-        default:
-            pa_assert_not_reached();
-    }
-
-    switch (config->allocation_method) {
-        case SBC_ALLOCATION_SNR:
-            a2dp->sbc.allocation = SBC_AM_SNR;
-            break;
-        case SBC_ALLOCATION_LOUDNESS:
-            a2dp->sbc.allocation = SBC_AM_LOUDNESS;
-            break;
-        default:
-            pa_assert_not_reached();
-    }
-
-    switch (config->subbands) {
-        case SBC_SUBBANDS_4:
-            a2dp->sbc.subbands = SBC_SB_4;
-            break;
-        case SBC_SUBBANDS_8:
-            a2dp->sbc.subbands = SBC_SB_8;
-            break;
-        default:
-            pa_assert_not_reached();
-    }
-
-    switch (config->block_length) {
-        case SBC_BLOCK_LENGTH_4:
-            a2dp->sbc.blocks = SBC_BLK_4;
-            break;
-        case SBC_BLOCK_LENGTH_8:
-            a2dp->sbc.blocks = SBC_BLK_8;
-            break;
-        case SBC_BLOCK_LENGTH_12:
-            a2dp->sbc.blocks = SBC_BLK_12;
-            break;
-        case SBC_BLOCK_LENGTH_16:
-            a2dp->sbc.blocks = SBC_BLK_16;
-            break;
-        default:
-            pa_assert_not_reached();
-    }
-
-    a2dp->min_bitpool = config->min_bitpool;
-    a2dp->max_bitpool = config->max_bitpool;
-
-    /* Set minimum bitpool for source to get the maximum possible block_size */
-    a2dp->sbc.bitpool = u->profile == PA_BLUEZ4_PROFILE_A2DP_SINK ? a2dp->max_bitpool : a2dp->min_bitpool;
-    a2dp->codesize = sbc_get_codesize(&a2dp->sbc);
-    a2dp->frame_length = sbc_get_frame_length(&a2dp->sbc);
-
-    pa_log_info("SBC parameters:\n\tallocation=%u\n\tsubbands=%u\n\tblocks=%u\n\tbitpool=%u",
-                a2dp->sbc.allocation, a2dp->sbc.subbands, a2dp->sbc.blocks, a2dp->sbc.bitpool);
-}
-
-static void bt_transport_config(struct userdata *u) {
-    if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        u->sample_spec.format = PA_SAMPLE_S16LE;
-        u->sample_spec.channels = 1;
-        u->sample_spec.rate = 8000;
-    } else
-        bt_transport_config_a2dp(u);
-}
-
-/* Run from main thread */
-static pa_hook_result_t transport_state_changed_cb(pa_bluez4_discovery *y, pa_bluez4_transport *t, struct userdata *u) {
-    pa_assert(t);
-    pa_assert(u);
-
-    if (t == u->transport && t->state == PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED)
-        pa_assert_se(pa_card_set_profile(u->card, pa_hashmap_get(u->card->profiles, "off"), false) >= 0);
-
-    if (t->device == u->device)
-        handle_transport_state_change(u, t);
-
-    return PA_HOOK_OK;
-}
-
-/* Run from main thread */
-static int setup_transport(struct userdata *u) {
-    pa_bluez4_transport *t;
-
-    pa_assert(u);
-    pa_assert(!u->transport);
-    pa_assert(u->profile != PA_BLUEZ4_PROFILE_OFF);
-
-    /* check if profile has a transport */
-    t = u->device->transports[u->profile];
-    if (!t || t->state == PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED) {
-        pa_log_warn("Profile has no transport");
-        return -1;
-    }
-
-    u->transport = t;
-
-    if (u->profile == PA_BLUEZ4_PROFILE_A2DP_SOURCE || u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY)
-        bt_transport_acquire(u, true); /* In case of error, the sink/sources will be created suspended */
-    else if (bt_transport_acquire(u, false) < 0)
-        return -1; /* We need to fail here until the interactions with module-suspend-on-idle and alike get improved */
-
-    bt_transport_config(u);
-
-    return 0;
-}
-
-/* Run from main thread */
-static int init_profile(struct userdata *u) {
-    int r = 0;
-    pa_assert(u);
-    pa_assert(u->profile != PA_BLUEZ4_PROFILE_OFF);
-
-    if (setup_transport(u) < 0)
-        return -1;
-
-    pa_assert(u->transport);
-
-    if (u->profile == PA_BLUEZ4_PROFILE_A2DP_SINK ||
-        u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT ||
-        u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY)
-        if (add_sink(u) < 0)
-            r = -1;
-
-    if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT ||
-        u->profile == PA_BLUEZ4_PROFILE_A2DP_SOURCE ||
-        u->profile == PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY)
-        if (add_source(u) < 0)
-            r = -1;
-
-    return r;
-}
-
-/* Run from main thread */
-static void stop_thread(struct userdata *u) {
-    char *k;
-
-    pa_assert(u);
-
-    if (u->sink && !USE_SCO_OVER_PCM(u))
-        pa_sink_unlink(u->sink);
-
-    if (u->source && !USE_SCO_OVER_PCM(u))
-        pa_source_unlink(u->source);
-
-    if (u->thread) {
-        pa_asyncmsgq_send(u->thread_mq.inq, NULL, PA_MESSAGE_SHUTDOWN, NULL, 0, NULL);
-        pa_thread_free(u->thread);
-        u->thread = NULL;
-    }
-
-    if (u->rtpoll_item) {
-        pa_rtpoll_item_free(u->rtpoll_item);
-        u->rtpoll_item = NULL;
-    }
-
-    if (u->rtpoll) {
-        pa_thread_mq_done(&u->thread_mq);
-
-        pa_rtpoll_free(u->rtpoll);
-        u->rtpoll = NULL;
-    }
-
-    if (u->transport) {
-        bt_transport_release(u);
-        u->transport = NULL;
-    }
-
-    if (u->sink) {
-        if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT) {
-            k = pa_sprintf_malloc("bluetooth-device@%p", (void*) u->sink);
-            pa_shared_remove(u->core, k);
-            pa_xfree(k);
-        }
-
-        pa_sink_unref(u->sink);
-        u->sink = NULL;
-    }
-
-    if (u->source) {
-        if (u->profile == PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT) {
-            k = pa_sprintf_malloc("bluetooth-device@%p", (void*) u->source);
-            pa_shared_remove(u->core, k);
-            pa_xfree(k);
-        }
-
-        pa_source_unref(u->source);
-        u->source = NULL;
-    }
-
-    if (u->read_smoother) {
-        pa_smoother_free(u->read_smoother);
-        u->read_smoother = NULL;
-    }
-}
-
-/* Run from main thread */
-static int start_thread(struct userdata *u) {
-    pa_assert(u);
-    pa_assert(!u->thread);
-    pa_assert(!u->rtpoll);
-    pa_assert(!u->rtpoll_item);
-
-    u->rtpoll = pa_rtpoll_new();
-
-    if (pa_thread_mq_init(&u->thread_mq, u->core->mainloop, u->rtpoll) < 0) {
-        pa_log("pa_thread_mq_init() failed.");
-        return -1;
-    }
-
-    if (USE_SCO_OVER_PCM(u)) {
-        if (sco_over_pcm_state_update(u, false) < 0) {
-            char *k;
-
-            if (u->sink) {
-                k = pa_sprintf_malloc("bluetooth-device@%p", (void*) u->sink);
-                pa_shared_remove(u->core, k);
-                pa_xfree(k);
-                u->sink = NULL;
-            }
-            if (u->source) {
-                k = pa_sprintf_malloc("bluetooth-device@%p", (void*) u->source);
-                pa_shared_remove(u->core, k);
-                pa_xfree(k);
-                u->source = NULL;
-            }
-            return -1;
-        }
-
-        pa_sink_ref(u->sink);
-        pa_source_ref(u->source);
-        /* FIXME: monitor stream_fd error */
-        return 0;
-    }
-
-    if (!(u->thread = pa_thread_new("bluetooth", thread_func, u))) {
-        pa_log_error("Failed to create IO thread");
-        return -1;
-    }
-
-    if (u->sink) {
-        pa_sink_set_asyncmsgq(u->sink, u->thread_mq.inq);
-        pa_sink_set_rtpoll(u->sink, u->rtpoll);
-        pa_sink_put(u->sink);
-
-        if (u->sink->set_volume)
-            u->sink->set_volume(u->sink);
-    }
-
-    if (u->source) {
-        pa_source_set_asyncmsgq(u->source, u->thread_mq.inq);
-        pa_source_set_rtpoll(u->source, u->rtpoll);
-        pa_source_put(u->source);
-
-        if (u->source->set_volume)
-            u->source->set_volume(u->source);
-    }
-
-    return 0;
-}
-
-static void save_sco_volume_callbacks(struct userdata *u) {
-    pa_assert(u);
-    pa_assert(USE_SCO_OVER_PCM(u));
-
-    u->hsp.sco_sink_set_volume = u->hsp.sco_sink->set_volume;
-    u->hsp.sco_source_set_volume = u->hsp.sco_source->set_volume;
-}
-
-static void restore_sco_volume_callbacks(struct userdata *u) {
-    pa_assert(u);
-    pa_assert(USE_SCO_OVER_PCM(u));
-
-    pa_sink_set_set_volume_callback(u->hsp.sco_sink, u->hsp.sco_sink_set_volume);
-    pa_source_set_set_volume_callback(u->hsp.sco_source, u->hsp.sco_source_set_volume);
-}
-
-/* Run from main thread */
-static int card_set_profile(pa_card *c, pa_card_profile *new_profile) {
-    struct userdata *u;
-    pa_bluez4_profile_t *d;
-
-    pa_assert(c);
-    pa_assert(new_profile);
-    pa_assert_se(u = c->userdata);
-
-    d = PA_CARD_PROFILE_DATA(new_profile);
-
-    if (*d != PA_BLUEZ4_PROFILE_OFF) {
-        const pa_bluez4_device *device = u->device;
-
-        if (!device->transports[*d] || device->transports[*d]->state == PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED) {
-            pa_log_warn("Profile not connected, refused to switch profile to %s", new_profile->name);
-            return -PA_ERR_IO;
-        }
-    }
-
-    stop_thread(u);
-
-    if (USE_SCO_OVER_PCM(u))
-        restore_sco_volume_callbacks(u);
-
-    u->profile = *d;
-    u->sample_spec = u->requested_sample_spec;
-
-    if (USE_SCO_OVER_PCM(u))
-        save_sco_volume_callbacks(u);
-
-    if (u->profile != PA_BLUEZ4_PROFILE_OFF)
-        if (init_profile(u) < 0)
-            goto off;
-
-    if (u->sink || u->source)
-        if (start_thread(u) < 0)
-            goto off;
-
-    return 0;
-
-off:
-    stop_thread(u);
-
-    pa_assert_se(pa_card_set_profile(u->card, pa_hashmap_get(u->card->profiles, "off"), false) >= 0);
-
-    return -PA_ERR_IO;
-}
-
-/* Run from main thread */
-static void create_card_ports(struct userdata *u, pa_hashmap *ports) {
-    pa_device_port *port;
-    pa_device_port_new_data port_data;
-
-    const char *name_prefix = NULL;
-    const char *input_description = NULL;
-    const char *output_description = NULL;
-
-    pa_assert(u);
-    pa_assert(ports);
-    pa_assert(u->device);
-
-    switch (pa_bluez4_get_form_factor(u->device->class)) {
-        case PA_BLUEZ4_FORM_FACTOR_UNKNOWN:
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_HEADSET:
-            name_prefix = "headset";
-            input_description = output_description = _("Headset");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_HANDSFREE:
-            name_prefix = "handsfree";
-            input_description = output_description = _("Handsfree");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_MICROPHONE:
-            name_prefix = "microphone";
-            input_description = _("Microphone");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_SPEAKER:
-            name_prefix = "speaker";
-            output_description = _("Speaker");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_HEADPHONE:
-            name_prefix = "headphone";
-            output_description = _("Headphone");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_PORTABLE:
-            name_prefix = "portable";
-            input_description = output_description = _("Portable");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_CAR:
-            name_prefix = "car";
-            input_description = output_description = _("Car");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_HIFI:
-            name_prefix = "hifi";
-            input_description = output_description = _("HiFi");
-            break;
-
-        case PA_BLUEZ4_FORM_FACTOR_PHONE:
-            name_prefix = "phone";
-            input_description = output_description = _("Phone");
-            break;
-    }
-
-    if (!name_prefix)
-        name_prefix = "unknown";
-
-    if (!output_description)
-        output_description = _("Bluetooth Output");
-
-    if (!input_description)
-        input_description = _("Bluetooth Input");
-
-    u->output_port_name = pa_sprintf_malloc("%s-output", name_prefix);
-    u->input_port_name = pa_sprintf_malloc("%s-input", name_prefix);
-
-    pa_device_port_new_data_init(&port_data);
-    pa_device_port_new_data_set_name(&port_data, u->output_port_name);
-    pa_device_port_new_data_set_description(&port_data, output_description);
-    pa_device_port_new_data_set_direction(&port_data, PA_DIRECTION_OUTPUT);
-    pa_device_port_new_data_set_available(&port_data, get_port_availability(u, PA_DIRECTION_OUTPUT));
-    pa_assert_se(port = pa_device_port_new(u->core, &port_data, 0));
-    pa_assert_se(pa_hashmap_put(ports, port->name, port) >= 0);
-    pa_device_port_new_data_done(&port_data);
-
-    pa_device_port_new_data_init(&port_data);
-    pa_device_port_new_data_set_name(&port_data, u->input_port_name);
-    pa_device_port_new_data_set_description(&port_data, input_description);
-    pa_device_port_new_data_set_direction(&port_data, PA_DIRECTION_INPUT);
-    pa_device_port_new_data_set_available(&port_data, get_port_availability(u, PA_DIRECTION_INPUT));
-    pa_assert_se(port = pa_device_port_new(u->core, &port_data, 0));
-    pa_assert_se(pa_hashmap_put(ports, port->name, port) >= 0);
-    pa_device_port_new_data_done(&port_data);
-}
-
-/* Run from main thread */
-static pa_card_profile *create_card_profile(struct userdata *u, pa_bluez4_profile_t profile, pa_hashmap *ports) {
-    pa_device_port *input_port, *output_port;
-    const char *name;
-    pa_card_profile *p = NULL;
-    pa_bluez4_profile_t *d = NULL;
-    pa_bluez4_transport *t;
-
-    pa_assert(u->input_port_name);
-    pa_assert(u->output_port_name);
-    pa_assert_se(input_port = pa_hashmap_get(ports, u->input_port_name));
-    pa_assert_se(output_port = pa_hashmap_get(ports, u->output_port_name));
-
-    name = pa_bluez4_profile_to_string(profile);
-
-    switch (profile) {
-    case PA_BLUEZ4_PROFILE_A2DP_SINK:
-        p = pa_card_profile_new(name, _("High Fidelity Playback (A2DP)"), sizeof(pa_bluez4_profile_t));
-        p->priority = 10;
-        p->n_sinks = 1;
-        p->n_sources = 0;
-        p->max_sink_channels = 2;
-        p->max_source_channels = 0;
-        pa_hashmap_put(output_port->profiles, p->name, p);
-
-        d = PA_CARD_PROFILE_DATA(p);
-        break;
-
-    case PA_BLUEZ4_PROFILE_A2DP_SOURCE:
-        p = pa_card_profile_new(name, _("High Fidelity Capture (A2DP)"), sizeof(pa_bluez4_profile_t));
-        p->priority = 10;
-        p->n_sinks = 0;
-        p->n_sources = 1;
-        p->max_sink_channels = 0;
-        p->max_source_channels = 2;
-        pa_hashmap_put(input_port->profiles, p->name, p);
-
-        d = PA_CARD_PROFILE_DATA(p);
-        break;
-
-    case PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT:
-        p = pa_card_profile_new(name, _("Telephony Duplex (HSP/HFP)"), sizeof(pa_bluez4_profile_t));
-        p->priority = 20;
-        p->n_sinks = 1;
-        p->n_sources = 1;
-        p->max_sink_channels = 1;
-        p->max_source_channels = 1;
-        pa_hashmap_put(input_port->profiles, p->name, p);
-        pa_hashmap_put(output_port->profiles, p->name, p);
-
-        d = PA_CARD_PROFILE_DATA(p);
-        break;
-
-    case PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY:
-        p = pa_card_profile_new(name, _("Handsfree Gateway"), sizeof(pa_bluez4_profile_t));
-        p->priority = 20;
-        p->n_sinks = 1;
-        p->n_sources = 1;
-        p->max_sink_channels = 1;
-        p->max_source_channels = 1;
-        pa_hashmap_put(input_port->profiles, p->name, p);
-        pa_hashmap_put(output_port->profiles, p->name, p);
-
-        d = PA_CARD_PROFILE_DATA(p);
-        break;
-
-    case PA_BLUEZ4_PROFILE_OFF:
-        pa_assert_not_reached();
-    }
-
-    *d = profile;
-
-    if ((t = u->device->transports[*d]))
-        p->available = transport_state_to_availability(t->state);
-
-    return p;
-}
-
-static int uuid_to_profile(const char *uuid, pa_bluez4_profile_t *_r) {
-    if (pa_streq(uuid, PA_BLUEZ4_UUID_A2DP_SINK))
-        *_r = PA_BLUEZ4_PROFILE_A2DP_SINK;
-    else if (pa_streq(uuid, PA_BLUEZ4_UUID_A2DP_SOURCE))
-        *_r = PA_BLUEZ4_PROFILE_A2DP_SOURCE;
-    else if (pa_streq(uuid, PA_BLUEZ4_UUID_HSP_HS) || pa_streq(uuid, PA_BLUEZ4_UUID_HFP_HF))
-        *_r = PA_BLUEZ4_PROFILE_HEADSET_HEAD_UNIT;
-    else if (pa_streq(uuid, PA_BLUEZ4_UUID_HSP_AG) || pa_streq(uuid, PA_BLUEZ4_UUID_HFP_AG))
-        *_r = PA_BLUEZ4_PROFILE_HEADSET_AUDIO_GATEWAY;
-    else
-        return -PA_ERR_INVALID;
-
-    return 0;
-}
-
-/* Run from main thread */
-static int add_card(struct userdata *u) {
-    pa_card_new_data data;
-    bool b;
-    pa_card_profile *p;
-    pa_bluez4_profile_t *d;
-    pa_bluez4_form_factor_t ff;
-    char *n;
-    const char *profile_str;
-    const pa_bluez4_device *device;
-    const char *uuid;
-    void *state;
-
-    pa_assert(u);
-    pa_assert(u->device);
-
-    device = u->device;
-
-    pa_card_new_data_init(&data);
-    data.driver = __FILE__;
-    data.module = u->module;
-
-    n = pa_utf8_filter(device->alias);
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_DESCRIPTION, n);
-    pa_xfree(n);
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_STRING, device->address);
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_API, "bluez");
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_CLASS, "sound");
-    pa_proplist_sets(data.proplist, PA_PROP_DEVICE_BUS, "bluetooth");
-
-    if ((ff = pa_bluez4_get_form_factor(device->class)) != PA_BLUEZ4_FORM_FACTOR_UNKNOWN)
-        pa_proplist_sets(data.proplist, PA_PROP_DEVICE_FORM_FACTOR, pa_bluez4_form_factor_to_string(ff));
-
-    pa_proplist_sets(data.proplist, "bluez.path", device->path);
-    pa_proplist_setf(data.proplist, "bluez.class", "0x%06x", (unsigned) device->class);
-    pa_proplist_sets(data.proplist, "bluez.alias", device->alias);
-    data.name = get_name("card", u->modargs, device->address, NULL, &b);
-    data.namereg_fail = b;
-
-    if (pa_modargs_get_proplist(u->modargs, "card_properties", data.proplist, PA_UPDATE_REPLACE) < 0) {
-        pa_log("Invalid properties");
-        pa_card_new_data_done(&data);
-        return -1;
-    }
-
-    create_card_ports(u, data.ports);
-
-    PA_HASHMAP_FOREACH(uuid, device->uuids, state) {
-        pa_bluez4_profile_t profile;
-
-        if (uuid_to_profile(uuid, &profile) < 0)
-            continue;
-
-        if (pa_hashmap_get(data.profiles, pa_bluez4_profile_to_string(profile)))
-            continue;
-
-        p = create_card_profile(u, profile, data.ports);
-        pa_hashmap_put(data.profiles, p->name, p);
-    }
-
-    pa_assert(!pa_hashmap_isempty(data.profiles));
-
-    p = pa_card_profile_new("off", _("Off"), sizeof(pa_bluez4_profile_t));
-    p->available = PA_AVAILABLE_YES;
-    d = PA_CARD_PROFILE_DATA(p);
-    *d = PA_BLUEZ4_PROFILE_OFF;
-    pa_hashmap_put(data.profiles, p->name, p);
-
-    u->card = pa_card_new(u->core, &data);
-    pa_card_new_data_done(&data);
-
-    if (!u->card) {
-        pa_log("Failed to allocate card.");
-        return -1;
-    }
-
-    u->card->userdata = u;
-    u->card->set_profile = card_set_profile;
-
-    pa_card_choose_initial_profile(u->card);
-
-    /* If the "profile" modarg is given, we have to override whatever the usual
-     * policy chose in pa_card_choose_initial_profile(). */
-    profile_str = pa_modargs_get_value(u->modargs, "profile", NULL);
-    if (profile_str) {
-        pa_card_profile *profile;
-
-        profile = pa_hashmap_get(u->card->profiles, profile_str);
-        if (!profile) {
-            pa_log("No such profile: %s", profile_str);
-            return -1;
-        }
-
-        pa_card_set_profile(u->card, profile, false);
-    }
-
-    pa_card_put(u->card);
-
-    d = PA_CARD_PROFILE_DATA(u->card->active_profile);
-
-    if (*d != PA_BLUEZ4_PROFILE_OFF && (!device->transports[*d] ||
-                              device->transports[*d]->state == PA_BLUEZ4_TRANSPORT_STATE_DISCONNECTED)) {
-        pa_log_warn("Default profile not connected, selecting off profile");
-        u->card->active_profile = pa_hashmap_get(u->card->profiles, "off");
-        u->card->save_profile = false;
-    }
-
-    d = PA_CARD_PROFILE_DATA(u->card->active_profile);
-    u->profile = *d;
-
-    if (USE_SCO_OVER_PCM(u))
-        save_sco_volume_callbacks(u);
-
-    return 0;
-}
-
-/* Run from main thread */
-static pa_bluez4_device* find_device(struct userdata *u, const char *address, const char *path) {
-    pa_bluez4_device *d = NULL;
-
-    pa_assert(u);
-
-    if (!address && !path) {
-        pa_log_error("Failed to get device address/path from module arguments.");
-        return NULL;
-    }
-
-    if (path) {
-        if (!(d = pa_bluez4_discovery_get_by_path(u->discovery, path))) {
-            pa_log_error("%s is not a valid BlueZ audio device.", path);
-            return NULL;
-        }
-
-        if (address && !(pa_streq(d->address, address))) {
-            pa_log_error("Passed path %s address %s != %s don't match.", path, d->address, address);
-            return NULL;
-        }
-
-    } else {
-        if (!(d = pa_bluez4_discovery_get_by_address(u->discovery, address))) {
-            pa_log_error("%s is not known.", address);
-            return NULL;
-        }
-    }
-
-    if (d) {
-        u->address = pa_xstrdup(d->address);
-        u->path = pa_xstrdup(d->path);
-    }
-
-    return d;
-}
-
-/* Run from main thread */
-static pa_hook_result_t uuid_added_cb(pa_bluez4_discovery *y, const struct pa_bluez4_hook_uuid_data *data,
-                                      struct userdata *u) {
-    pa_bluez4_profile_t profile;
-    pa_card_profile *p;
-
-    pa_assert(data);
-    pa_assert(data->device);
-    pa_assert(data->uuid);
-    pa_assert(u);
-
-    if (data->device != u->device)
-        return PA_HOOK_OK;
-
-    if (uuid_to_profile(data->uuid, &profile) < 0)
-        return PA_HOOK_OK;
-
-    if (pa_hashmap_get(u->card->profiles, pa_bluez4_profile_to_string(profile)))
-        return PA_HOOK_OK;
-
-    p = create_card_profile(u, profile, u->card->ports);
-    pa_card_add_profile(u->card, p);
-
-    return PA_HOOK_OK;
-}
-
-/* Run from main thread */
-static pa_hook_result_t discovery_hook_cb(pa_bluez4_discovery *y, const pa_bluez4_device *d, struct userdata *u) {
-    pa_assert(u);
-    pa_assert(d);
-
-    if (d != u->device)
-        return PA_HOOK_OK;
-
-    if (d->dead)
-        pa_log_debug("Device %s removed: unloading module", d->path);
-    else if (!pa_bluez4_device_any_audio_connected(d))
-        pa_log_debug("Unloading module, because device %s doesn't have any audio profiles connected anymore.", d->path);
-    else
-        return PA_HOOK_OK;
-
-    pa_module_unload(u->module, true);
-
-    return PA_HOOK_OK;
-}
-
-int pa__init(pa_module *m) {
-    pa_modargs *ma;
-    uint32_t channels;
-    struct userdata *u;
-    const char *address, *path;
-    pa_bluez4_device *device;
-
-    pa_assert(m);
-
-    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
-        pa_log_error("Failed to parse module arguments");
-        goto fail;
-    }
-
-    m->userdata = u = pa_xnew0(struct userdata, 1);
-    u->module = m;
-    u->core = m->core;
-    u->stream_fd = -1;
-    u->sample_spec = m->core->default_sample_spec;
-    u->modargs = ma;
-
-    if (pa_modargs_get_value(ma, "sco_sink", NULL) &&
-        !(u->hsp.sco_sink = pa_namereg_get(m->core, pa_modargs_get_value(ma, "sco_sink", NULL), PA_NAMEREG_SINK))) {
-        pa_log("SCO sink not found");
-        goto fail;
-    }
-
-    if (pa_modargs_get_value(ma, "sco_source", NULL) &&
-        !(u->hsp.sco_source = pa_namereg_get(m->core, pa_modargs_get_value(ma, "sco_source", NULL), PA_NAMEREG_SOURCE))) {
-        pa_log("SCO source not found");
-        goto fail;
-    }
-
-    if (pa_modargs_get_sample_rate(ma, &u->sample_spec.rate) < 0) {
-        pa_log_error("Failed to get rate from module arguments");
-        goto fail;
-    }
-
-    channels = u->sample_spec.channels;
-    if (pa_modargs_get_value_u32(ma, "channels", &channels) < 0 ||
-        !pa_channels_valid(channels)) {
-        pa_log_error("Failed to get channels from module arguments");
-        goto fail;
-    }
-    u->sample_spec.channels = (uint8_t) channels;
-    u->requested_sample_spec = u->sample_spec;
-
-    address = pa_modargs_get_value(ma, "address", NULL);
-    path = pa_modargs_get_value(ma, "path", NULL);
-
-    if (!(u->discovery = pa_bluez4_discovery_get(m->core)))
-        goto fail;
-
-    if (!(device = find_device(u, address, path)))
-        goto fail;
-
-    u->device = device;
-
-    u->discovery_slot =
-        pa_hook_connect(pa_bluez4_discovery_hook(u->discovery, PA_BLUEZ4_HOOK_DEVICE_CONNECTION_CHANGED),
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) discovery_hook_cb, u);
-
-    u->uuid_added_slot =
-        pa_hook_connect(pa_bluez4_discovery_hook(u->discovery, PA_BLUEZ4_HOOK_DEVICE_UUID_ADDED),
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) uuid_added_cb, u);
-
-    u->sink_state_changed_slot =
-        pa_hook_connect(&u->core->hooks[PA_CORE_HOOK_SINK_STATE_CHANGED],
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) sink_state_changed_cb, u);
-
-    u->source_state_changed_slot =
-        pa_hook_connect(&u->core->hooks[PA_CORE_HOOK_SOURCE_STATE_CHANGED],
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) source_state_changed_cb, u);
-
-    u->transport_state_changed_slot =
-        pa_hook_connect(pa_bluez4_discovery_hook(u->discovery, PA_BLUEZ4_HOOK_TRANSPORT_STATE_CHANGED),
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) transport_state_changed_cb, u);
-
-    u->transport_nrec_changed_slot =
-        pa_hook_connect(pa_bluez4_discovery_hook(u->discovery, PA_BLUEZ4_HOOK_TRANSPORT_NREC_CHANGED),
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) transport_nrec_changed_cb, u);
-
-    u->transport_microphone_changed_slot =
-        pa_hook_connect(pa_bluez4_discovery_hook(u->discovery, PA_BLUEZ4_HOOK_TRANSPORT_MICROPHONE_GAIN_CHANGED),
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) transport_microphone_gain_changed_cb, u);
-
-    u->transport_speaker_changed_slot =
-        pa_hook_connect(pa_bluez4_discovery_hook(u->discovery, PA_BLUEZ4_HOOK_TRANSPORT_SPEAKER_GAIN_CHANGED),
-                        PA_HOOK_NORMAL, (pa_hook_cb_t) transport_speaker_gain_changed_cb, u);
-
-    /* Add the card structure. This will also initialize the default profile */
-    if (add_card(u) < 0)
-        goto fail;
-
-    if (!(u->msg = pa_msgobject_new(bluetooth_msg)))
-        goto fail;
-
-    u->msg->parent.process_msg = device_process_msg;
-    u->msg->card = u->card;
-
-    if (u->profile != PA_BLUEZ4_PROFILE_OFF)
-        if (init_profile(u) < 0)
-            goto off;
-
-    if (u->sink || u->source)
-        if (start_thread(u) < 0)
-            goto off;
-
-    return 0;
-
-off:
-    stop_thread(u);
-
-    pa_assert_se(pa_card_set_profile(u->card, pa_hashmap_get(u->card->profiles, "off"), false) >= 0);
-
-    return 0;
-
-fail:
-
-    pa__done(m);
-
-    return -1;
-}
-
-int pa__get_n_used(pa_module *m) {
-    struct userdata *u;
-
-    pa_assert(m);
-    pa_assert_se(u = m->userdata);
-
-    return
-        (u->sink ? pa_sink_linked_by(u->sink) : 0) +
-        (u->source ? pa_source_linked_by(u->source) : 0);
-}
-
-void pa__done(pa_module *m) {
-    struct userdata *u;
-
-    pa_assert(m);
-
-    if (!(u = m->userdata))
-        return;
-
-    stop_thread(u);
-
-    if (u->discovery_slot)
-        pa_hook_slot_free(u->discovery_slot);
-
-    if (u->uuid_added_slot)
-        pa_hook_slot_free(u->uuid_added_slot);
-
-    if (u->sink_state_changed_slot)
-        pa_hook_slot_free(u->sink_state_changed_slot);
-
-    if (u->source_state_changed_slot)
-        pa_hook_slot_free(u->source_state_changed_slot);
-
-    if (u->transport_state_changed_slot)
-        pa_hook_slot_free(u->transport_state_changed_slot);
-
-    if (u->transport_nrec_changed_slot)
-        pa_hook_slot_free(u->transport_nrec_changed_slot);
-
-    if (u->transport_microphone_changed_slot)
-        pa_hook_slot_free(u->transport_microphone_changed_slot);
-
-    if (u->transport_speaker_changed_slot)
-        pa_hook_slot_free(u->transport_speaker_changed_slot);
-
-    if (USE_SCO_OVER_PCM(u))
-        restore_sco_volume_callbacks(u);
-
-    if (u->msg)
-        pa_xfree(u->msg);
-
-    if (u->card)
-        pa_card_free(u->card);
-
-    if (u->a2dp.buffer)
-        pa_xfree(u->a2dp.buffer);
-
-    sbc_finish(&u->a2dp.sbc);
-
-    if (u->modargs)
-        pa_modargs_free(u->modargs);
-
-    pa_xfree(u->output_port_name);
-    pa_xfree(u->input_port_name);
-
-    pa_xfree(u->address);
-    pa_xfree(u->path);
-
-    if (u->discovery)
-        pa_bluez4_discovery_unref(u->discovery);
-
-    pa_xfree(u);
-}
diff --git a/src/modules/bluetooth/module-bluez4-discover.c b/src/modules/bluetooth/module-bluez4-discover.c
deleted file mode 100644
index 2813cd5..0000000
--- a/src/modules/bluetooth/module-bluez4-discover.c
+++ /dev/null
@@ -1,187 +0,0 @@
-/***
-  This file is part of PulseAudio.
-
-  Copyright 2008-2013 João Paulo Rechi Vita
-
-  PulseAudio is free software; you can redistribute it and/or modify
-  it under the terms of the GNU Lesser General Public License as
-  published by the Free Software Foundation; either version 2.1 of the
-  License, or (at your option) any later version.
-
-  PulseAudio is distributed in the hope that it will be useful, but
-  WITHOUT ANY WARRANTY; without even the implied warranty of
-  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
-  General Public License for more details.
-
-  You should have received a copy of the GNU Lesser General Public
-  License along with PulseAudio; if not, see <http://www.gnu.org/licenses/>.
-***/
-
-#ifdef HAVE_CONFIG_H
-#include <config.h>
-#endif
-
-#include <stdio.h>
-#include <stdlib.h>
-
-#include <pulse/xmalloc.h>
-#include <pulsecore/module.h>
-#include <pulsecore/core-util.h>
-#include <pulsecore/modargs.h>
-#include <pulsecore/macro.h>
-#include <pulsecore/core-util.h>
-#include <pulsecore/dbus-shared.h>
-
-#include "bluez4-util.h"
-
-PA_MODULE_AUTHOR("João Paulo Rechi Vita");
-PA_MODULE_DESCRIPTION("Detect available BlueZ 4 Bluetooth audio devices and load BlueZ 4 Bluetooth audio drivers");
-PA_MODULE_VERSION(PACKAGE_VERSION);
-PA_MODULE_USAGE("sco_sink=<name of sink> "
-                "sco_source=<name of source> ");
-PA_MODULE_LOAD_ONCE(true);
-
-static const char* const valid_modargs[] = {
-    "sco_sink",
-    "sco_source",
-    "async", /* deprecated */
-    NULL
-};
-
-struct userdata {
-    pa_module *module;
-    pa_modargs *modargs;
-    pa_core *core;
-    pa_bluez4_discovery *discovery;
-    pa_hook_slot *slot;
-    pa_hashmap *hashmap;
-};
-
-struct pa_module_info {
-    char *path;
-    uint32_t module;
-};
-
-static pa_hook_result_t load_module_for_device(pa_bluez4_discovery *y, const pa_bluez4_device *d, struct userdata *u) {
-    struct pa_module_info *mi;
-
-    pa_assert(u);
-    pa_assert(d);
-
-    mi = pa_hashmap_get(u->hashmap, d->path);
-
-    if (pa_bluez4_device_any_audio_connected(d)) {
-
-        if (!mi) {
-            pa_module *m = NULL;
-            char *args;
-
-            /* Oh, awesome, a new device has shown up and been connected! */
-
-            args = pa_sprintf_malloc("address=\"%s\" path=\"%s\"", d->address, d->path);
-
-            if (pa_modargs_get_value(u->modargs, "sco_sink", NULL) &&
-                pa_modargs_get_value(u->modargs, "sco_source", NULL)) {
-                char *tmp;
-
-                tmp = pa_sprintf_malloc("%s sco_sink=\"%s\" sco_source=\"%s\"", args,
-                                        pa_modargs_get_value(u->modargs, "sco_sink", NULL),
-                                        pa_modargs_get_value(u->modargs, "sco_source", NULL));
-                pa_xfree(args);
-                args = tmp;
-            }
-
-            pa_log_debug("Loading module-bluez4-device %s", args);
-            pa_module_load(&m, u->module->core, "module-bluez4-device", args);
-            pa_xfree(args);
-
-            if (m) {
-                mi = pa_xnew(struct pa_module_info, 1);
-                mi->module = m->index;
-                mi->path = pa_xstrdup(d->path);
-
-                pa_hashmap_put(u->hashmap, mi->path, mi);
-            } else
-                pa_log_debug("Failed to load module for device %s", d->path);
-        }
-
-    } else {
-
-        if (mi) {
-
-            /* Hmm, disconnection? Then the module unloads itself */
-
-            pa_log_debug("Unregistering module for %s", d->path);
-            pa_hashmap_remove(u->hashmap, mi->path);
-            pa_xfree(mi->path);
-            pa_xfree(mi);
-        }
-    }
-
-    return PA_HOOK_OK;
-}
-
-int pa__init(pa_module* m) {
-    struct userdata *u;
-    pa_modargs *ma;
-
-    pa_assert(m);
-
-    if (!(ma = pa_modargs_new(m->argument, valid_modargs))) {
-        pa_log("Failed to parse module arguments");
-        goto fail;
-    }
-
-    if (pa_modargs_get_value(ma, "async", NULL))
-        pa_log_warn("The 'async' argument is deprecated and does nothing.");
-
-    m->userdata = u = pa_xnew0(struct userdata, 1);
-    u->module = m;
-    u->core = m->core;
-    u->modargs = ma;
-    u->hashmap = pa_hashmap_new(pa_idxset_string_hash_func, pa_idxset_string_compare_func);
-
-    if (!(u->discovery = pa_bluez4_discovery_get(u->core)))
-        goto fail;
-
-    u->slot = pa_hook_connect(pa_bluez4_discovery_hook(u->discovery, PA_BLUEZ4_HOOK_DEVICE_CONNECTION_CHANGED),
-                              PA_HOOK_NORMAL, (pa_hook_cb_t) load_module_for_device, u);
-
-    return 0;
-
-fail:
-    pa__done(m);
-
-    return -1;
-}
-
-void pa__done(pa_module* m) {
-    struct userdata *u;
-
-    pa_assert(m);
-
-    if (!(u = m->userdata))
-        return;
-
-    if (u->slot)
-        pa_hook_slot_free(u->slot);
-
-    if (u->discovery)
-        pa_bluez4_discovery_unref(u->discovery);
-
-    if (u->hashmap) {
-        struct pa_module_info *mi;
-
-        while ((mi = pa_hashmap_steal_first(u->hashmap))) {
-            pa_xfree(mi->path);
-            pa_xfree(mi);
-        }
-
-        pa_hashmap_free(u->hashmap);
-    }
-
-    if (u->modargs)
-        pa_modargs_free(u->modargs);
-
-    pa_xfree(u);
-}
diff --git a/src/modules/bluetooth/module-bluez5-device.c b/src/modules/bluetooth/module-bluez5-device.c
index 2a36adf..fdde77b 100644
--- a/src/modules/bluetooth/module-bluez5-device.c
+++ b/src/modules/bluetooth/module-bluez5-device.c
@@ -3,6 +3,7 @@
 
   Copyright 2008-2013 João Paulo Rechi Vita
   Copyright 2011-2013 BMW Car IT GmbH.
+  Copyright 2018-2019 Pali Rohár <pali.rohar@gmail.com>
 
   PulseAudio is free software; you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as
@@ -25,7 +26,6 @@
 #include <errno.h>
 
 #include <arpa/inet.h>
-#include <sbc/sbc.h>
 
 #include <pulse/rtclock.h>
 #include <pulse/timeval.h>
@@ -46,8 +46,8 @@
 #include <pulsecore/time-smoother.h>
 
 #include "a2dp-codecs.h"
+#include "a2dp-codec-util.h"
 #include "bluez5-util.h"
-#include "rtp.h"
 
 PA_MODULE_AUTHOR("João Paulo Rechi Vita");
 PA_MODULE_DESCRIPTION("BlueZ 5 Bluetooth audio sink and source");
@@ -61,8 +61,6 @@ PA_MODULE_USAGE("path=<device object path>"
 #define FIXED_LATENCY_RECORD_A2DP   (25 * PA_USEC_PER_MSEC)
 #define FIXED_LATENCY_RECORD_SCO    (25 * PA_USEC_PER_MSEC)
 
-#define BITPOOL_DEC_LIMIT 32
-#define BITPOOL_DEC_STEP 5
 #define HSP_MAX_GAIN 15
 
 static const char* const valid_modargs[] = {
@@ -93,18 +91,6 @@ typedef struct bluetooth_msg {
 PA_DEFINE_PRIVATE_CLASS(bluetooth_msg, pa_msgobject);
 #define BLUETOOTH_MSG(o) (bluetooth_msg_cast(o))
 
-typedef struct sbc_info {
-    sbc_t sbc;                           /* Codec data */
-    bool sbc_initialized;                /* Keep track if the encoder is initialized */
-    size_t codesize, frame_length;       /* SBC Codesize, frame_length. We simply cache those values here */
-    uint16_t seq_num;                    /* Cumulative packet sequence */
-    uint8_t min_bitpool;
-    uint8_t max_bitpool;
-
-    void* buffer;                        /* Codec transfer buffer */
-    size_t buffer_size;                  /* Size of the buffer */
-} sbc_info_t;
-
 struct userdata {
     pa_module *module;
     pa_core *core;
@@ -144,8 +130,18 @@ struct userdata {
     pa_usec_t started_at;
     pa_smoother *read_smoother;
     pa_memchunk write_memchunk;
-    pa_sample_spec sample_spec;
-    struct sbc_info sbc_info;
+
+    const pa_a2dp_codec *a2dp_codec;
+
+    void *encoder_info;
+    pa_sample_spec encoder_sample_spec;
+    void *encoder_buffer;                        /* Codec transfer buffer */
+    size_t encoder_buffer_size;                  /* Size of the buffer */
+
+    void *decoder_info;
+    pa_sample_spec decoder_sample_spec;
+    void *decoder_buffer;                        /* Codec transfer buffer */
+    size_t decoder_buffer_size;                  /* Size of the buffer */
 };
 
 typedef enum pa_bluetooth_form_factor {
@@ -379,7 +375,7 @@ static int sco_process_push(struct userdata *u) {
      * issues in our Bluetooth adapter. In these cases, in order to avoid
      * an assertion failure due to unaligned data, just discard the whole
      * packet */
-    if (!pa_frame_aligned(l, &u->sample_spec)) {
+    if (!pa_frame_aligned(l, &u->decoder_sample_spec)) {
         pa_log_warn("SCO packet received of unaligned size: %zu", l);
         pa_memblock_unref(memchunk.memblock);
         return -1;
@@ -402,7 +398,7 @@ static int sco_process_push(struct userdata *u) {
         tstamp = pa_rtclock_now();
     }
 
-    pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->sample_spec));
+    pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->decoder_sample_spec));
     pa_smoother_resume(u->read_smoother, tstamp, true);
 
     pa_source_post(u->source, &memchunk);
@@ -412,110 +408,52 @@ static int sco_process_push(struct userdata *u) {
 }
 
 /* Run from IO thread */
-static void a2dp_prepare_buffer(struct userdata *u) {
-    size_t min_buffer_size = PA_MAX(u->read_link_mtu, u->write_link_mtu);
-
+static void a2dp_prepare_encoder_buffer(struct userdata *u) {
     pa_assert(u);
 
-    if (u->sbc_info.buffer_size >= min_buffer_size)
-        return;
+    if (u->encoder_buffer_size < u->write_link_mtu) {
+        pa_xfree(u->encoder_buffer);
+        u->encoder_buffer = pa_xmalloc(u->write_link_mtu);
+    }
 
-    u->sbc_info.buffer_size = 2 * min_buffer_size;
-    pa_xfree(u->sbc_info.buffer);
-    u->sbc_info.buffer = pa_xmalloc(u->sbc_info.buffer_size);
+    /* Encoder buffer cannot be larger then link MTU, otherwise
+     * encode method would produce larger packets then link MTU */
+    u->encoder_buffer_size = u->write_link_mtu;
 }
 
 /* Run from IO thread */
-static int a2dp_process_render(struct userdata *u) {
-    struct sbc_info *sbc_info;
-    struct rtp_header *header;
-    struct rtp_payload *payload;
-    size_t nbytes;
-    void *d;
-    const void *p;
-    size_t to_write, to_encode;
-    unsigned frame_count;
-    int ret = 0;
-
+static void a2dp_prepare_decoder_buffer(struct userdata *u) {
     pa_assert(u);
-    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK);
-    pa_assert(u->sink);
-
-    /* First, render some data */
-    if (!u->write_memchunk.memblock)
-        pa_sink_render_full(u->sink, u->write_block_size, &u->write_memchunk);
-
-    pa_assert(u->write_memchunk.length == u->write_block_size);
-
-    a2dp_prepare_buffer(u);
-
-    sbc_info = &u->sbc_info;
-    header = sbc_info->buffer;
-    payload = (struct rtp_payload*) ((uint8_t*) sbc_info->buffer + sizeof(*header));
-
-    frame_count = 0;
-
-    /* Try to create a packet of the full MTU */
-
-    p = (const uint8_t *) pa_memblock_acquire_chunk(&u->write_memchunk);
-    to_encode = u->write_memchunk.length;
-
-    d = (uint8_t*) sbc_info->buffer + sizeof(*header) + sizeof(*payload);
-    to_write = sbc_info->buffer_size - sizeof(*header) - sizeof(*payload);
 
-    while (PA_LIKELY(to_encode > 0 && to_write > 0)) {
-        ssize_t written;
-        ssize_t encoded;
-
-        encoded = sbc_encode(&sbc_info->sbc,
-                             p, to_encode,
-                             d, to_write,
-                             &written);
-
-        if (PA_UNLIKELY(encoded <= 0)) {
-            pa_log_error("SBC encoding error (%li)", (long) encoded);
-            pa_memblock_release(u->write_memchunk.memblock);
-            return -1;
-        }
-
-        pa_assert_fp((size_t) encoded <= to_encode);
-        pa_assert_fp((size_t) encoded == sbc_info->codesize);
-
-        pa_assert_fp((size_t) written <= to_write);
-        pa_assert_fp((size_t) written == sbc_info->frame_length);
-
-        p = (const uint8_t*) p + encoded;
-        to_encode -= encoded;
-
-        d = (uint8_t*) d + written;
-        to_write -= written;
-
-        frame_count++;
+    if (u->decoder_buffer_size < u->read_link_mtu) {
+        pa_xfree(u->decoder_buffer);
+        u->decoder_buffer = pa_xmalloc(u->read_link_mtu);
     }
 
-    pa_memblock_release(u->write_memchunk.memblock);
-
-    pa_assert(to_encode == 0);
-
-    PA_ONCE_BEGIN {
-        pa_log_debug("Using SBC encoder implementation: %s", pa_strnull(sbc_get_implementation_info(&sbc_info->sbc)));
-    } PA_ONCE_END;
+    /* Decoder buffer cannot be larger then link MTU, otherwise
+     * decode method would produce larger output then read_block_size */
+    u->decoder_buffer_size = u->read_link_mtu;
+}
 
-    /* write it to the fifo */
-    memset(sbc_info->buffer, 0, sizeof(*header) + sizeof(*payload));
-    header->v = 2;
-    header->pt = 1;
-    header->sequence_number = htons(sbc_info->seq_num++);
-    header->timestamp = htonl(u->write_index / pa_frame_size(&u->sample_spec));
-    header->ssrc = htonl(1);
-    payload->frame_count = frame_count;
+/* Run from IO thread */
+static int a2dp_write_buffer(struct userdata *u, size_t nbytes) {
+    int ret = 0;
 
-    nbytes = (uint8_t*) d - (uint8_t*) sbc_info->buffer;
+    /* Encoder function of A2DP codec may provide empty buffer, in this case do
+     * not post any empty buffer via A2DP socket. It may be because of codec
+     * internal state, e.g. encoder is waiting for more samples so it can
+     * provide encoded data. */
+    if (PA_UNLIKELY(!nbytes)) {
+        u->write_index += (uint64_t) u->write_memchunk.length;
+        pa_memblock_unref(u->write_memchunk.memblock);
+        pa_memchunk_reset(&u->write_memchunk);
+        return 0;
+    }
 
     for (;;) {
         ssize_t l;
 
-        l = pa_write(u->stream_fd, sbc_info->buffer, nbytes, &u->stream_write_type);
+        l = pa_write(u->stream_fd, u->encoder_buffer, nbytes, &u->stream_write_type);
 
         pa_assert(l != 0);
 
@@ -558,6 +496,40 @@ static int a2dp_process_render(struct userdata *u) {
     return ret;
 }
 
+/* Run from IO thread */
+static int a2dp_process_render(struct userdata *u) {
+    const uint8_t *ptr;
+    size_t processed;
+    size_t length;
+
+    pa_assert(u);
+    pa_assert(u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK);
+    pa_assert(u->sink);
+    pa_assert(u->a2dp_codec);
+
+    /* First, render some data */
+    if (!u->write_memchunk.memblock)
+        pa_sink_render_full(u->sink, u->write_block_size, &u->write_memchunk);
+
+    pa_assert(u->write_memchunk.length == u->write_block_size);
+
+    a2dp_prepare_encoder_buffer(u);
+
+    /* Try to create a packet of the full MTU */
+    ptr = (const uint8_t *) pa_memblock_acquire_chunk(&u->write_memchunk);
+
+    length = u->a2dp_codec->encode_buffer(u->encoder_info, u->write_index / pa_frame_size(&u->encoder_sample_spec), ptr, u->write_memchunk.length, u->encoder_buffer, u->encoder_buffer_size, &processed);
+
+    pa_memblock_release(u->write_memchunk.memblock);
+
+    if (processed != u->write_memchunk.length) {
+        pa_log_error("Encoding error");
+        return -1;
+    }
+
+    return a2dp_write_buffer(u, length);
+}
+
 /* Run from IO thread */
 static int a2dp_process_push(struct userdata *u) {
     int ret = 0;
@@ -567,29 +539,21 @@ static int a2dp_process_push(struct userdata *u) {
     pa_assert(u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE);
     pa_assert(u->source);
     pa_assert(u->read_smoother);
+    pa_assert(u->a2dp_codec);
 
     memchunk.memblock = pa_memblock_new(u->core->mempool, u->read_block_size);
     memchunk.index = memchunk.length = 0;
 
+    a2dp_prepare_decoder_buffer(u);
+
     for (;;) {
         bool found_tstamp = false;
         pa_usec_t tstamp;
-        struct sbc_info *sbc_info;
-        struct rtp_header *header;
-        struct rtp_payload *payload;
-        const void *p;
-        void *d;
+        uint8_t *ptr;
         ssize_t l;
-        size_t to_write, to_decode;
-        size_t total_written = 0;
+        size_t processed;
 
-        a2dp_prepare_buffer(u);
-
-        sbc_info = &u->sbc_info;
-        header = sbc_info->buffer;
-        payload = (struct rtp_payload*) ((uint8_t*) sbc_info->buffer + sizeof(*header));
-
-        l = pa_read(u->stream_fd, sbc_info->buffer, sbc_info->buffer_size, &u->stream_write_type);
+        l = pa_read(u->stream_fd, u->decoder_buffer, u->decoder_buffer_size, &u->stream_write_type);
 
         if (l <= 0) {
 
@@ -606,7 +570,7 @@ static int a2dp_process_push(struct userdata *u) {
             break;
         }
 
-        pa_assert((size_t) l <= sbc_info->buffer_size);
+        pa_assert((size_t) l <= u->decoder_buffer_size);
 
         /* TODO: get timestamp from rtp */
         if (!found_tstamp) {
@@ -614,54 +578,28 @@ static int a2dp_process_push(struct userdata *u) {
             tstamp = pa_rtclock_now();
         }
 
-        p = (uint8_t*) sbc_info->buffer + sizeof(*header) + sizeof(*payload);
-        to_decode = l - sizeof(*header) - sizeof(*payload);
-
-        d = pa_memblock_acquire(memchunk.memblock);
-        to_write = memchunk.length = pa_memblock_get_length(memchunk.memblock);
+        ptr = pa_memblock_acquire(memchunk.memblock);
+        memchunk.length = pa_memblock_get_length(memchunk.memblock);
 
-        while (PA_LIKELY(to_decode > 0)) {
-            size_t written;
-            ssize_t decoded;
-
-            decoded = sbc_decode(&sbc_info->sbc,
-                                 p, to_decode,
-                                 d, to_write,
-                                 &written);
-
-            if (PA_UNLIKELY(decoded <= 0)) {
-                pa_log_error("SBC decoding error (%li)", (long) decoded);
-                pa_memblock_release(memchunk.memblock);
-                pa_memblock_unref(memchunk.memblock);
-                return 0;
-            }
+        memchunk.length = u->a2dp_codec->decode_buffer(u->decoder_info, u->decoder_buffer, l, ptr, memchunk.length, &processed);
 
-            total_written += written;
-
-            /* Reset frame length, it can be changed due to bitpool change */
-            sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
-
-            pa_assert_fp((size_t) decoded <= to_decode);
-            pa_assert_fp((size_t) decoded == sbc_info->frame_length);
-
-            pa_assert_fp((size_t) written == sbc_info->codesize);
-
-            p = (const uint8_t*) p + decoded;
-            to_decode -= decoded;
+        pa_memblock_release(memchunk.memblock);
 
-            d = (uint8_t*) d + written;
-            to_write -= written;
+        if (processed != (size_t) l) {
+            pa_log_error("Decoding error");
+            ret = -1;
+            break;
         }
 
-        u->read_index += (uint64_t) total_written;
-        pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->sample_spec));
+        u->read_index += (uint64_t) memchunk.length;
+        pa_smoother_put(u->read_smoother, tstamp, pa_bytes_to_usec(u->read_index, &u->decoder_sample_spec));
         pa_smoother_resume(u->read_smoother, tstamp, true);
 
-        memchunk.length -= to_write;
-
-        pa_memblock_release(memchunk.memblock);
-
-        pa_source_post(u->source, &memchunk);
+        /* Decoding of A2DP codec data may result in empty buffer, in this case
+         * do not post empty audio samples. It may happen due to algorithmic
+         * delay of audio codec. */
+        if (PA_LIKELY(memchunk.length))
+            pa_source_post(u->source, &memchunk);
 
         ret = l;
         break;
@@ -672,7 +610,7 @@ static int a2dp_process_push(struct userdata *u) {
     return ret;
 }
 
-static void update_buffer_size(struct userdata *u) {
+static void update_sink_buffer_size(struct userdata *u) {
     int old_bufsize;
     socklen_t len = sizeof(int);
     int ret;
@@ -704,72 +642,6 @@ static void update_buffer_size(struct userdata *u) {
     }
 }
 
-/* Run from I/O thread */
-static void a2dp_set_bitpool(struct userdata *u, uint8_t bitpool) {
-    struct sbc_info *sbc_info;
-
-    pa_assert(u);
-
-    sbc_info = &u->sbc_info;
-
-    if (sbc_info->sbc.bitpool == bitpool)
-        return;
-
-    if (bitpool > sbc_info->max_bitpool)
-        bitpool = sbc_info->max_bitpool;
-    else if (bitpool < sbc_info->min_bitpool)
-        bitpool = sbc_info->min_bitpool;
-
-    sbc_info->sbc.bitpool = bitpool;
-
-    sbc_info->codesize = sbc_get_codesize(&sbc_info->sbc);
-    sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
-
-    pa_log_debug("Bitpool has changed to %u", sbc_info->sbc.bitpool);
-
-    u->read_block_size =
-        (u->read_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-        / sbc_info->frame_length * sbc_info->codesize;
-
-    u->write_block_size =
-        (u->write_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-        / sbc_info->frame_length * sbc_info->codesize;
-
-    pa_sink_set_max_request_within_thread(u->sink, u->write_block_size);
-    pa_sink_set_fixed_latency_within_thread(u->sink,
-            FIXED_LATENCY_PLAYBACK_A2DP + pa_bytes_to_usec(u->write_block_size, &u->sample_spec));
-
-    /* If there is still data in the memchunk, we have to discard it
-     * because the write_block_size may have changed. */
-    if (u->write_memchunk.memblock) {
-        pa_memblock_unref(u->write_memchunk.memblock);
-        pa_memchunk_reset(&u->write_memchunk);
-    }
-
-    update_buffer_size(u);
-}
-
-/* Run from I/O thread */
-static void a2dp_reduce_bitpool(struct userdata *u) {
-    struct sbc_info *sbc_info;
-    uint8_t bitpool;
-
-    pa_assert(u);
-
-    sbc_info = &u->sbc_info;
-
-    /* Check if bitpool is already at its limit */
-    if (sbc_info->sbc.bitpool <= BITPOOL_DEC_LIMIT)
-        return;
-
-    bitpool = sbc_info->sbc.bitpool - BITPOOL_DEC_STEP;
-
-    if (bitpool < BITPOOL_DEC_LIMIT)
-        bitpool = BITPOOL_DEC_LIMIT;
-
-    a2dp_set_bitpool(u, bitpool);
-}
-
 static void teardown_stream(struct userdata *u) {
     if (u->rtpoll_item) {
         pa_rtpoll_item_free(u->rtpoll_item);
@@ -843,6 +715,24 @@ static void transport_release(struct userdata *u) {
         pa_asyncmsgq_post(pa_thread_mq_get()->outq, PA_MSGOBJECT(u->msg), BLUETOOTH_MESSAGE_STREAM_FD_HUP, NULL, 0, NULL, NULL);
 }
 
+/* Run from I/O thread */
+static void handle_sink_block_size_change(struct userdata *u) {
+    pa_sink_set_max_request_within_thread(u->sink, u->write_block_size);
+    pa_sink_set_fixed_latency_within_thread(u->sink,
+                                            (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK ?
+                                             FIXED_LATENCY_PLAYBACK_A2DP : FIXED_LATENCY_PLAYBACK_SCO) +
+                                            pa_bytes_to_usec(u->write_block_size, &u->encoder_sample_spec));
+
+    /* If there is still data in the memchunk, we have to discard it
+     * because the write_block_size may have changed. */
+    if (u->write_memchunk.memblock) {
+        pa_memblock_unref(u->write_memchunk.memblock);
+        pa_memchunk_reset(&u->write_memchunk);
+    }
+
+    update_sink_buffer_size(u);
+}
+
 /* Run from I/O thread */
 static void transport_config_mtu(struct userdata *u) {
     if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
@@ -859,41 +749,47 @@ static void transport_config_mtu(struct userdata *u) {
             u->write_block_size = pa_frame_align(u->write_block_size, &u->sink->sample_spec);
         }
     } else {
-        u->read_block_size =
-            (u->read_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-            / u->sbc_info.frame_length * u->sbc_info.codesize;
-
-        u->write_block_size =
-            (u->write_link_mtu - sizeof(struct rtp_header) - sizeof(struct rtp_payload))
-            / u->sbc_info.frame_length * u->sbc_info.codesize;
+        pa_assert(u->a2dp_codec);
+        if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
+            u->write_block_size = u->a2dp_codec->get_write_block_size(u->encoder_info, u->write_link_mtu);
+        } else {
+            u->read_block_size = u->a2dp_codec->get_read_block_size(u->decoder_info, u->read_link_mtu);
+        }
     }
 
-    if (u->sink) {
-        pa_sink_set_max_request_within_thread(u->sink, u->write_block_size);
-        pa_sink_set_fixed_latency_within_thread(u->sink,
-                                                (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK ?
-                                                 FIXED_LATENCY_PLAYBACK_A2DP : FIXED_LATENCY_PLAYBACK_SCO) +
-                                                pa_bytes_to_usec(u->write_block_size, &u->sample_spec));
-    }
+    if (u->sink)
+        handle_sink_block_size_change(u);
 
     if (u->source)
         pa_source_set_fixed_latency_within_thread(u->source,
                                                   (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE ?
                                                    FIXED_LATENCY_RECORD_A2DP : FIXED_LATENCY_RECORD_SCO) +
-                                                  pa_bytes_to_usec(u->read_block_size, &u->sample_spec));
+                                                  pa_bytes_to_usec(u->read_block_size, &u->decoder_sample_spec));
 }
 
 /* Run from I/O thread */
-static void setup_stream(struct userdata *u) {
+static int setup_stream(struct userdata *u) {
     struct pollfd *pollfd;
     int one;
 
+    pa_assert(u->stream_fd >= 0);
+
     /* return if stream is already set up */
     if (u->stream_setup_done)
-        return;
+        return 0;
 
     pa_log_info("Transport %s resuming", u->transport->path);
 
+    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
+        pa_assert(u->a2dp_codec);
+        if (u->a2dp_codec->reset(u->encoder_info) < 0)
+            return -1;
+    } else if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE) {
+        pa_assert(u->a2dp_codec);
+        if (u->a2dp_codec->reset(u->decoder_info) < 0)
+            return -1;
+    }
+
     transport_config_mtu(u);
 
     pa_make_fd_nonblock(u->stream_fd);
@@ -905,11 +801,6 @@ static void setup_stream(struct userdata *u) {
 
     pa_log_debug("Stream properly set up, we're ready to roll!");
 
-    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
-        a2dp_set_bitpool(u, u->sbc_info.max_bitpool);
-        update_buffer_size(u);
-    }
-
     u->rtpoll_item = pa_rtpoll_item_new(u->rtpoll, PA_RTPOLL_NEVER, 1);
     pollfd = pa_rtpoll_item_get_pollfd(u->rtpoll_item, NULL);
     pollfd->fd = u->stream_fd;
@@ -921,6 +812,8 @@ static void setup_stream(struct userdata *u) {
 
     if (u->source)
         u->read_smoother = pa_smoother_new(PA_USEC_PER_SEC, 2*PA_USEC_PER_SEC, true, true, 10, pa_rtclock_now(), true);
+
+    return 0;
 }
 
 /* Called from I/O thread, returns true if the transport was acquired or
@@ -932,8 +825,10 @@ static bool setup_transport_and_stream(struct userdata *u) {
     if (transport_error < 0) {
         if (transport_error != -EAGAIN)
             return false;
-    } else
-        setup_stream(u);
+    } else {
+        if (setup_stream(u) < 0)
+            return false;
+    }
     return true;
 }
 
@@ -951,7 +846,7 @@ static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t off
 
             if (u->read_smoother) {
                 wi = pa_smoother_get(u->read_smoother, pa_rtclock_now());
-                ri = pa_bytes_to_usec(u->read_index, &u->sample_spec);
+                ri = pa_bytes_to_usec(u->read_index, &u->decoder_sample_spec);
 
                 *((int64_t*) data) = u->source->thread_info.fixed_latency + wi - ri;
             } else
@@ -961,7 +856,17 @@ static int source_process_msg(pa_msgobject *o, int code, void *data, int64_t off
         }
 
         case PA_SOURCE_MESSAGE_SETUP_STREAM:
-            setup_stream(u);
+            /* Skip stream setup if stream_fd has been invalidated.
+               This can occur if the stream has already been set up and
+               then immediately received POLLHUP. If the stream has
+               already been set up earlier, then this setup_stream()
+               call is redundant anyway, but currently the code
+               is such that this kind of unnecessary setup_stream()
+               calls can happen. */
+            if (u->stream_fd < 0)
+                pa_log_debug("Skip source stream setup while closing");
+            else
+                setup_stream(u);
             return 0;
 
     }
@@ -980,7 +885,7 @@ static int source_set_state_in_io_thread_cb(pa_source *s, pa_source_state_t new_
 
         case PA_SOURCE_SUSPENDED:
             /* Ignore if transition is PA_SOURCE_INIT->PA_SOURCE_SUSPENDED */
-            if (!PA_SOURCE_IS_OPENED(u->source->thread_info.state))
+            if (!PA_SOURCE_IS_OPENED(s->thread_info.state))
                 break;
 
             /* Stop the device if the sink is suspended as well */
@@ -994,7 +899,7 @@ static int source_set_state_in_io_thread_cb(pa_source *s, pa_source_state_t new_
 
         case PA_SOURCE_IDLE:
         case PA_SOURCE_RUNNING:
-            if (u->source->thread_info.state != PA_SOURCE_SUSPENDED)
+            if (s->thread_info.state != PA_SOURCE_SUSPENDED)
                 break;
 
             /* Resume the device if the sink was suspended as well */
@@ -1044,11 +949,11 @@ static void source_set_volume_cb(pa_source *s) {
     if (volume < PA_VOLUME_NORM)
         volume++;
 
-    pa_cvolume_set(&s->real_volume, u->sample_spec.channels, volume);
+    pa_cvolume_set(&s->real_volume, u->decoder_sample_spec.channels, volume);
 
     /* Set soft volume when in headset role */
     if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
-        pa_cvolume_set(&s->soft_volume, u->sample_spec.channels, volume);
+        pa_cvolume_set(&s->soft_volume, u->decoder_sample_spec.channels, volume);
 
     /* If we are in the AG role, we send a command to the head set to change
      * the microphone gain. In the HS role, source and sink are swapped, so
@@ -1069,7 +974,7 @@ static int add_source(struct userdata *u) {
     data.name = pa_sprintf_malloc("bluez_source.%s.%s", u->device->address, pa_bluetooth_profile_to_string(u->profile));
     data.namereg_fail = false;
     pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluetooth_profile_to_string(u->profile));
-    pa_source_new_data_set_sample_spec(&data, &u->sample_spec);
+    pa_source_new_data_set_sample_spec(&data, &u->decoder_sample_spec);
     if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
         pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
 
@@ -1127,10 +1032,10 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
 
             if (u->read_smoother) {
                 ri = pa_smoother_get(u->read_smoother, pa_rtclock_now());
-                wi = pa_bytes_to_usec(u->write_index + u->write_block_size, &u->sample_spec);
+                wi = pa_bytes_to_usec(u->write_index + u->write_block_size, &u->encoder_sample_spec);
             } else if (u->started_at) {
                 ri = pa_rtclock_now() - u->started_at;
-                wi = pa_bytes_to_usec(u->write_index, &u->sample_spec);
+                wi = pa_bytes_to_usec(u->write_index, &u->encoder_sample_spec);
             }
 
             *((int64_t*) data) = u->sink->thread_info.fixed_latency + wi - ri;
@@ -1139,7 +1044,17 @@ static int sink_process_msg(pa_msgobject *o, int code, void *data, int64_t offse
         }
 
         case PA_SINK_MESSAGE_SETUP_STREAM:
-            setup_stream(u);
+            /* Skip stream setup if stream_fd has been invalidated.
+               This can occur if the stream has already been set up and
+               then immediately received POLLHUP. If the stream has
+               already been set up earlier, then this setup_stream()
+               call is redundant anyway, but currently the code
+               is such that this kind of unnecessary setup_stream()
+               calls can happen. */
+            if (u->stream_fd < 0)
+                pa_log_debug("Skip sink stream setup while closing");
+            else
+                setup_stream(u);
             return 0;
     }
 
@@ -1157,7 +1072,7 @@ static int sink_set_state_in_io_thread_cb(pa_sink *s, pa_sink_state_t new_state,
 
         case PA_SINK_SUSPENDED:
             /* Ignore if transition is PA_SINK_INIT->PA_SINK_SUSPENDED */
-            if (!PA_SINK_IS_OPENED(u->sink->thread_info.state))
+            if (!PA_SINK_IS_OPENED(s->thread_info.state))
                 break;
 
             /* Stop the device if the source is suspended as well */
@@ -1171,7 +1086,7 @@ static int sink_set_state_in_io_thread_cb(pa_sink *s, pa_sink_state_t new_state,
 
         case PA_SINK_IDLE:
         case PA_SINK_RUNNING:
-            if (u->sink->thread_info.state != PA_SINK_SUSPENDED)
+            if (s->thread_info.state != PA_SINK_SUSPENDED)
                 break;
 
             /* Resume the device if the source was suspended as well */
@@ -1218,11 +1133,11 @@ static void sink_set_volume_cb(pa_sink *s) {
     if (volume < PA_VOLUME_NORM)
         volume++;
 
-    pa_cvolume_set(&s->real_volume, u->sample_spec.channels, volume);
+    pa_cvolume_set(&s->real_volume, u->encoder_sample_spec.channels, volume);
 
     /* Set soft volume when in headset role */
     if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY)
-        pa_cvolume_set(&s->soft_volume, u->sample_spec.channels, volume);
+        pa_cvolume_set(&s->soft_volume, u->encoder_sample_spec.channels, volume);
 
     /* If we are in the AG role, we send a command to the head set to change
      * the speaker gain. In the HS role, source and sink are swapped, so
@@ -1243,7 +1158,7 @@ static int add_sink(struct userdata *u) {
     data.name = pa_sprintf_malloc("bluez_sink.%s.%s", u->device->address, pa_bluetooth_profile_to_string(u->profile));
     data.namereg_fail = false;
     pa_proplist_sets(data.proplist, "bluetooth.protocol", pa_bluetooth_profile_to_string(u->profile));
-    pa_sink_new_data_set_sample_spec(&data, &u->sample_spec);
+    pa_sink_new_data_set_sample_spec(&data, &u->encoder_sample_spec);
     if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
         pa_proplist_sets(data.proplist, PA_PROP_DEVICE_INTENDED_ROLES, "phone");
 
@@ -1289,117 +1204,38 @@ static int add_sink(struct userdata *u) {
 }
 
 /* Run from main thread */
-static void transport_config(struct userdata *u) {
+static int transport_config(struct userdata *u) {
     if (u->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT || u->profile == PA_BLUETOOTH_PROFILE_HEADSET_AUDIO_GATEWAY) {
-        u->sample_spec.format = PA_SAMPLE_S16LE;
-        u->sample_spec.channels = 1;
-        u->sample_spec.rate = 8000;
+        u->encoder_sample_spec.format = PA_SAMPLE_S16LE;
+        u->encoder_sample_spec.channels = 1;
+        u->encoder_sample_spec.rate = 8000;
+        u->decoder_sample_spec.format = PA_SAMPLE_S16LE;
+        u->decoder_sample_spec.channels = 1;
+        u->decoder_sample_spec.rate = 8000;
+        return 0;
     } else {
-        sbc_info_t *sbc_info = &u->sbc_info;
-        a2dp_sbc_t *config;
+        bool is_a2dp_sink = u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK;
+        void *info;
 
         pa_assert(u->transport);
 
-        u->sample_spec.format = PA_SAMPLE_S16LE;
-        config = (a2dp_sbc_t *) u->transport->config;
-
-        if (sbc_info->sbc_initialized)
-            sbc_reinit(&sbc_info->sbc, 0);
-        else
-            sbc_init(&sbc_info->sbc, 0);
-        sbc_info->sbc_initialized = true;
-
-        switch (config->frequency) {
-            case SBC_SAMPLING_FREQ_16000:
-                sbc_info->sbc.frequency = SBC_FREQ_16000;
-                u->sample_spec.rate = 16000U;
-                break;
-            case SBC_SAMPLING_FREQ_32000:
-                sbc_info->sbc.frequency = SBC_FREQ_32000;
-                u->sample_spec.rate = 32000U;
-                break;
-            case SBC_SAMPLING_FREQ_44100:
-                sbc_info->sbc.frequency = SBC_FREQ_44100;
-                u->sample_spec.rate = 44100U;
-                break;
-            case SBC_SAMPLING_FREQ_48000:
-                sbc_info->sbc.frequency = SBC_FREQ_48000;
-                u->sample_spec.rate = 48000U;
-                break;
-            default:
-                pa_assert_not_reached();
-        }
+        pa_assert(!u->a2dp_codec);
+        pa_assert(!u->encoder_info);
+        pa_assert(!u->decoder_info);
 
-        switch (config->channel_mode) {
-            case SBC_CHANNEL_MODE_MONO:
-                sbc_info->sbc.mode = SBC_MODE_MONO;
-                u->sample_spec.channels = 1;
-                break;
-            case SBC_CHANNEL_MODE_DUAL_CHANNEL:
-                sbc_info->sbc.mode = SBC_MODE_DUAL_CHANNEL;
-                u->sample_spec.channels = 2;
-                break;
-            case SBC_CHANNEL_MODE_STEREO:
-                sbc_info->sbc.mode = SBC_MODE_STEREO;
-                u->sample_spec.channels = 2;
-                break;
-            case SBC_CHANNEL_MODE_JOINT_STEREO:
-                sbc_info->sbc.mode = SBC_MODE_JOINT_STEREO;
-                u->sample_spec.channels = 2;
-                break;
-            default:
-                pa_assert_not_reached();
-        }
+        u->a2dp_codec = u->transport->a2dp_codec;
+        pa_assert(u->a2dp_codec);
 
-        switch (config->allocation_method) {
-            case SBC_ALLOCATION_SNR:
-                sbc_info->sbc.allocation = SBC_AM_SNR;
-                break;
-            case SBC_ALLOCATION_LOUDNESS:
-                sbc_info->sbc.allocation = SBC_AM_LOUDNESS;
-                break;
-            default:
-                pa_assert_not_reached();
-        }
-
-        switch (config->subbands) {
-            case SBC_SUBBANDS_4:
-                sbc_info->sbc.subbands = SBC_SB_4;
-                break;
-            case SBC_SUBBANDS_8:
-                sbc_info->sbc.subbands = SBC_SB_8;
-                break;
-            default:
-                pa_assert_not_reached();
-        }
-
-        switch (config->block_length) {
-            case SBC_BLOCK_LENGTH_4:
-                sbc_info->sbc.blocks = SBC_BLK_4;
-                break;
-            case SBC_BLOCK_LENGTH_8:
-                sbc_info->sbc.blocks = SBC_BLK_8;
-                break;
-            case SBC_BLOCK_LENGTH_12:
-                sbc_info->sbc.blocks = SBC_BLK_12;
-                break;
-            case SBC_BLOCK_LENGTH_16:
-                sbc_info->sbc.blocks = SBC_BLK_16;
-                break;
-            default:
-                pa_assert_not_reached();
-        }
-
-        sbc_info->min_bitpool = config->min_bitpool;
-        sbc_info->max_bitpool = config->max_bitpool;
+        info = u->a2dp_codec->init(is_a2dp_sink, false, u->transport->config, u->transport->config_size, is_a2dp_sink ? &u->encoder_sample_spec : &u->decoder_sample_spec);
+        if (is_a2dp_sink)
+            u->encoder_info = info;
+        else
+            u->decoder_info = info;
 
-        /* Set minimum bitpool for source to get the maximum possible block_size */
-        sbc_info->sbc.bitpool = u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK ? sbc_info->max_bitpool : sbc_info->min_bitpool;
-        sbc_info->codesize = sbc_get_codesize(&sbc_info->sbc);
-        sbc_info->frame_length = sbc_get_frame_length(&sbc_info->sbc);
+        if (!info)
+            return -1;
 
-        pa_log_info("SBC parameters: allocation=%u, subbands=%u, blocks=%u, bitpool=%u",
-                    sbc_info->sbc.allocation, sbc_info->sbc.subbands ? 8 : 4, sbc_info->sbc.blocks, sbc_info->sbc.bitpool);
+        return 0;
     }
 }
 
@@ -1430,9 +1266,7 @@ static int setup_transport(struct userdata *u) {
             return -1; /* We need to fail here until the interactions with module-suspend-on-idle and alike get improved */
     }
 
-    transport_config(u);
-
-    return 0;
+    return transport_config(u);
 }
 
 /* Run from main thread */
@@ -1543,7 +1377,7 @@ static void thread_func(void *userdata) {
             if (have_source) {
 
                 /* We should send two blocks to the device before we expect a response. */
-                if (u->write_index == 0 && u->read_index <= 0)
+                if (have_sink && u->write_index == 0 && u->read_index <= 0)
                     blocks_to_write = 2;
 
                 /* If we got woken up by POLLIN let's do some reading */
@@ -1558,7 +1392,7 @@ static void thread_func(void *userdata) {
                     if (n_read < 0)
                         goto fail;
 
-                    if (n_read > 0) {
+                    if (have_sink && n_read > 0) {
                         /* We just read something, so we are supposed to write something, too */
                         bytes_to_write += n_read;
                         blocks_to_write += bytes_to_write / u->write_block_size;
@@ -1612,12 +1446,12 @@ static void thread_func(void *userdata) {
 
                     if (u->started_at) {
                         time_passed = pa_rtclock_now() - u->started_at;
-                        audio_sent = pa_bytes_to_usec(u->write_index, &u->sample_spec);
+                        audio_sent = pa_bytes_to_usec(u->write_index, &u->encoder_sample_spec);
                     }
 
                     /* A new block needs to be sent. */
                     if (audio_sent <= time_passed) {
-                        size_t bytes_to_send = pa_usec_to_bytes(time_passed - audio_sent, &u->sample_spec);
+                        size_t bytes_to_send = pa_usec_to_bytes(time_passed - audio_sent, &u->encoder_sample_spec);
 
                         /* There are more than two blocks that need to be written. It seems that
                          * the socket has not been accepting data fast enough (could be due to
@@ -1630,7 +1464,7 @@ static void thread_func(void *userdata) {
                             pa_usec_t skip_usec;
 
                             skip_bytes = bytes_to_send - 2 * u->write_block_size;
-                            skip_usec = pa_bytes_to_usec(skip_bytes, &u->sample_spec);
+                            skip_usec = pa_bytes_to_usec(skip_bytes, &u->encoder_sample_spec);
 
                             pa_log_debug("Skipping %llu us (= %llu bytes) in audio stream",
                                         (unsigned long long) skip_usec,
@@ -1650,8 +1484,13 @@ static void thread_func(void *userdata) {
                                 skip_bytes -= bytes_to_render;
                             }
 
-                            if (u->write_index > 0 && u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK)
-                                a2dp_reduce_bitpool(u);
+                            if (u->write_index > 0 && u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK) {
+                                size_t new_write_block_size = u->a2dp_codec->reduce_encoder_bitrate(u->encoder_info, u->write_link_mtu);
+                                if (new_write_block_size) {
+                                    u->write_block_size = new_write_block_size;
+                                    handle_sink_block_size_change(u);
+                                }
+                            }
                         }
 
                         blocks_to_write = 1;
@@ -1680,7 +1519,7 @@ static void thread_func(void *userdata) {
                         if (writable) {
                             /* There was no write pending on this iteration of the loop.
                              * Let's estimate when we need to wake up next */
-                            next_write_at = pa_bytes_to_usec(u->write_index, &u->sample_spec);
+                            next_write_at = pa_bytes_to_usec(u->write_index, &u->encoder_sample_spec);
                             sleep_for = time_passed < next_write_at ? next_write_at - time_passed : 0;
                             /* pa_log("Sleeping for %lu; time passed %lu, next write at %lu", (unsigned long) sleep_for, (unsigned long) time_passed, (unsigned long)next_write_at); */
                         } else
@@ -1824,6 +1663,20 @@ static void stop_thread(struct userdata *u) {
         pa_smoother_free(u->read_smoother);
         u->read_smoother = NULL;
     }
+
+    if (u->profile == PA_BLUETOOTH_PROFILE_A2DP_SINK || u->profile == PA_BLUETOOTH_PROFILE_A2DP_SOURCE) {
+        if (u->encoder_info) {
+            u->a2dp_codec->deinit(u->encoder_info);
+            u->encoder_info = NULL;
+        }
+
+        if (u->decoder_info) {
+            u->a2dp_codec->deinit(u->decoder_info);
+            u->decoder_info = NULL;
+        }
+
+        u->a2dp_codec = NULL;
+    }
 }
 
 /* Run from main thread */
@@ -2211,7 +2064,7 @@ static void handle_transport_state_change(struct userdata *u, struct pa_bluetoot
             /* When the ofono backend resumes source or sink when in the audio gateway role, the
              * state of source or sink may already be RUNNING before the transport is acquired via
              * hf_audio_agent_new_connection(), so the pa_source_suspend() call will not lead to a
-             * state change message. In this case we explicitely need to signal the I/O thread to
+             * state change message. In this case we explicitly need to signal the I/O thread to
              * set up the stream. */
             if (PA_SOURCE_IS_OPENED(u->source->state))
                 pa_asyncmsgq_send(u->source->asyncmsgq, PA_MSGOBJECT(u->source), PA_SOURCE_MESSAGE_SETUP_STREAM, NULL, 0, NULL);
@@ -2303,7 +2156,7 @@ static pa_hook_result_t transport_speaker_gain_changed_cb(pa_bluetooth_discovery
     if (volume < PA_VOLUME_NORM)
         volume++;
 
-    pa_cvolume_set(&v, u->sample_spec.channels, volume);
+    pa_cvolume_set(&v, u->encoder_sample_spec.channels, volume);
     if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
         pa_sink_volume_changed(u->sink, &v);
     else
@@ -2330,7 +2183,7 @@ static pa_hook_result_t transport_microphone_gain_changed_cb(pa_bluetooth_discov
     if (volume < PA_VOLUME_NORM)
         volume++;
 
-    pa_cvolume_set(&v, u->sample_spec.channels, volume);
+    pa_cvolume_set(&v, u->decoder_sample_spec.channels, volume);
 
     if (t->profile == PA_BLUETOOTH_PROFILE_HEADSET_HEAD_UNIT)
         pa_source_volume_changed(u->source, &v);
@@ -2491,11 +2344,11 @@ void pa__done(pa_module *m) {
     if (u->transport_microphone_gain_changed_slot)
         pa_hook_slot_free(u->transport_microphone_gain_changed_slot);
 
-    if (u->sbc_info.buffer)
-        pa_xfree(u->sbc_info.buffer);
+    if (u->encoder_buffer)
+        pa_xfree(u->encoder_buffer);
 
-    if (u->sbc_info.sbc_initialized)
-        sbc_finish(&u->sbc_info.sbc);
+    if (u->decoder_buffer)
+        pa_xfree(u->decoder_buffer);
 
     if (u->msg)
         pa_xfree(u->msg);
diff --git a/src/modules/bluetooth/module-bluez5-discover.c b/src/modules/bluetooth/module-bluez5-discover.c
index 4457821..b6c8eb0 100644
--- a/src/modules/bluetooth/module-bluez5-discover.c
+++ b/src/modules/bluetooth/module-bluez5-discover.c
@@ -36,6 +36,7 @@ PA_MODULE_VERSION(PACKAGE_VERSION);
 PA_MODULE_LOAD_ONCE(true);
 PA_MODULE_USAGE(
     "headset=ofono|native|auto"
+    "autodetect_mtu=<boolean>"
 );
 
 static const char* const valid_modargs[] = {
diff --git a/src/modules/bluetooth/rtp.h b/src/modules/bluetooth/rtp.h
index 20694c1..813d9e3 100644
--- a/src/modules/bluetooth/rtp.h
+++ b/src/modules/bluetooth/rtp.h
@@ -3,6 +3,7 @@
  *  BlueZ - Bluetooth protocol stack for Linux
  *
  *  Copyright (C) 2004-2010  Marcel Holtmann <marcel@holtmann.org>
+ *  Copyright (C) 2019       Pali Rohár <pali.rohar@gmail.com>
  *
  *
  *  This library is free software; you can redistribute it and/or
@@ -19,16 +20,20 @@
  *  License along with this library; if not, see <http://www.gnu.org/licenses/>.
  */
 
-#if __BYTE_ORDER == __LITTLE_ENDIAN
+#include <endian.h>
+#include <stdint.h>
+
+#if defined(__BYTE_ORDER) && defined(__LITTLE_ENDIAN) && \
+	__BYTE_ORDER == __LITTLE_ENDIAN
 
 struct rtp_header {
-	unsigned cc:4;
-	unsigned x:1;
-	unsigned p:1;
-	unsigned v:2;
+	uint8_t cc:4;
+	uint8_t x:1;
+	uint8_t p:1;
+	uint8_t v:2;
 
-	unsigned pt:7;
-	unsigned m:1;
+	uint8_t pt:7;
+	uint8_t m:1;
 
 	uint16_t sequence_number;
 	uint32_t timestamp;
@@ -36,24 +41,25 @@ struct rtp_header {
 	uint32_t csrc[0];
 } __attribute__ ((packed));
 
-struct rtp_payload {
-	unsigned frame_count:4;
-	unsigned rfa0:1;
-	unsigned is_last_fragment:1;
-	unsigned is_first_fragment:1;
-	unsigned is_fragmented:1;
+struct rtp_sbc_payload {
+	uint8_t frame_count:4;
+	uint8_t rfa0:1;
+	uint8_t is_last_fragment:1;
+	uint8_t is_first_fragment:1;
+	uint8_t is_fragmented:1;
 } __attribute__ ((packed));
 
-#elif __BYTE_ORDER == __BIG_ENDIAN
+#elif defined(__BYTE_ORDER) && defined(__BIG_ENDIAN) && \
+	__BYTE_ORDER == __BIG_ENDIAN
 
 struct rtp_header {
-	unsigned v:2;
-	unsigned p:1;
-	unsigned x:1;
-	unsigned cc:4;
+	uint8_t v:2;
+	uint8_t p:1;
+	uint8_t x:1;
+	uint8_t cc:4;
 
-	unsigned m:1;
-	unsigned pt:7;
+	uint8_t m:1;
+	uint8_t pt:7;
 
 	uint16_t sequence_number;
 	uint32_t timestamp;
@@ -61,12 +67,12 @@ struct rtp_header {
 	uint32_t csrc[0];
 } __attribute__ ((packed));
 
-struct rtp_payload {
-	unsigned is_fragmented:1;
-	unsigned is_first_fragment:1;
-	unsigned is_last_fragment:1;
-	unsigned rfa0:1;
-	unsigned frame_count:4;
+struct rtp_sbc_payload {
+	uint8_t is_fragmented:1;
+	uint8_t is_first_fragment:1;
+	uint8_t is_last_fragment:1;
+	uint8_t rfa0:1;
+	uint8_t frame_count:4;
 } __attribute__ ((packed));
 
 #else
-- 
2.20.1

